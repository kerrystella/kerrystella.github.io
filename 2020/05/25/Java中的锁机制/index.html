<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-I5hRpZheEu">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"luischen.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","width":300,"display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="引子说起Java中的并发，有一个永恒的话题就是锁机制。而提及Java中的锁，我们一般认为有两种形式，  通过synchronized关键字的实现 通过Lock接口的实现  网上关于两种方式的对比已经比较详尽，从使用角度来看synchronized关键字方式属于自动档，只需一条指令加锁释放全搞定，而Lock接口实现的锁则相当于手动挡，需要关注加锁、锁中断和解锁的一系列细节，搞不好就得熄火。特别是在J">
<meta property="og:type" content="article">
<meta property="og:title" content="Java中的锁机制">
<meta property="og:url" content="https://luischen.gitee.io/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="路易斯小屋">
<meta property="og:description" content="引子说起Java中的并发，有一个永恒的话题就是锁机制。而提及Java中的锁，我们一般认为有两种形式，  通过synchronized关键字的实现 通过Lock接口的实现  网上关于两种方式的对比已经比较详尽，从使用角度来看synchronized关键字方式属于自动档，只需一条指令加锁释放全搞定，而Lock接口实现的锁则相当于手动挡，需要关注加锁、锁中断和解锁的一系列细节，搞不好就得熄火。特别是在J">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luischen.gitee.io/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/code.png">
<meta property="og:image" content="https://luischen.gitee.io/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/compile.png">
<meta property="article:published_time" content="2020-05-25T01:49:35.000Z">
<meta property="article:modified_time" content="2022-09-02T02:11:29.862Z">
<meta property="article:author" content="Luis Chen">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luischen.gitee.io/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/code.png">


<link rel="canonical" href="https://luischen.gitee.io/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://luischen.gitee.io/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/","path":"2020/05/25/Java中的锁机制/","title":"Java中的锁机制"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java中的锁机制 | 路易斯小屋</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">路易斯小屋</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">同步对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%90%8C%E6%AD%A5"><span class="nav-number">2.1.</span> <span class="nav-text">实例对象同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%90%8C%E6%AD%A5"><span class="nav-number">2.2.</span> <span class="nav-text">类对象同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">可重入性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">公平性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">典型应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Luis Chen"
      src="/uploads/%E8%AF%81%E4%BB%B6%E7%85%A72.jpg">
  <p class="site-author-name" itemprop="name">Luis Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luischen.gitee.io/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/%E8%AF%81%E4%BB%B6%E7%85%A72.jpg">
      <meta itemprop="name" content="Luis Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路易斯小屋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java中的锁机制 | 路易斯小屋">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java中的锁机制
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-25 09:49:35" itemprop="dateCreated datePublished" datetime="2020-05-25T09:49:35+08:00">2020-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">技术总结</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>说起Java中的并发，有一个永恒的话题就是锁机制。而提及Java中的锁，我们一般认为有两种形式，</p>
<ol>
<li>通过synchronized关键字的实现</li>
<li>通过Lock接口的实现</li>
</ol>
<p>网上关于两种方式的对比已经比较详尽，从使用角度来看synchronized关键字方式属于自动档，只需一条指令加锁释放全搞定，而Lock接口实现的锁则相当于手动挡，需要关注加锁、锁中断和解锁的一系列细节，搞不好就得熄火。特别是在JDK1.6对于synchronized关键字做了大量的优化后，已经做到大部分业务都够用了，所以废话不在多，今天的主题：自动档synchronized发车！</p>
<h2 id="同步对象"><a href="#同步对象" class="headerlink" title="同步对象"></a>同步对象</h2><p>通过synchronized关键字修饰的部分我们一般称之为同步块，而同步块的实现是对于同步块指定一个唯一访问的对象。在实现过程中我们会涉及两类同步对象，四种同步代码实现方式。</p>
<h3 id="实例对象同步"><a href="#实例对象同步" class="headerlink" title="实例对象同步"></a>实例对象同步</h3><p>实例对象同步是指同步块的唯一访问对象是一个实例对象，实例对象同步的时候会尝试获取实例对象的monitor，这种时候需要注意的是不同线程如果同步的是同一个类的不同实例，是起不到对象同步的作用的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(test1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(test2).start();</span><br></pre></td></tr></table></figure>

<p>实例对象同步我们又分为两种形式，</p>
<ul>
<li>实例方法的synchronized关键字</li>
<li>实例方法中的synchronized代码块</li>
</ul>
<h3 id="类对象同步"><a href="#类对象同步" class="headerlink" title="类对象同步"></a>类对象同步</h3><p>类对象同步是指同步块的唯一访问对象是一个类对象，类对象同步的时候会尝试获取类对象的monitor。所以在类对象同步的时候我们可能面临过度锁的问题，即类对象中的同步块被线程锁定导致所有类实例都无法被其他线程访问。</p>
<p>类对象同步我们有两种代码实现方式，</p>
<ul>
<li>静态方法的synchronized关键字</li>
<li>静态方法中的synchronized代码块</li>
</ul>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>我们知道synchronized关键字主要是通过JVM层面进行实现，而这时候来看一下JVM的字节码就是一个很有（显）必（逼）要（格）的事情了。针对上面提到的四种代码实现方式，我们简单撸一段代码：</p>
<img src="code.png"/>

<p>然后使用javac先编译成class文件再使用javap来查看字节码。</p>
<img src="compile.png"/>

<p>通过字节码的结果比对我们发现，通过synchronized关键字修饰的同步块都在字节码中以monitorenter和monitorexit的指令形式体现了出来，而通过关键字修饰的方法都没有体现。</p>
<p>难道是加在方法上的关键字不起作用？我们可以反过来想一下，如果针对这两种情况加monitorenter和monitorexit指令我们是加在哪里呢？方法的开头和结尾，那么直接给这个方法加一个标记每次进入这个方法的时候通过标记去获取锁离开的时候再通过标记去释放不就行了吗。所以我们在方法定义下面看到了一行flag，而其中有一个ACC_SYNCHRONIZED正是起到了这个同步标记的作用。</p>
<p>总结起来，synchronized关键字的底层实现分成显式的指令实现和隐式的标记实现。显式实现主要针对同步块，通过将同步块代码包含在monitorenter和monitorexit指令中实现代码块的同步访问。关于monitorenter和monitorexit的实现原理，摘抄官方说明如下：</p>
<blockquote>
<p>monitorenter</p>
<p>​     Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
<p>​     • If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</p>
<p>​     • If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</p>
<p>​     • If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
<p>monitorexit</p>
<p>  The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</p>
<p>​     The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>隐式实现主要针对同步方法，字节码层面通过ACC_SYNCHRONIZED标志位实现。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置。如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。关于monitor的获取释放规则和指令级别的实现一致。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>在synchronized关键字刚刚出现的时候，往往会成为我们性能调优的常客，甚至很多代码规范中明确指出尽可能的避免使用synchronized关键字来实现代码同步。终于在JDK1.6的时候，官方爸爸出手了，优化点包含：</p>
<ol>
<li><p>引入适应性自旋锁</p>
<p>在传统锁实现中，如果线程获取锁失败则进入阻塞，CPU进行状态切换，而往往状态切换的代价是很大的。为了解决这个问题，自旋应运而生，简单来说就是通过不停的尝试直到获取到锁。当等待的任务执行时间较长时，无限制的自旋会浪费CPU时间，一般会给自旋加一个固定的次数限制。适应性自旋则更进一步，由前一次在同一个锁上的自旋时间和锁的拥有者的状态共同决定自旋的次数，如果前一次自旋成功并且当前拥有者正常运行则允许当前自旋占用较多的CPU时间来进行自旋，如果在当前锁上的自旋极少成功则分配较少的自旋次数避免资源浪费。</p>
</li>
<li><p>通过逃逸分析的锁消除</p>
<p>主要是指JIT对于不存在同步访问的同步块进行锁消除操作，具体来说就是在字节码转机器码阶段忽略掉不必要的monitorenter和monitorexit指令。</p>
</li>
<li><p>锁粗化</p>
<p>JIT在进行动态编译的阶段，如果发现前后两个同步块对同一个对象进行加锁，则将锁粗化成一个，避免了反复获取释放锁的开销。</p>
</li>
<li><p>通过锁分级引入偏向锁和轻量锁</p>
<p>锁分级的理念是基于锁的应用场景进行了细分，研究发现在实际应用中大部分的同步场景都出现在无竞争状态，小部分出现在存在少量竞争的场景，还有小部分是存在大量竞争的场景。</p>
<p>针对无竞争场景，提出了偏向锁，通过在对象头中存储偏向的线程ID，下次再进入的时候就可以无代价获取到锁。</p>
<p>针对低竞争场景，推出了轻量锁，通过CAS操作来尝试替换对象头中的线程指向，如果多次自旋失败表明跳出了低竞争场景则进行锁膨胀，升级为重量级锁。</p>
</li>
</ol>
<h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>所谓的可重入性，在锁机制的上下文中我们可以理解为如果一个线程获取了对象的锁之后多次访问对象的同步块都不会发生阻塞。通俗来讲可以理解为，我们获取了一个大房子（对象）的钥匙，那么以后想进哪间房间（同步块）就进哪间房间。</p>
<p>提到可重入性，比较迷惑的是JUC中的ReentrantLock，让人觉得如果要实现锁的可重入性必须使用这个类，事实上synchronized实现的锁默认也是可重入的。</p>
<h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>锁的公平性是指获取锁的顺序严格的按照线程加锁请求到达的顺序，即满足先到先得原则。在Java中synchronized实现的锁是非公平的，而Lock接口的实现中如ReentrantLock中的锁也是默认非公平的。不同点在于synchronized无法实现公平锁，而ReentrantLock可以通过传入参数指定使用公平锁或者非公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>这里主要看一下synchronized在ConcurrentHashMap中的应用。</p>
<p>在JDK1.8中对于ConcurrentHashMap有一项很重要的变更是取消了Segment的使用，取而代之的是使用Node数组结合synchronized的方式对单条记录进行加锁来进一步提高数据结构的并发性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">	<span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			binCount = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">				K ek;</span><br><span class="line">				<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">					((ek = e.key) == key ||</span><br><span class="line">					 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">					oldVal = e.val;</span><br><span class="line">					<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">						e.val = value;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				Node&lt;K,V&gt; pred = e;</span><br><span class="line">				<span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">					pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">											  value, <span class="literal">null</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">			Node&lt;K,V&gt; p;</span><br><span class="line">			binCount = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">										   value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">				oldVal = p.val;</span><br><span class="line">				<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">					p.val = value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Segment是基于ReentrantLock实现的，我们不妨发散一下将这次升级解读成：</p>
<ol>
<li>synchronized的优化到1.8版本已经经过足够的验证可以出现在基础数据结构中</li>
<li>在锁的使用上官方推荐synchronized的方式，后续应该还有持续发力</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们从使用方式和底层实现两个方面出发全面认识了Java中的加锁方式synchronized关键字。特别是经过JDK1.6的脱胎换骨，现在的synchronized关键字已经成为了更多并发实现的首选。通过对锁机制的一般特性如重入性和公平性的理解，我们不难发现不管是synchronized方式还是Lock方式，实现思想上都是一脉相承的。而之所以并存的原因大概也是为了可以通过多种选择的提供达到相互促进的目的吧。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Luis Chen
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://luischen.gitee.io/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/" title="Java中的锁机制">https://luischen.gitee.io/2020/05/25/Java中的锁机制/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag"># 编程语言</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/03/13/%E5%9F%BA%E4%BA%8ESpring-Cloud-Gateway%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E8%B7%B5/" rel="prev" title="基于Spring Cloud Gateway的路由实践">
                  <i class="fa fa-chevron-left"></i> 基于Spring Cloud Gateway的路由实践
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/06/15/%E4%BD%A0%E7%9A%84SpringBoot%E5%8F%AF%E4%BB%A5%E5%90%AF%E5%8A%A8%E7%9A%84%E5%86%8D%E5%BF%AB%E7%82%B9/" rel="next" title="你的SpringBoot可以启动的再快点">
                  你的SpringBoot可以启动的再快点 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luis Chen</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
