<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>InfluxDB备份策略</title>
    <url>/2021/08/19/InfluxDB%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>设备数据采集的时序数据使用InfluxDB进行存储，InfluxDB提供了两大类备份策略来保障数据安全：</p>
<ul>
<li><p>数据库实时主备</p>
<p>实时主备是指通过内置的subscription机制，将主库收到的请求通过go-routine的方式到从库进行重放来实现数据的主备存储。这种方式可以认为是热备。</p>
</li>
<li><p>数据定期备份</p>
<p>定期备份是指通过客户端工具提供的backup命令将数据备份到其他地方进行保存，需要恢复的时候通过restore命令加载数据备份。这种方式根据数据备份的频率存在丢失数据的风险。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h2><h3 id="实时备份"><a href="#实时备份" class="headerlink" title="实时备份"></a>实时备份</h3><p>通过subscription的方式实现主备的架构如下图：</p>
<img src="arch.png" />

<p>首先在InfluxDB的主服务器上通过命令建立订阅，包含如下信息：</p>
<ol>
<li>订阅名称 mysub</li>
<li>订阅的数据库和保留策略 mydb.autogen</li>
<li>数据目的策略，可选ALL（全部发送）和ANY（Round Robin发送任一）</li>
<li>数据目的地，以逗号分隔的目标主机信息</li>
</ol>
<p>创建完成后在主服务器上会生成一个类似路由表的数据结构，数采客户端发送数据（1）到主服务器后，主服务器根据路由策略生成一个或者多个writer（2）将数据同步发送到备库。</p>
<h3 id="全量备份"><a href="#全量备份" class="headerlink" title="全量备份"></a>全量备份</h3><p>全量备份通过influxd命令行工具，主要语法如下：</p>
<img src="command.png" />

<p>基于全量备份的备份恢复策略可以用如下的流程图来表示：</p>
<img src="flow.png" />

<p>每天通过系统定时任务的方式触发 bk_influx.sh 的shell脚本进行数据备份，备份完成后传输到归档位置，可以是挂载的usb设备也可以是用户定义的网络位置。最后备份进行滚动替换，删除过期的备份数据。当数据库损坏或者需要搭建影子环境的时候只需要直接使用restore命令进行恢复即可。</p>
<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><p>增量备份的是在上述全量备份的时候通过指定start和end进行区间过滤，但是start和end的实现上存在缺陷使得我们即使进行了过滤，一样会占用很多的系统资源进行大量的无用数据文件读操作。恢复的时候需要额外写工具进行数据导入。备份恢复的流程如下：</p>
<img src="flow2.png" />

<p>从流程图上看增量备份的备份过程和全量备份基本一致，主要差异有：</p>
<ol>
<li>bk_influx.sh的逻辑差异，备份时需要指定开始结束时间</li>
<li>由于是增量备份，每一个备份都是相对独立的不需要备份替换过程</li>
<li>数据恢复过程需要一个临时库存储增量数据，然后使用工具通过java 客户端从临时库读取数据并写入到主库</li>
</ol>
<h3 id="离线备份"><a href="#离线备份" class="headerlink" title="离线备份"></a>离线备份</h3><p>离线备份是InfluxDB早期版本提供的功能，准确的说应该是在线备份离线恢复，对应于MySQL的物理备份。</p>
<p>在InfluxDB的数据目录结构可以看出数据是分成meta、data和wal三个维度存储的。Meta存储的是元数据例如数据库结构，用户信息等；data目录中以tsm的文件格式存储时序数据；wal目录存储的是预写入日志。离线备份模式下会获取meta和data目录下对应的文件，wal目录下的文件因为没有同步到数据文件不做处理。</p>
<p>离线备份的语法如下，</p>
<img src="command2.png" />

<p>离线备份恢复流程如下：</p>
<img src="flow3.png" />

<ol>
<li>定时任务运行增量备份，备份当前时间对应的shard ID</li>
<li>传输备份数据到指定位置，usb或者网络位置</li>
<li>进行备份恢复之前需要关闭目标服务</li>
<li>运行客户端命令进行离线恢复</li>
<li>启动目标服务检查数据正确性</li>
</ol>
<p>从以上流程可以看出主要的难点有两点:</p>
<ul>
<li><p>如何确定备份的频率</p>
<p>我们通过show retention policies可以确定shard定义的范围。如果一个shard范围是一周，我们可以定义备份的频率为一周，当然小于一周也是可以的，只不过操作的是同一个数据文件在备份的时候进行滚动替换。</p>
</li>
<li><p>如何确定最新的shard ID</p>
<p>通过show shards命令可以确定shard的分布。然后进入到data 目录下找到当前retention policy目录下最大的shard目录即为最新的shard ID。出于完备性考虑，如果某一次备份没有进行则需要从最近一次备份的shard Id进行，所以可以新建文件来保存最近备份的shard ID，这样下次备份只需要找到大于最近备份的shard的所有shard进行备份即可。</p>
<p>获取shard id的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，	获取最近一次备份的shard ID，如无则返回0</span><br><span class="line">2，	遍历data目录，获取大于shard ID的所有文件夹名称</span><br><span class="line">3，	循环进行增量备份</span><br><span class="line">4，	备份完成后更新最近的shard ID</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>InfluxDB 提供了四种备份策略，可以通过下表进行一个简单比较。</p>
<table>
<thead>
<tr>
<th>备份策略</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>数据库主备</td>
<td>实时备份<br />数据安全性较高</td>
<td>架构复杂，系统资源消耗大</td>
<td>需要实现时序数据库高可用的情况</td>
</tr>
<tr>
<td>全量备份</td>
<td>兼容性好<br />恢复操作简单</td>
<td>海量数据的场景备份恢复占<br />用大量的系统资源，<br />影响实时业务</td>
<td>数据量不多（&lt;10G）或者硬件性能<br />较好的情况</td>
</tr>
<tr>
<td>增量备份</td>
<td>备份窗口<br />时间缩短</td>
<td>恢复过程需要引入其他客户端工具，<br />提供的start和end参数存在bug</td>
<td>已有InfluxDB迁移工具的情况</td>
</tr>
<tr>
<td>离线备份</td>
<td>物理备份速度快<br />资源占用少</td>
<td>备份的时候需要管理Shard ID，<br />只能离线恢复并重启服务</td>
<td>数据恢复主要应用于离线分析和影子<br />环境的场景</td>
</tr>
</tbody></table>
<p>从上表可以看出数据库主备的方式架构复杂而且系统资源消耗极大，一般情况下直接忽略。</p>
<p>在项目初期数据量较小的时候可以选择全量备份，减少操作的复杂度。随着数据量的逐渐增加，可以选择增量备份或者离线备份。如果选择增量备份需要自己准备InfluxDB迁移工具用于从临时库到主库的数据迁移，而选择离线备份则需要在备份脚本中增加shard ID的管理，当然因此换来的备份资源大幅缩减还是能值回票价的。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>InfluxDB</tag>
        <tag>数据技术</tag>
      </tags>
  </entry>
  <entry>
    <title>InfluxDB数据接入MQTT</title>
    <url>/2021/12/22/InfluxDB%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%85%A5MQTT/</url>
    <content><![CDATA[<p>在边缘计算场景中数据存储在边缘的时序数据库如 InfluxDB 中，如果不能将数据进行归集以统筹管理则可能形成数据孤岛，无法充分有效的发挥大数据的威力。</p>
<p>边缘端的数据流是数采网关直连InfluxDB，通过restful的方式将采集到的数据发送到时序数据库。这种方式的优点是架构简单，没有中间环节数据传输效率高、实时性有保障。缺点则是可扩展性低，无法满足数据处理、数据转发等需求。</p>
<p>在某大型客户的案例中我们面临的挑战是边缘时序数据需要接入对方的工业互联网平台，鉴于平台支持MQTT方式接入，我们的问题就转化为：<em>边缘时序数据发送到MQTT队列</em></p>
<span id="more"></span>

<h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>在分析了我们现在连接方式后我们总结出三种方案来应对挑战。</p>
<img src="solution.png"/>

<ol>
<li>方案一，网关直接连接MQTT</li>
<li>方案二，定时任务去InfluxDB拉取后发送到MQTT</li>
<li>方案三，模拟一个InfluxDB的订阅者，作为中间层</li>
</ol>
<p>综合来看方案一实现方式比较简单，直接由网关发起双写。缺点是对网关性能要求比较高，同样也面临后期扩展性的问题。</p>
<p>方案二和方案三都是通过增加一个中间层来解决问题，通过中间层可以实现数据预处理、数据分发等功能保留了扩展性。不同点在于方案二采用主动拉取的方式，方案三采用了订阅者模式由InfluxDB推送数据更新到订阅者。相比较而言方案三的实时性更好，性能损耗也相对更小。</p>
<p>最终我们选择方案三作为InfluxDB到MQTT的连接方案。</p>
<img src="solution2.png"/>

<h2 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h2><p>我们从三个方面来依次阐述方案实现：</p>
<h3 id="InfluxDB-设置"><a href="#InfluxDB-设置" class="headerlink" title="InfluxDB 设置"></a>InfluxDB 设置</h3><p>在InfluxDB设置中，订阅是默认开启的。如果已经关闭注意打开即可，配置项段落如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">subscriber</span>]</span><br><span class="line">	<span class="comment"># determine whether the subscriber service is enabled</span></span><br><span class="line">	<span class="string">enable</span> <span class="string">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在完成了配置后需要重启服务生效。然后通过执行语句创建subscription，完成订阅。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SUBSCRIPTION &quot;mysub&quot; <span class="keyword">ON</span> &quot;test&quot;.&quot;autogen&quot; DESTINATIONS <span class="keyword">ALL</span> <span class="string">&#x27;http://192.168.8.181:9090&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其中 mysub 是订阅的名称，test 和 autogen 分别是数据库和保留策略的名称，<a href="http://192.168.8.181:9090/">http://192.168.8.181:9090</a> 是订阅者地址，InfluxDB会将fork的请求发送到这个地址。</p>
<h3 id="订阅者实现"><a href="#订阅者实现" class="headerlink" title="订阅者实现"></a>订阅者实现</h3><p>订阅者实现是整个方案的核心，我们通过类图来说明。</p>
<img src="class-diagram.png" />

<p>Router是订阅者对外暴露的端点，通过receive方法接收请求后将请求流转到Transformer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/write&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">receive</span><span class="params">(<span class="meta">@RequestBody</span> String data)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">mqttdata</span> <span class="operator">=</span> transformer.transform(data);</span><br><span class="line">    gateway.sendToMqtt(mqttdata);</span><br><span class="line">    <span class="keyword">return</span> Mono.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Transformer将数据从InfluxDB的line protocol转换为平台接收的MQTT数据格式，通过MQTT客户端发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">transform</span><span class="params">(String lineData)</span> &#123;</span><br><span class="line">		<span class="type">RootCloudThing</span> <span class="variable">thing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootCloudThing</span>();</span><br><span class="line">		</span><br><span class="line">		String[] lines = lineData.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		List&lt;RootCloudItem&gt; items = Arrays.stream(lines)</span><br><span class="line">				.filter(line-&gt; itemConfigure.isValidLine(line))</span><br><span class="line">				.map(RootCloudItem::buildFromLine).collect(Collectors.toList());</span><br><span class="line">		thing.setItems(items);</span><br><span class="line">		</span><br><span class="line">		Map&lt;String,List&lt;RootCloudThing&gt;&gt; innerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		innerMap.put(<span class="string">&quot;things&quot;</span>, Arrays.asList(thing));</span><br><span class="line">		Map&lt;String,Object&gt; outerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		outerMap.put(<span class="string">&quot;body&quot;</span>, innerMap);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(outerMap);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>transform方法主要实现了line数据的过滤和向RootCloudThing对象的转换，最后以Json格式返回给Router用以发送到MQTT broker。</p>
<h3 id="发送MQTT"><a href="#发送MQTT" class="headerlink" title="发送MQTT"></a>发送MQTT</h3><p>我们基于eclipse paho作为MQTT的客户端实现，pom文件引入如下依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.integration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-integration-mqtt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过配置文件注入配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mqtt configure</span></span><br><span class="line"><span class="string">mqtt.broker.uri=tcp://mqtt-broker-pre.rootcloudapp.com:1883</span></span><br><span class="line"><span class="string">mqtt.broker.username=xxxxxxxx</span></span><br><span class="line"><span class="string">mqtt.broker.passcode=xxxxxxxx</span></span><br><span class="line"><span class="string">mqtt.broker.topic=v4/p/post/thing/live/json/1.1</span></span><br></pre></td></tr></table></figure>

<p>通过ProducerConfigure类实现配置读取并初始化客户端bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mqtt.broker&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConfigure</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String uri;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String passcode;</span><br><span class="line">	<span class="keyword">private</span> String topic;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> MqttPahoClientFactory <span class="title function_">mqttClientFactory</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">DefaultMqttPahoClientFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMqttPahoClientFactory</span>();</span><br><span class="line">		<span class="type">MqttConnectOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttConnectOptions</span>();</span><br><span class="line">		options.setServerURIs(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; uri &#125;);</span><br><span class="line">		options.setUserName(username);		</span><br><span class="line">		options.setPassword(passcode.toCharArray());</span><br><span class="line">		options.setCleanSession(<span class="literal">true</span>);</span><br><span class="line">		factory.setConnectionOptions(options);</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> MessageChannel <span class="title function_">mqttOutboundChannel</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectChannel</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ServiceActivator(inputChannel = &quot;mqttOutboundChannel&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> MessageHandler <span class="title function_">mqttOutbound</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">MqttPahoMessageHandler</span> <span class="variable">messageHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttPahoMessageHandler</span>(username, mqttClientFactory());</span><br><span class="line">		messageHandler.setAsync(<span class="literal">true</span>);</span><br><span class="line">		messageHandler.setDefaultTopic(topic);</span><br><span class="line">		<span class="keyword">return</span> messageHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@MessagingGateway(defaultRequestChannel = &quot;mqttOutboundChannel&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyGateway</span> &#123;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">sendToMqtt</span><span class="params">(String data)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//getter setter ....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>通过方案实现章节的三个步骤我们已经基本实现了一个用于订阅InfluxDB的中间层，反观实现原理和Canal（ <a href="https://github.com/alibaba/canal/">https://github.com/alibaba/canal/</a> ） 有点类似。</p>
<p>通过中间层的引入，在网关直连到InfluxDB的已有方式不需要任何改动的前提下，我们实现了数据的预处理和分发。基于中间层我们可以将时序数据发送到任意目的地，满足数据归集、数据备份、数据展示和数据分析等多种需求。</p>
<p>附源代码地址（版本更新后可能和原文实现有差异）：<a href="https://gitee.com/luischen/databridge">https://gitee.com/luischen/databridge</a></p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>InfluxDB</tag>
        <tag>数据技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的锁机制</title>
    <url>/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>说起Java中的并发，有一个永恒的话题就是锁机制，而提及Java中的锁，我们一般认为有两种形式，</p>
<ol>
<li>通过synchronized关键字的实现</li>
<li>通过Lock接口的实现</li>
</ol>
<p>网上关于两种方式的对比已经比较详尽，从使用角度来看synchronized关键字方式属于自动档，只需一条指令加锁释放全搞定，而Lock接口实现的锁则相当于手动挡，需要关注加锁、锁中断和解锁的一系列细节，搞不好就得熄火。特别是在JDK1.6对于synchronized关键字做了大量的优化后，已经做到大部分业务都够用了，所以废话不在多，今天的主题：自动档synchronized发车！</p>
<h2 id="同步对象"><a href="#同步对象" class="headerlink" title="同步对象"></a>同步对象</h2><p>通过synchronized关键字修饰的部分我们一般称之为同步块，而同步块的实现是对于同步块指定一个唯一访问的对象。在实现过程中我们会涉及两类同步对象，四种同步代码实现方式。</p>
<span id="more"></span>

<h3 id="实例对象同步"><a href="#实例对象同步" class="headerlink" title="实例对象同步"></a>实例对象同步</h3><p>实例对象同步是指同步块的唯一访问对象是一个实例对象，实例对象同步的时候会尝试获取实例对象的monitor，这种时候需要注意的是不同线程如果同步的是同一个类的不同实例，是起不到对象同步的作用的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(test1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(test2).start();</span><br></pre></td></tr></table></figure>

<p>实例对象同步我们又分为两种形式，</p>
<ul>
<li>实例方法的synchronized关键字</li>
<li>实例方法中的synchronized代码块</li>
</ul>
<h3 id="类对象同步"><a href="#类对象同步" class="headerlink" title="类对象同步"></a>类对象同步</h3><p>类对象同步是指同步块的唯一访问对象是一个类对象，类对象同步的时候会尝试获取类对象的monitor。所以在类对象同步的时候我们可能面临过度锁的问题，即类对象中的同步块被线程锁定导致所有类实例都无法被其他线程访问。</p>
<p>类对象同步我们有两种代码实现方式，</p>
<ul>
<li>静态方法的synchronized关键字</li>
<li>静态方法中的synchronized代码块</li>
</ul>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>我们知道synchronized关键字主要是通过JVM层面进行实现，而这时候来看一下JVM的字节码就是一个很有（显）必（逼）要（格）的事情了。针对上面提到的四种代码实现方式，我们简单撸一段代码：</p>
<img src="code.png"/>

<p>然后使用javac先编译成class文件再使用javap来查看字节码。</p>
<img src="compile.png"/>

<p>通过字节码的结果比对我们发现，通过synchronized关键字修饰的同步块都在字节码中以monitorenter和monitorexit的指令形式体现了出来，而通过关键字修饰的方法都没有体现。</p>
<p>难道是加在方法上的关键字不起作用？我们可以反过来想一下，如果针对这两种情况加monitorenter和monitorexit指令我们是加在哪里呢？方法的开头和结尾，那么直接给这个方法加一个标记每次进入这个方法的时候通过标记去获取锁离开的时候再通过标记去释放不就行了吗。所以我们在方法定义下面看到了一行flag，而其中有一个ACC_SYNCHRONIZED正是起到了这个同步标记的作用。</p>
<p>总结起来，synchronized关键字的底层实现分成显式的指令实现和隐式的标记实现。显式实现主要针对同步块，通过将同步块代码包含在monitorenter和monitorexit指令中实现代码块的同步访问。关于monitorenter和monitorexit的实现原理，摘抄官方说明如下：</p>
<blockquote>
<p>monitorenter</p>
<p>​     Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
<p>​     • If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</p>
<p>​     • If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</p>
<p>​     • If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
<p>monitorexit</p>
<p>  The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</p>
<p>​     The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>隐式实现主要针对同步方法，字节码层面通过ACC_SYNCHRONIZED标志位实现。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置。如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。关于monitor的获取释放规则和指令级别的实现一致。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>在synchronized关键字刚刚出现的时候，往往会成为我们性能调优的常客，甚至很多代码规范中明确指出尽可能的避免使用synchronized关键字来实现代码同步。终于在JDK1.6的时候，官方爸爸出手了，优化点包含：</p>
<ol>
<li><p>引入适应性自旋锁</p>
<p>在传统锁实现中，如果线程获取锁失败则进入阻塞，CPU进行状态切换，而往往状态切换的代价是很大的。为了解决这个问题，自旋应运而生，简单来说就是通过不停的尝试直到获取到锁。当等待的任务执行时间较长时，无限制的自旋会浪费CPU时间，一般会给自旋加一个固定的次数限制。适应性自旋则更进一步，由前一次在同一个锁上的自旋时间和锁的拥有者的状态共同决定自旋的次数，如果前一次自旋成功并且当前拥有者正常运行则允许当前自旋占用较多的CPU时间来进行自旋，如果在当前锁上的自旋极少成功则分配较少的自旋次数避免资源浪费。</p>
</li>
<li><p>通过逃逸分析的锁消除</p>
<p>主要是指JIT对于不存在同步访问的同步块进行锁消除操作，具体来说就是在字节码转机器码阶段忽略掉不必要的monitorenter和monitorexit指令。</p>
</li>
<li><p>锁粗化</p>
<p>JIT在进行动态编译的阶段，如果发现前后两个同步块对同一个对象进行加锁，则将锁粗化成一个，避免了反复获取释放锁的开销。</p>
</li>
<li><p>通过锁分级引入偏向锁和轻量锁</p>
<p>锁分级的理念是基于锁的应用场景进行了细分，研究发现在实际应用中大部分的同步场景都出现在无竞争状态，小部分出现在存在少量竞争的场景，还有小部分是存在大量竞争的场景。</p>
<p>针对无竞争场景，提出了偏向锁，通过在对象头中存储偏向的线程ID，下次再进入的时候就可以无代价获取到锁。</p>
<p>针对低竞争场景，推出了轻量锁，通过CAS操作来尝试替换对象头中的线程指向，如果多次自旋失败表明跳出了低竞争场景则进行锁膨胀，升级为重量级锁。</p>
</li>
</ol>
<h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>所谓的可重入性，在锁机制的上下文中我们可以理解为如果一个线程获取了对象的锁之后多次访问对象的同步块都不会发生阻塞。通俗来讲可以理解为，我们获取了一个大房子（对象）的钥匙，那么以后想进哪间房间（同步块）就进哪间房间。</p>
<p>提到可重入性，比较迷惑的是JUC中的ReentrantLock，让人觉得如果要实现锁的可重入性必须使用这个类，事实上synchronized实现的锁默认也是可重入的。</p>
<h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>锁的公平性是指获取锁的顺序严格的按照线程加锁请求到达的顺序，即满足先到先得原则。在Java中synchronized实现的锁是非公平的，而Lock接口的实现中如ReentrantLock中的锁也是默认非公平的。不同点在于synchronized无法实现公平锁，而ReentrantLock可以通过传入参数指定使用公平锁或者非公平锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>这里主要看一下synchronized在ConcurrentHashMap中的应用。</p>
<p>在JDK1.8中对于ConcurrentHashMap有一项很重要的变更是取消了Segment的使用，取而代之的是使用Node数组结合synchronized的方式对单条记录进行加锁来进一步提高数据结构的并发性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">	<span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			binCount = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">				K ek;</span><br><span class="line">				<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">					((ek = e.key) == key ||</span><br><span class="line">					 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">					oldVal = e.val;</span><br><span class="line">					<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">						e.val = value;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				Node&lt;K,V&gt; pred = e;</span><br><span class="line">				<span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">					pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">											  value, <span class="literal">null</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">			Node&lt;K,V&gt; p;</span><br><span class="line">			binCount = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">										   value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">				oldVal = p.val;</span><br><span class="line">				<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">					p.val = value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Segment是基于ReentrantLock实现的，我们不妨发散一下将这次升级解读成：</p>
<ol>
<li>synchronized的优化到1.8版本已经经过足够的验证可以出现在基础数据结构中</li>
<li>在锁的使用上官方推荐synchronized的方式，后续应该还有持续发力</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们从使用方式和底层实现两个方面出发全面认识了Java中的加锁方式synchronized关键字。特别是经过JDK1.6的脱胎换骨，现在的synchronized关键字已经成为了更多并发实现的首选。通过对锁机制的一般特性如重入性和公平性的理解，我们不难发现不管是synchronized方式还是Lock方式，实现思想上都是一脉相承的。而之所以并存的原因大概也是为了可以通过多种选择的提供达到相互促进的目的吧。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2016/05/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="生成的文件目录错乱"><a href="#生成的文件目录错乱" class="headerlink" title="生成的文件目录错乱"></a>生成的文件目录错乱</h3><p>原因是Next主题解析机制是二级目录、三级目录的按级解析，如果文章中出现了跳级的情况就会出现文件目录错乱。修复办法就是使用层层递进的目录定义。</p>
<h3 id="修改每页文章数量"><a href="#修改每页文章数量" class="headerlink" title="修改每页文章数量"></a>修改每页文章数量</h3><p>在hexo的_config.yml中修改per_page配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>一个Slash引发的ClassNotFound血案</title>
    <url>/2019/08/27/%E4%B8%80%E4%B8%AASlash%E5%BC%95%E5%8F%91%E7%9A%84ClassNotFound%E8%A1%80%E6%A1%88/</url>
    <content><![CDATA[<p>公司开发了一款Web应用，开发架构基于Spring Boot，通过jar包的方式发布到服务器并通过命令行运行在内置的Tomcat上。上线将近一年，一切都是那么的风平浪静，然而一切的平静被上周的一次现场算法回访打破。</p>
<p>我们的数据分析人员本意只是想查看一下历史数据来确认算法的表现符合预期，结果发现历史数据查询页面怎么点都没有反应，而其他页面都是正常的，服务重启后一切恢复正常。</p>
<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>虽然问题通过服务重启后成功解决，但是出错的原因没有定位到也就意味着再次出错的可能性依然存在。</p>
<span id="more"></span>

<p>分析问题最直观的方式就是从错误出发，通过错误信息来反向推导错误发生的场景。在这个案例中我们查看了浏览器控制台和后台错误日志，最终获取了准确的错误信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-08-<span class="number">23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">47</span>,<span class="number">835</span> [http-nio-<span class="number">9090</span>-exec-<span class="number">8</span>] ERROR o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].[dispatcherServlet] - Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] in context with path [] threw exception [java.lang.ClassNotFoundException: org.apache.jsp.WEB_002dINF.views.report.report_005fmain_jsp] with root cause</span><br><span class="line">java.lang.ClassNotFoundException: org.apache.jsp.WEB_002dINF.views.report.report_005fmain_jsp</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>)</span><br><span class="line">	at org.apache.jasper.servlet.JasperLoader.loadClass(JasperLoader.java:<span class="number">129</span>)</span><br><span class="line">	at org.apache.jasper.servlet.JasperLoader.loadClass(JasperLoader.java:<span class="number">60</span>)</span><br><span class="line">	at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:<span class="number">159</span>)</span><br><span class="line">	at org.apache.jasper.servlet.JspServletWrapper.getServlet(JspServletWrapper.java:<span class="number">171</span>)</span><br><span class="line">	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:<span class="number">380</span>)</span><br><span class="line">	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:<span class="number">386</span>)</span><br><span class="line">	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:<span class="number">330</span>)</span><br><span class="line">	at javax.servlet.http.HttpServlet.service(HttpServlet.java:<span class="number">742</span>)</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="number">231</span>)</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="number">166</span>)</span><br><span class="line">	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:<span class="number">52</span>)</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="number">193</span>)</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="number">166</span>)</span><br><span class="line">	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:<span class="number">728</span>)</span><br><span class="line">	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:<span class="number">470</span>)</span><br><span class="line">	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个ClassNotFoundException，通过错误信息我们可以在搜索引擎上找到一堆解答，甚至在Spring Boot的Github上都有类似的情况(<a href="https://github.com/spring-projects/spring-boot/issues/5009)%E3%80%82">https://github.com/spring-projects/spring-boot/issues/5009)。</a></p>
<p>结果总结下来就是：</p>
<blockquote>
<p>Spring Boot内置的Tomcat会在系统根目录的&#x2F;tmp下创建Tomcat开头的临时目录，tmp目录的定时清理会导致部分文件的class文件找不到，解决办法是指定一个work目录不要使用默认的tmp目录。</p>
</blockquote>
<p>听起来很有道理，官方都这么说了那照着做就行了呗。</p>
<p>然而作为一个好奇心爆棚的程序员，这样的解释显得苍白而无力，但是这个解释倒是给我们的重现提供了很好的便利，毕竟只有充分重现了这个问题才能更好的去探究深层次的原因。 </p>
<p>于是在官方解释的指导下，我们进行了多次重现的尝试，最终将问题范围缩小如下：</p>
<p><span style="color:red">在Tomcat启动后将tmp下的ROOT目录删除，访问的第一个页面会出现无法访问的情况，后台出现ClassNotFoundException，之后再访问其他页面都是正常。</span></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在进行问题分析的时候，我们一般会使用三种方式</p>
<ul>
<li><p>经验法</p>
<p>结合自身的经验来猜测问题发生的可能原因，然后通过验证来定位问题具体原因</p>
</li>
<li><p>推导法</p>
<p>从问题的发生点开始倒推，沿着问题发生的路径逐步接近问题的根源</p>
</li>
<li><p>分析法</p>
<p>分析整个流程中的每一个节点，找到和问题可能相关的节点逐个验证从而找到导致问题的节点</p>
</li>
</ul>
<hr>
<p>经验法往往是遇到问题时第一个使用的方法，因为面对问题时冲在前面的往往是我们的直觉。在这个问题中我做了以下猜测，并逐一验证。</p>
<ol>
<li><p>class文件损坏</p>
<p>做出这个假设的依据是，在同一个目录下存在两个页面的Class文件，一个可以访问一个不可以访问。</p>
<p>验证方法也很简单，首先重启服务正常访问页面A获取到正常状态下的A.java和A.class文件；重启服务器后删除ROOT目录，再访问页面A触发错误，将目录下的java和class文件替换成正常状态的问题；再次访问页面，依然报错。</p>
<p>至此我们推翻了我们关于Class文件损坏的假设。</p>
</li>
<li><p>dev-tool导致classloader不一致</p>
<p>做出这个假设的依据是我们之前遇到的一个dev-tool的问题，Spring Boot在引入了dev-tool后会进行热加载，这时候由于jar包加载和class加载使用了不同的ClassLoader会出现ClassNotFoundException。</p>
<p>我们之前解决这个问题的方法是去掉dev-tool，同样在这里我们也可以去掉dev-tool再走一遍重现步骤，发现问题依然存在。</p>
<p>至此我们排除了Dev-tool导致ClassLoader不一致的假设。</p>
</li>
<li><p>class文件时间戳</p>
<p>在我们查看正常文件和异常文件差异的时候发现，正常文件的时间戳和jar包中的jsp时间戳一致，而异常文件的时间戳是当前时间，那会不会是因为时间戳不一致导致的呢。</p>
<p>为了验证这个假设我们从两方面入手a) 调整正常文件的时间戳到当前时间，结果正常文件依然正常 b) 调整异常文件的时间戳为jsp的时间，结果异常文件依然无法访问。</p>
<p>于是我们也排除了Class文件时间戳的假设。</p>
</li>
</ol>
<hr>
<p>推导法是比较直观也是可以比较快速的发现问题的方法，但是在我们这个案例中我们发现错误堆栈中的URLClassLoader并不是问题发生的第一现场，真正的第一现场在java自己的包中，对我们逐步跟踪问题造成了困难。</p>
<img src="classloader.png"/>

<hr>
<p>鉴于此我们选择分析法作为我们解决问题的突破口。当然还有一个重要条件支持我们采用分析法解决问题，那就是在我们这个案例中我们存在OK和NOK两种情况，在每一个分析的节点我们都可以引入两种情况进行对比。</p>
<p>在开始之前，由于要每一步比较差异，我们需要配置Eclipse的远程调试。传送门：(<a href="https://www.cnblogs.com/east7/p/10285955.html">https://www.cnblogs.com/east7/p/10285955.html</a>)</p>
<p>首先我们梳理一下Tomcat解析JSP的流程，由于我们基于类来描述流程，所以先罗列一下涉及的类以及主要的方法：</p>
<img src="jsp-class.png"/>

<p>JspServlet类是主入口，接收jsp请求；</p>
<p>JspRuntimeContext通过add和get方法来维持一个ServletWrapper的缓存；</p>
<p>从JspServlet往后是加载的主要类，而从Compiler往后的类是编译用到的类。</p>
<p>在大致了解了内部类结构后我们可以来看看Jsp加载的流程了，</p>
<img src="jsp-flow.png"/>

<p>从图中可以看出我们的报错点在获取Servlet的class这一步，那么我们从页面访问的步骤一步步比较OK和NOK表现的差异。</p>
<ol>
<li><p>获取ServletWrapper</p>
<p>这一步的作用是为每一个Jsp页面构建一个代理并缓存在JspRuntimeContext中，这样每次访问页面直接获取代理即可。从调试的结果看，构建wrapper的每个参数都是一样，而构建的wrapper结果也是一致的。</p>
</li>
<li><p>编译java文件</p>
<p>我们注意到在Complier.class的generateJava这个方法中有一步是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctxt.checkOutputDir();</span><br></pre></td></tr></table></figure>

<p>我们的重现恰恰是删除了ROOT目录，继续进去看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkOutputDir</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outputDir != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(<span class="keyword">new</span> <span class="title class_">File</span>(outputDir)).exists()) &#123;</span><br><span class="line">                makeOutputDir();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createOutputDir();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于一开始的outputDir为空会进入createOutputDir方法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">base</span> <span class="operator">=</span> options.getScratchDir();</span><br><span class="line">            baseUrl = base.toURI().toURL();</span><br><span class="line">            outputDir = base.getAbsolutePath() + File.separator + path +</span><br><span class="line">                    File.separator;</span><br><span class="line">            <span class="keyword">if</span> (!makeOutputDir()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(Localizer.getMessage(<span class="string">&quot;jsp.error.outputfolder&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(Localizer.getMessage(<span class="string">&quot;jsp.error.outputfolder&quot;</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里对baseUrl进行赋值，联想到之前看到一个关于UrlClassPath加载资源的解读，ucp类会根据baseUrl来加载不同的loader进行资源加载。通过debug我们发现这个地方的baseUrl在OK和NOK两种情况下确实存在差异。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NOK：</span><br><span class="line">baseURL = file:/tmp/tomcat.2612162063177545213.9090/work/Tomcat/localhost/ROOT</span><br><span class="line">OK：</span><br><span class="line">baseURL = file:/tmp/tomcat.2612162063177545213.9090/work/Tomcat/localhost/ROOT/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对照ucp的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Loader <span class="title function_">getLoader</span><span class="params">(<span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Loader&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Loader <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> url.getFile();</span><br><span class="line">                    <span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; file.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(url.getProtocol())) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileLoader</span>(url);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JarLoader</span>(url, jarHandler, lmap, acc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException)pae.getException();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现当出现”&#x2F;”的时候我们是通过fileLoader来加载资源，而没有”&#x2F;”的情况我们默认到jarLoader，用jarLoader去加载一个文件路径当然会返回ClassNotFound了。</p>
</li>
</ol>
<hr>
<p>至此我们终于将这个问题的来龙去脉理清楚了，那这一个“&#x2F;”的差异是怎么来的呢，回到那段代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">baseUrl = base.toURI().toURL();</span><br><span class="line">         outputDir = base.getAbsolutePath() + File.separator + path +</span><br><span class="line">                 File.separator;</span><br><span class="line">         <span class="keyword">if</span> (!makeOutputDir()) &#123;</span><br></pre></td></tr></table></figure>

<p>OK和NOK的情况base是一样的，唯一的区别就是OK的情况文件目录都是存在的，而NOK的时候文件夹是没有的，是不是这种差异导致了一个”&#x2F;”的差异呢，还是看代码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//base.toURI():</span></span><br><span class="line"><span class="keyword">public</span> URI <span class="title function_">toURI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> getAbsoluteFile();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sp</span> <span class="operator">=</span> slashify(f.getPath(), f.isDirectory());</span><br><span class="line">            <span class="keyword">if</span> (sp.startsWith(<span class="string">&quot;//&quot;</span>))</span><br><span class="line">                sp = <span class="string">&quot;//&quot;</span> + sp;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;file&quot;</span>, <span class="literal">null</span>, sp, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException x) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);         <span class="comment">// Can&#x27;t happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Slashify():</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">slashify</span><span class="params">(String path, <span class="type">boolean</span> isDirectory)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> path;</span><br><span class="line">        <span class="keyword">if</span> (File.separatorChar != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            p = p.replace(File.separatorChar, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!p.startsWith(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            p = <span class="string">&quot;/&quot;</span> + p;</span><br><span class="line">        <span class="keyword">if</span> (!p.endsWith(<span class="string">&quot;/&quot;</span>) &amp;&amp; isDirectory)</span><br><span class="line">            p = p + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出只有满足isDirectory的判断才会给URI加上”&#x2F;”，在我们NOK的情况下由于文件夹不存在isDirectory返回false不会加上结尾的”&#x2F;”，导致了baseURI的差异，并最终导致了ClassNotFoundException的生产血案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个案例中我们主要使用了经验法和分析法来定位问题，查找本源。</p>
<p>在经验分析的过程中我们遇到了阻碍，转而通过分析法分解了Tomcat对于Jsp请求的处理流程，在分析Jsp编译过程时发现会对baseURI进行赋值，结合我们已有的对URLClassLoader的加载过程的理解，于是我们对于baseURI的处理进行了着重分析。最终发现由于baseURI赋值时系统环境的差异导致了生成的baseURI产生了一个”&#x2F;”的差异，而这一个差异又导致资源加载的加载器选择差异，最终导致不合适的加载器加载不到资源的错误。</p>
<p>在问题的解决上我们还是沿用官方的说法，指定一个tmp url用来存放tomcat的临时文件，避免被删除。</p>
<p>参考材料：</p>
<p><a href="http://www.docjar.com/html/api/sun/misc/URLClassPath.java.html">http://www.docjar.com/html/api/sun/misc/URLClassPath.java.html</a></p>
<p><a href="https://www.jianshu.com/p/b8e331840961">https://www.jianshu.com/p/b8e331840961</a></p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>开发技术</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>一次性能事故的处理和总结</title>
    <url>/2019/07/12/%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E4%BA%8B%E6%95%85%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>前几天做了一个工况统计的功能，查询最近7天的数据然后分析数据的分布。</p>
<p>从一开始接到这个需求就感觉哪里有点不对劲，上线一周后终于迎来了一次爆发：页面响应慢，多次查询后服务不可用。</p>
<span id="more"></span>

<img src="overview.png"/>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从线上环境拉取日志后发现两个异常表现，</p>
<ol>
<li>在进行查询分析的时候，后台会出现超时异常</li>
<li>经历了两到三次的超时异常后，出现了OOM导致系统服务不可用</li>
</ol>
<p>从日志的表现我们可以大致还原一下事故现场。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; 用户点击查询分析功能，服务器开始吭哧吭哧的查询，由于数据量多导致查询的响应速度成为瓶颈</span><br><span class="line">&gt;&gt; 用户在等了好久之后觉得页面是不是挂了，于是刷新页面并重新发起一次查询</span><br><span class="line">&gt;&gt; 服务器重新启动一个线程继续开始漫长的吭哧吭哧之旅</span><br><span class="line">&gt;&gt; 某一次的查询终于达到了熔断点，返回了超时异常，但是内存依然占用无法及时回收</span><br><span class="line">&gt;&gt; 新的操作需要使用内存的时候，出现了OOM异常，系统服务不可用</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>我们从以下两方面进行验证，首先是通过问题重现验证我们关于事故现场的假设，其次通过分析代码来找出支持这种假设的依据。</p>
<h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><p>问题重现很容易，我们从客户现场拿回了全量的数据文件在本地就可以克隆一个现场环境。</p>
<p>然后按照我们设想的步骤进行操作，在第2步的时候等了将近1分钟，页面返回了一个空结果集，然后我们再点击一次查询，没过多久页面出现500错误服务已经不可用。</p>
<p>查看后台日志的表现和线上环境的表现一致，所以我们可以认为我们基本还原了现场。</p>
<p>唯一的不同是我们这边等了近1分钟后页面是有返回一个空的结果集，并不是设想中的一直等待。</p>
<h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><p>查看了该功能的相关代码后，我们定位出几个可能导致问题的代码片段。</p>
<img src="code_verify.png"/>

<ul>
<li>使用了线程池充分利用多线程的优势加快响应速度，这个没问题，但是当线程池被不恰当使用的时候很有可能造成系统资源得不到合理分配，最终导致OOM</li>
<li>在这里通过两个线程分别查询前一天的数据和前七天的数据，事实上这两部分数据是有重复的，多余的查询动作造成了资源的浪费</li>
<li>在线程阻塞的时候设置了15秒和30秒的查询超时时间，这里应该是造成日志中超时异常的根源</li>
</ul>
<h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>结合问题重现和代码验证的结果，我们通过交叉验证进一步的确认症结所在。</p>
<ul>
<li><p>超时问题</p>
<p>在代码验证的过程中我们定位了两个代码片段，接下来我们就修改这两个片段，去掉超时时间的指定，一直等待到执行完成。</p>
<p>原代码：<code>dailyFuture.get(15, TimeUnit.SECONDS);</code></p>
<p>修改后：<code>dailyFuture.get();</code></p>
<p>通过这一步的验证，我们发现整个操作是可以返回结果的，只不过需要等将近2分钟，那么超时问题就转移为慢查询问题了。</p>
<p>接下来我们比较测试数据和线上数据后发现，线上数据比测试数据翻了一倍，原因是现场加大了采集频率，这样导致了我们预先实验出来的超时时间设定不符合数据要求。</p>
<p>由于数据量是我们不可控的，最终针对这个问题我们的解决思路是优化查询，减少查询所需要的时间。优化基线是数据量每天172w点,查询时间30秒，对象转换时间5-10秒。</p>
</li>
<li><p>OOM问题</p>
<p>针对OOM问题我们定位的原因是多线程，于是我们将整个查询过程查询7天的数据都串行化后，发现一次查询的内存占用都在1G以下，由于串行后资源得到及时释放，多次查询也不会造成OOM问题。</p>
<p>对比我们目前的设置，线程池设置的最大大小是30，每天的查询作为一个任务提交，理论上最多会在内存中保留30天的数据，OOM简直是一定的了。这样分析下来我们OOM的问题转移为线程池大小的合理设置问题，当然慢查询问题也是导致OOM问题的一个因素，因为查询一直没有返回导致资源无法被垃圾回收。</p>
</li>
</ul>
<p>总结下来，解决目前问题（超时和服务不可用）的突破口是:</p>
<ol>
<li>优化慢查询</li>
<li>合理设置线程池</li>
</ol>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>通过上面的分析和验证过程我们已经找到了问题的两个突破口，其中设置线程池主要通过不断的优化调整完成，所以解决问题的重点我们放在了优化慢查询上。</p>
<p>我们将整个分布分析过程分解如下：</p>
<img src="query-flow.png"/>

<p>其中Influx查询和客户端对象转换属于我们慢查询的优化范畴，开始优化之前我们明确一下我们优化的基线，</p>
<table>
<thead>
<tr>
<th>数据量</th>
<th>Influx查询用时</th>
<th>对象转换用时</th>
</tr>
</thead>
<tbody><tr>
<td>1728000（20Hz）</td>
<td>30s</td>
<td>5~10s</td>
</tr>
</tbody></table>
<h3 id="Influx查询"><a href="#Influx查询" class="headerlink" title="Influx查询"></a>Influx查询</h3><p>对于Influx查询，我们首先分析执行过程：客户端通过Okhttp发送请求到Influx服务端，服务端执行查询语句，返回结果到客户端。</p>
<p>分析下来影响查询响应时间的因素主要有，</p>
<ol>
<li>传输因素，数据量对于网络传输的时间消耗</li>
<li>服务器因素，服务器负载性能对于influx的查询时间影响</li>
<li>查询语句，查询语句的不合理书写影响了influx的查询性能，如未使用时间和标签等索引</li>
</ol>
<p>首先我们看看我们的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> history <span class="keyword">WHERE</span> item_code<span class="operator">=</span><span class="string">&#x27;%s&#x27;</span> <span class="keyword">and</span> <span class="type">time</span><span class="operator">&gt;=</span><span class="operator">%</span>s <span class="keyword">and</span> <span class="type">time</span><span class="operator">&lt;</span><span class="operator">%</span>s</span><br></pre></td></tr></table></figure>

<p>这个语句使用了time进行筛选，使用了item_code这个标签进行索引查询，但是在返回的结果集中使用了*返回了所有的字段。实际上我们这个需求只需要用到value字段，根据influx的查询接口我们针对每条记录只需要返回长度为2的数组，一个记录时间一个记录value。现在使用了*返回了很多无用的tag字段，结果集相当于翻倍了，改进后的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">value</span> <span class="keyword">FROM</span> history <span class="keyword">WHERE</span> item_code<span class="operator">=</span><span class="string">&#x27;%s&#x27;</span> <span class="keyword">and</span> <span class="type">time</span><span class="operator">&gt;=</span><span class="operator">%</span>s <span class="keyword">and</span> <span class="type">time</span><span class="operator">&lt;</span><span class="operator">%</span>s</span><br></pre></td></tr></table></figure>

<p>仅仅通过这个小小的改动，每次查询的平均时间减少到20s。</p>
<p>顺着这个思路我们进一步缩减结果集，将原来写在代码中的一个过滤条件加入查询语句，最终的查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">value</span> <span class="keyword">FROM</span> history <span class="keyword">WHERE</span> <span class="built_in">ABS</span>(<span class="keyword">value</span>)<span class="operator">&gt;</span> <span class="operator">%</span>s <span class="keyword">and</span> item_code<span class="operator">=</span><span class="string">&#x27;%s&#x27;</span> <span class="keyword">and</span> <span class="type">time</span><span class="operator">&gt;=</span><span class="operator">%</span>s <span class="keyword">and</span> <span class="type">time</span><span class="operator">&lt;</span><span class="operator">%</span>s</span><br></pre></td></tr></table></figure>

<p>优化后的查询时间稳定在15s左右。</p>
<h3 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h3><p>对象转换阶段主要发生在influx客户端，通过InfluxDBResultMapper将服务端的Response转换成Pojo对象。</p>
<p>在这一步中我们定位了几个可能的优化点，</p>
<ol>
<li><p>将Response转换成Pojo相比于直接操作Response，多了一倍的内存占用</p>
<p>InfluxDB这样做可以确保通用性，而对于我们来说没有必要。</p>
</li>
<li><p>转换过程基于反射</p>
<p>为了找到Pojo和字段的对应关系，需要通过反射来保证通用性，我们在已经知道顺序的情况下直接赋值即可。</p>
</li>
<li><p>在遍历结果集的使用的stream而没有使用parallelstream</p>
<p>InfluxDB为了保证结果集解析的顺序性，而在我们的需求中对于顺序没有要求，所以可以利用并行流来提高处理效率。</p>
</li>
</ol>
<p>最终我们的方案是直接解析Response进行分析计算，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;DataItem&gt; <span class="title function_">queryToDataItem</span><span class="params">(String ql, String dbName, String tableName, InfluxDB influxDB)</span> &#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Query</span>(ql, dbName);</span><br><span class="line">            <span class="type">QueryResult</span> <span class="variable">queryResult</span> <span class="operator">=</span> influxDB.query(query, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span>(!CommonUtil.isNullResponse(queryResult)) &#123;</span><br><span class="line">            	<span class="keyword">for</span>(Series s : queryResult.getResults().get(<span class="number">0</span>).getSeries()) &#123;</span><br><span class="line">            		<span class="keyword">if</span>(s.getName().equals(tableName)) &#123;				</span><br><span class="line">            			<span class="keyword">return</span> s.getValues().stream()</span><br><span class="line">            					.map(row -&gt; <span class="keyword">new</span> <span class="title class_">DataItem</span>(</span><br><span class="line">            					((Double)row.get(<span class="number">0</span>)).longValue(),	</span><br><span class="line">            					(Double)row.get(<span class="number">1</span>))).collect(Collectors.toList());        			</span><br><span class="line">            		&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        	</span><br><span class="line">    	&#125;<span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">    		LOG.error(<span class="string">&quot;Exception when query &#123;&#125;&quot;</span>, ex.getMessage());</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这一步优化，我们每一次查询后的转换可以控制在2s之内，而且大大降低了内存使用。反观InfluxDB客户端的实现，这也体现了代码中通用性和运行效率的博弈，我们可以合理利用tradeoff来实现我们的目的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过一起线上的事故作为切入点，首先通过经验进行合理的假设分析，得到一个可以模拟的事故现场。然后通过问题重现、代码定位和交叉验证的方式定位到最终需要解决的问题。在解决问题阶段我们根据我们在解决一般性能问题的经验，迁移到时序数据库性能问题的解决上，而最终的解决方案也证实了性能问题都是相通的。</p>
<p>通过以下表格可以看出我们优化的成效：</p>
<table>
<thead>
<tr>
<th></th>
<th>数据量</th>
<th>Influx查询用时</th>
<th>对象转换用时</th>
</tr>
</thead>
<tbody><tr>
<td>优化前</td>
<td>1728000</td>
<td>30s</td>
<td>5~10s</td>
</tr>
<tr>
<td>优化后</td>
<td>1728000</td>
<td>15s</td>
<td>2s</td>
</tr>
</tbody></table>
<p>也许有人会觉得查询花费将近20s还是有点慢，下面就分享一个这个过程中的趣事。</p>
<hr>
<p>针对这个问题，我和另一个同事分别进行优化。在优化到7次查询用时80s左右的时候，我感觉已经没有多大的余地了，结果他给出了他的优化结果是60s，出于好奇心我又花了一天时间在考虑资源利用最大化的情况下也还是在80左右徘徊。</p>
<p>最后我只能拿着他的方案过来研究一下，结果发现一跑要100多，于是检查一下机器配置后发现他的测试机是DDR4，而我的是DDR3。同样把我的优化方案放到他的机器上跑了一下，7天的查询时间为40s，相当于内存效率差了一倍。</p>
<h3 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h3><p>此外分享在InfluxDB调优中的两个花絮，</p>
<ol>
<li><p>使用chunk的方式并不能提升查询效率</p>
<p>chunk的方式其实是一种数据分页查询，通过串行的方式查询一个个子结果集。优点是可以快速返回并处理，减少资源锁时间。但是在百万级数据上的切分并没有到达查询引擎的临界点，相反增加了建立连接的次数和结果集处理的复杂度。</p>
</li>
<li><p>不使用绑定变量的方式查询速度更快</p>
<p>使用关系型数据库如MySql的经验告诉我们，在查询的时候使用绑定变量可以更加安全并且可以获得较好的查询性能。安全是毋庸置疑的，但是Influx对于更快的查询性能方面似乎没有实现，经过实测使用绑定变量的查询反而会慢一点。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么Java中的String设计成不可变的</title>
    <url>/2020/03/13/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E7%9A%84String%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/</url>
    <content><![CDATA[<p>原文出处：<a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/</a></p>
<p>在Java中String类是不可变的(final)。简单来说，一个不可变的类就意味着他的实例是不可修改的，实例的所有信息都是在实例创建的时候被初始化并且不可被修改。不可变类的设计有很多优点。这篇博文主要从内存，同步和数据结构的角度来具体说明这种不可变的概念。</p>
<span id="more"></span>

<h2 id="String-Pool-的需要"><a href="#String-Pool-的需要" class="headerlink" title="String Pool 的需要"></a>String Pool 的需要</h2><p>String Pool（String intern pool）是在方法区的一块特殊存储区域。当一个String被创建时如果发现当前String已经存在于String Pool，则会返回一个已存在String的引用而不会新建一个对象。以下代码只会创建一个String对象在堆内存中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>下图是创建的过程：</p>
<img src="string-create.png" />

<p>假设一个String是可变的，改变了一个引用指向的String会导致其他引用得到错误的值。</p>
<h2 id="缓存-Hash-Code"><a href="#缓存-Hash-Code" class="headerlink" title="缓存 Hash Code"></a>缓存 Hash Code</h2><p>在Java中，对于String的Hash Code使用是非常频繁的，例如在HashMap或HashSet中。将String设计成不可变可以保证他的Hash Code始终一致，这样Hash Code就可以被缓存并且不用担心变化。这就意味着，不需要在每次使用String的时候都去计算他的Hash Code，这也使得程序运行更加高效。</p>
<h2 id="简化使用"><a href="#简化使用" class="headerlink" title="简化使用"></a>简化使用</h2><p>为了更加详细的阐述，我们考虑以下程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(String a: set)&#123;</span><br><span class="line">	a.value = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果String是可变的，那么就会违背set的设计初衷（set包含不重复的元素）。当然上面的例子只是为了论证，实际上String类中没有value这个字段。我们在使用set的时候同样要注意这个问题，如果set中的元素会发生变化，那么就有可能违背set的不重复设定。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>String在很多Java类中被广泛用作参数，例如网络连接，文件打开等。假设String是可变的，一个连接或者一个文件就可能被改变，这会导致严重的安全隐患。某个方法以为正在连接到一个机器，实际并没有。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSecure(s)) &#123; </span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//here will cause problem, if s is changed before this by using other references.    </span></span><br><span class="line">    causeProblem(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为不可变对象不能被改变，他们还可以在多线程中被自由的共享，这就消除了对象同步的需求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，String被设计成不可变的出发点是效率和安全。这也是不可变类在很多情况下被优先使用的原因。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>你的SpringBoot可以启动的再快点</title>
    <url>/2020/06/15/%E4%BD%A0%E7%9A%84SpringBoot%E5%8F%AF%E4%BB%A5%E5%90%AF%E5%8A%A8%E7%9A%84%E5%86%8D%E5%BF%AB%E7%82%B9/</url>
    <content><![CDATA[<p>公司最近推出了一款一体机产品，于是老板就天天提个小箱子跑客户做POC，倍儿有范儿。跑了一阵子客户反响（问题）不错（不少），其中最大的问题就是开机进系统太慢，按照老板的说法：</p>
<blockquote>
<p>我按下开机键已经准备天花乱坠了，愣是给我一个系统维护界面5分钟才能进去。只好跟他们解释说我们是工业一体机比较严谨，开机前要做好充分的自检。</p>
</blockquote>
<p> 其实开机慢我们是有预期的，我们的应用是云端微服务应用，为了快速响应公司号召稍加改造就变成了边缘应用。在资源配置各方面大幅缩水的情况下，不慢都对不起我们30w行的代码量。 </p>
<p>言归正传，万里长征第一步：重现。通过秒表多次测量的结果显示：</p>
<ul>
<li><p>开机进入维护界面需要30s，</p>
</li>
<li><p>进入登录页需要2分30s，</p>
</li>
<li><p>登录进系统需要近4分钟</p>
</li>
</ul>
<p>虽然没有反馈的那么夸张，这个速度也确实有点慢了。</p>
<span id="more"></span>

<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>基于上面的测量结果，我们可以得到如下分布图：</p>
<img src="time-distribute.png"/>

<p>系统启动时间占比较小，而且在操作系统级别的优化比较复杂收益不高，我们将优化的重心放在应用启动和系统登录两个部分。</p>
<ul>
<li><p>应用启动</p>
<p>我们通过查看应用日志可以发现应用的实际启动时间为109s，这个时间和我们之前实测的时间也比较吻合，可以作为我们应用优化的基线。</p>
</li>
<li><p>系统登录</p>
<p>系统登录时间的消耗看起来不太合理，这是因为我们的应用使用了Eureka作为微服务的注册发现组件，导致了在应用启动后要经历多次心跳验证才能真正可用。这部分的优化策略是在一体机中去掉Eureka，RestTemplate直接访问本机Restful服务即可。</p>
</li>
</ul>
<p>经过以上初步分析，我们明确了我们优化的对象就是109s的应用启动时间。在开始之前我们先说一下我们面临的应用规模，30w业务代码行，800+ spring管理的对象，Jar包大小70M左右。</p>
<h2 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h2><p>通过查阅资料可以找到一些先行者，虽然案例大多是很简单的应用，比如说只有一个依赖的情况优化到1s之内，但是原理上还是相通的。</p>
<h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>我们可以通过@Lazy指定单个bean的延迟初始化，或者通过@ComponentScan指定lazyInit&#x3D;true，也可以实现一个LazyInitBeanFactoryPostProcessor类来灵活的指定。</p>
<p>在实际过程中我们发现不是所有的类都能设置为lazyInit的，比如消息队列的监听类如果一开始不进行实例化那么就永远不会被实例化，这会导致消息永远都不会被消费；还有定时任务类，同样不适合设置成lazyInit。</p>
<p>最终我们采用LazyInitBeanFactoryPostProcessor的方式实现了两个数组进行灵活定制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] COMMON_INIT_LIST= &#123;</span><br><span class="line">		  <span class="string">&quot;springContextUtil&quot;</span>,</span><br><span class="line">		  <span class="string">&quot;custJobFactory&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] CUST_INIT_LIST= &#123;</span><br><span class="line">		  <span class="string">&quot;userMsgReceiver&quot;</span>,</span><br><span class="line">		  <span class="string">&quot;dgnsOperateReceiver&quot;</span>,</span><br><span class="line">		  <span class="string">&quot;equipCondCalcReceiver&quot;</span>,</span><br><span class="line">		  <span class="string">&quot;modelAnalysisReceiver&quot;</span>,</span><br><span class="line">		  <span class="string">&quot;modelAnalysisScheduler&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;	   </span><br><span class="line">	<span class="keyword">if</span>(!needInitBean(beanName)) &#123;</span><br><span class="line">	    <span class="type">BeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(beanName);</span><br><span class="line">		definition.setLazyInit(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">needInitBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ArrayUtils.contains(COMMON_INIT_LIST, beanName) || ArrayUtils.contains(CUST_INIT_LIST, beanName);		  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过延迟初始化，应用启动时间从109s提升到48s，效果非常明显。</p>
<h3 id="JVM启动参数优化"><a href="#JVM启动参数优化" class="headerlink" title="JVM启动参数优化"></a>JVM启动参数优化</h3><p>这里主要涉及的启动参数设置是下面两个：</p>
<ol>
<li><p>-XX:TieredStopAtLevel&#x3D;1</p>
<p>使用C1编译器，又称为客户端模式，相对于C2也就是服务端模式，C1编译生成的机器码更加关注快速启动但是由于机器码没有经过编译优化所以不适合在线上环境稳定运行。</p>
</li>
<li><p>-Xverify:none&#x2F; -noverify</p>
<p>通过去除字节码的验证来提升JVM启动速度，同样不适合线上对安全有要求的环境使用。</p>
</li>
</ol>
<p>我们平时开发的时候可能注意到在IDE如Eclipse中启动一个SpringBoot应用的时候有一个选项叫Fast-startup，如图：</p>
<img src="fast-startup.png"/>

<p>我们一般都是默认勾选的，殊不知这个选项对应的参数就是以上两个JVM参数。</p>
<img src="fast-startup2.png"/>

<p>这两个参数的设置可以大大提升我们本地启动的速度，而本地启动不存在稳定性和安全性的问题，所以适用这两个参数。 </p>
<p>实际案例中我们通过这两个参数的设置，可以将启动时间提升到40s。</p>
<h3 id="生成组件索引"><a href="#生成组件索引" class="headerlink" title="生成组件索引"></a>生成组件索引</h3><p>通过引入Maven依赖spring-context-indexer在编译阶段来为组件生成索引加快类扫描速度。具体做法分为两步：</p>
<ol>
<li><p>添加Maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Maven Plugin</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!--$NO-MVN-MAN-VER$--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过Maven install命令运行后在生成的jar包的META-INF目录下面会生成spring.components文件。如果你的项目是多模块项目，那么在每个模块的jar下面都会生成一个索引文件。</p>
<p>通过这步优化，启动时间可以提升到38s，效果不算明显。这和我们项目本身的规模还有路径扫描的速度有关，如果项目本身类不多或者路径扫描本身很快，那建索引就没有多大意义了，目前看来2s的提升聊胜于无吧。</p>
</li>
</ol>
<h2 id="上下求索"><a href="#上下求索" class="headerlink" title="上下求索"></a>上下求索</h2><p>在通用优化建议的基础上，我们还根据自己的经验和尝试，进行了进一步的优化。</p>
<h3 id="延迟初始化-1"><a href="#延迟初始化-1" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>这次的延迟初始化是从代码层面来进行。通过第一步的延迟初始化处理，我们筛选出一些需要提前初始化的类。而这些类的初始化由于存在类依赖等因素又会牵扯出一大串的初始化，导致我们在少量类的初始化上花费了较多的时间。</p>
<p>举个例子，我们有个消息消费类通过@Autowired强依赖类5个service，那么在这个Receiver类初始化的时候这5个service也会被触发初始化，service类中又通过@Autowired引入了其他类的初始化，层层传递导致一个类的初始化实际触发了几十个类的初始化，已经破坏了我们延迟初始化的设定。</p>
<p>针对这种情况可以在@Autowired字段上加上@Lazy注解，但是容器在注册属性的时候会提示一个warning：AnnotationUtils - Failed to meta-introspect annotation。虽然不影响后续初始化，但是看着还是很糟心的。所以我选择的方式是干脆把这几个需要提前初始化的类里面的@Autowired字段全部移除，使用的时候到ApplicationContext获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EquipCondService condService;</span><br><span class="line"><span class="comment">//替换为使用时获取,做到真正的延迟实例化</span></span><br><span class="line"><span class="type">EquipCondService</span> <span class="variable">condService</span> <span class="operator">=</span> SpringContextUtil.getBean(EquipCondService.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过代码改造之后的延迟初始化升级，启动时间提升到29s，效果还不错。</p>
<h3 id="Shiro初始化优化"><a href="#Shiro初始化优化" class="headerlink" title="Shiro初始化优化"></a>Shiro初始化优化</h3><p>Shiro的问题是通过查看Spring debug日志中的跳变发现的。</p>
<img src="shiro1.png"/>

<p>在正常的日志中一般两个日志的间隔也就几十毫秒，而在shiro的初始化过程中我们发现了一段3s的间隔，那一定是发生了什么不可告人的事情。通过二分查找的Debug终于发现了问题所在。</p>
<p>在shiroConfig中需要定一个securityManager，我们使用了Apache包里自带的DefaultWebSecurityManager。以下是DefaultWebSecurityManager类的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultWebSecurityManager</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>();</span><br><span class="line">	((DefaultSubjectDAO) <span class="built_in">this</span>.subjectDAO).setSessionStorageEvaluator(<span class="keyword">new</span></span><br><span class="line">                                                                     <span class="title class_">DefaultWebSessionStorageEvaluator</span>());</span><br><span class="line">	<span class="built_in">this</span>.sessionMode = HTTP_SESSION_MODE;</span><br><span class="line">	setSubjectFactory(<span class="keyword">new</span> <span class="title class_">DefaultWebSubjectFactory</span>());</span><br><span class="line">	setRememberMeManager(<span class="keyword">new</span> <span class="title class_">CookieRememberMeManager</span>());</span><br><span class="line">	setSessionManager(<span class="keyword">new</span> <span class="title class_">ServletContainerSessionManager</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AbstractRememberMeManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serializer = <span class="keyword">new</span> <span class="title class_">DefaultSerializer</span>&lt;PrincipalCollection&gt;();</span><br><span class="line">        <span class="type">AesCipherService</span> <span class="variable">cipherService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AesCipherService</span>();</span><br><span class="line">        <span class="built_in">this</span>.cipherService = cipherService;</span><br><span class="line">        setCipherKey(cipherService.generateNewKey().getEncoded());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在SecurityManager初始化的时候会初始化依赖的CookieRememberMeManager，最终调用到抽象类的构造函数。在这里有一句话最终造成了3s的启动延时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cipherService.generateNewKey()</span><br></pre></td></tr></table></figure>

<p>这是生成对称加解密密钥的方法，通过单元测试发现这句话单独执行时间也是在3s左右，验证了我们的结论。</p>
<p>解决方法简单粗暴，使用自定义的WebSecurityManager，去掉setRememberMeManager的调用即可。</p>
<p>经过这一步优化后，启动时间优化到26s，刚好是3s的提升。</p>
<h2 id="温故知新"><a href="#温故知新" class="headerlink" title="温故知新"></a>温故知新</h2><p>在一体机开机速度提升的需求驱动下，我们首先甄别出需要解决的关键问题就是应用启动时间。我们通过借鉴先行者的成功经验，成功的将应用启动时间从109s提升到38s。然后从日志分析入手，找出日志中的跳变点，解决了@Autowired引发的伪延迟问题和Shiro生成密钥的时间损耗。最终我们成功的将启动时间控制到了30s之内（26s），而相应的一体机从开机到老板开始天花乱坠也就只需要1分半钟，喝口水就掩饰过去了。</p>
<p>下面罗列一下我们的优化路径，供后续参考借鉴。</p>
<img src="path.png"/>]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>应用技术</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Netty的边缘数采</title>
    <url>/2020/03/13/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%B0%E9%87%87/</url>
    <content><![CDATA[<p>在设备数据采集方面，我们已经探索出一套成熟的做法即在设备侧部署一个边缘程序，通过定时拉取的机制到工控机如PLC的指定位置获取数据。但是对于机器人来说，不同型号的机器人控制设备都有自己不同程度的封装，我们需要严格按照机器人设备的数据开放方式进行定制化实现才有可能正确的获取到数据。</p>
<p>就我们这次研究的FANUC机器人来说，它的数据是通过内置的Socket服务端发送出来的。因此我们的数采方案是在边缘端部署一个相应的Socket客户端与之进行通信，获取数据并进行后续处理。</p>
<span id="more"></span>

<h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p>由于团队的主技术栈是Java， 所以我们决定选用Netty作为构建网络通信客户端的框架。至于为什么使用Netty而不是原生的Java NIO不是本文讨论的重点，可以简单粗暴的认为Netty就是比原生的Java NIO更贴近实际应用场景。</p>
<p>通过分析需求，我们得出如下技术细节分解：</p>
<img src="solution.png"/>

<p>其中多客户端体现了边缘端管理维度的需求，断线重连机制是通讯维度的要求，数据解析和粘包处理是数据处理维度。接下来我们就针对技术细节进行详细的可行性验证。</p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="多客户端"><a href="#多客户端" class="headerlink" title="多客户端"></a>多客户端</h3><p>在Netty中启动一个客户端简单到只需要三句话，虽然链式调用的一句话确实有点长。原始的Netty客户端建立过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">   <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">   bootstrap.group(workerGroup)</span><br><span class="line">	.channel(NioSocketChannel.class)	</span><br><span class="line">	.handler(<span class="keyword">new</span> <span class="title class_">ClientIniterHandler</span>())</span><br><span class="line">	.connect(ip, port).addListener();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>考虑到多客户端的需求，我们对Netty客户端进行了封装，封装后的客户端更加易于管理。</p>
<img src="class-diagram.png" alt=""/>

<p>Starter是启动类，负责读取配置文件并初始化客户端，通过Map&lt;String, NettyClient&gt;的数据结构来管理所有的客户端。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File[] files = FileUtil.getPropertiesFileArr();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesUtil.initProperties(files[i]);</span><br><span class="line">	<span class="type">NettyClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClient</span>(properties);</span><br><span class="line">	clientMap.put(properties.getProperty(<span class="string">&quot;server.ip&quot;</span>)+<span class="string">&quot;:&quot;</span>+properties.getProperty(<span class="string">&quot;server.port&quot;</span>),client);</span><br><span class="line">	client.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NettyClient是封装后的客户端，通过配置文件构造，将配置注入到属性中。DataHandler是数据处理类，主要负责报文解析和数据发送后台数据的工作。每个NettyClient聚合一个DataHandler用于数据处理，避免了并发问题符合Netty串行处理的设计思想。</p>
<h3 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h3><p>针对断线重连功能我们聚焦两个关注点，</p>
<ol>
<li><p>首次连接失败的重试</p>
<p>首次连接我们通过对Connect事件加入Future Listener实现，在Future Listener中监听isSuccess标识位可以获取到连接状态，从而确定下一步动作。加入retryTime字段的控制，当重试次数达到一定次数后降低重试的频率，一定程度上节省资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bootstrap.connect(ip, port).addListener((ChannelFuture futureListener)-&gt;&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> futureListener.channel().eventLoop();</span><br><span class="line">	<span class="keyword">if</span> (!futureListener.isSuccess()) &#123;					</span><br><span class="line">		<span class="comment">// 10s秒之后重连</span></span><br><span class="line">		retryTimes ++;</span><br><span class="line">		<span class="keyword">if</span>(retryTimes &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">			eventLoop.schedule(() -&gt; </span><br><span class="line">doConnect(<span class="keyword">new</span> <span class="title class_">Bootstrap</span>(), eventLoop), <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//超过10次后改成1分钟重试</span></span><br><span class="line">			eventLoop.schedule(() -&gt; </span><br><span class="line">doConnect(<span class="keyword">new</span> <span class="title class_">Bootstrap</span>(), eventLoop), <span class="number">1</span>, TimeUnit.MINUTES);						</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		retryTimes = <span class="number">0</span>;</span><br><span class="line">		LOG.info(<span class="string">&quot;客户端[&#123;&#125;]与服务器连接成功&quot;</span>,id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
<li><p>非首次连接的断线重连</p>
<p>当连接过程中发生断线会触发Inactive事件，在Client Handler的channelInactive监听中进行处理即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> ctx.channel().eventLoop();</span><br><span class="line"><span class="comment">//获取配置信息		</span></span><br><span class="line"><span class="type">NettyClient</span> <span class="variable">client</span> <span class="operator">=</span> getNettyClientByCtx(ctx);</span><br><span class="line"><span class="keyword">if</span>(client != <span class="literal">null</span>) &#123;</span><br><span class="line">	client.doConnect(<span class="keyword">new</span> <span class="title class_">Bootstrap</span>(), eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="16进制解析"><a href="#16进制解析" class="headerlink" title="16进制解析"></a>16进制解析</h3><p>在服务端和客户端通信的过程中通常采用字节流，Netty在接收端通过Pipeline加入编解码器的方式完成字节流和对象之间的转换。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br></pre></td></tr></table></figure>

<p>这里的StringDecoder是字符串解码器，字节流通过解码器的解析就可以转换成String类型，从而方便后续的处理。我们遇到的问题是服务端发送的是16进制数据，因此我们需要的是一个16进制解码器，下面是我们对于两种处理过程的比较。</p>
<img src="compare.png"/>

<p>由此可以看出和一般的处理差异在于服务端多了16进制编码过程，导致客户端也要相应的增加16进制的解码器，考虑实现方便我们将16进制解码器和字符串解码器合并成一个HexDecoder。在ClientInitHander中使用HexDecoder替换原来的StringDecoder。</p>
<p>而HexDecoder的Decode方法主要就是做了两件事情a) 字节到HexString b) HexString到String，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">HEXES</span> <span class="operator">=</span> <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] req = <span class="keyword">new</span> <span class="title class_">byte</span>[msg.readableBytes()];</span><br><span class="line">    msg.readBytes(req);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">hex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">2</span> * req.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; req.length; i++) &#123;</span><br><span class="line">	<span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> req[i];</span><br><span class="line">	hex.append(HEXES.charAt((b &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>))</span><br><span class="line">		.append(HEXES.charAt((b &amp; <span class="number">0x0F</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    out.add(ClientUtil.hexStr2Str(hex.toString()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">hexStr2Str</span><span class="params">(String hexStr)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] hexs = hexStr.toCharArray();</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[hexStr.length() / <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">	n = str.indexOf(hexs[<span class="number">2</span> * i]) * <span class="number">16</span>;</span><br><span class="line">	n += str.indexOf(hexs[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">	bytes[i] = (<span class="type">byte</span>) (n &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的实现16进制数据的解析问题是解决了，我们不禁要好奇一下服务器为啥要弄成16进制传输呢？</p>
<p>结合网上的讨论，下面两点是我比较认可的</p>
<ol>
<li>机器人内部的数据都是二进制01形式的，二进制和十六进制之间转换比较容易</li>
<li>相对十进制来说，十六进制的数据可读性更强，如Ox1064，很容易的看出高四位是0001而这个位置一般会放一些标志位。</li>
</ol>
<h3 id="粘包处理"><a href="#粘包处理" class="headerlink" title="粘包处理"></a>粘包处理</h3><p>粘包是指客户端读取的报文不是一个完整的报文，大多数情况会和拆包结对出现。举个例子，我们的报文结构是<Robot><Item1></Item1></Robot>，当出现粘包的情况时某一次收到的报文就可能是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Robot</span>&gt;</span><span class="tag">&lt;<span class="name">Item1</span>&gt;</span><span class="tag">&lt;/<span class="name">Item1</span>&gt;</span><span class="tag">&lt;/<span class="name">Robot</span>&gt;</span><span class="tag">&lt;<span class="name">Robot</span>&gt;</span><span class="tag">&lt;<span class="name">Item1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而下一次收到的报文就可能是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">Item1</span>&gt;</span><span class="tag">&lt;/<span class="name">Robot</span>&gt;</span><span class="tag">&lt;<span class="name">Robot</span>&gt;</span><span class="tag">&lt;<span class="name">Item1</span>&gt;</span><span class="tag">&lt;/<span class="name">Item1</span>&gt;</span><span class="tag">&lt;/<span class="name">Robot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>粘包的出现由两方面因素构成：</p>
<img src="cause.png"/>

<p>针对粘包现象，Netty提供了三种解决思路，</p>
<img src="solution2.png"/>

<p>了解了三种解决思路之后，我们发现固定长度和长度位两种方案对于服务端都需要改造，而分隔符的解决思路很好的契合了我们这种结构性很强的报文。最终我们选用了DelimiterBasedFrameDecoder，在ChannelInitHander中将Decoder加入Pipeline即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">delimiter</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="string">&quot;&lt;/Robot&gt;&quot;</span>.getBytes());</span><br><span class="line">pipeline.addLast(<span class="string">&quot;delimiter&quot;</span>, <span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="literal">false</span>, delimiter));</span><br></pre></td></tr></table></figure>

<p>DelimiterBasedFrameDecoder需要传入三个参数。</p>
<ol>
<li>第一个参数1024是定义的最大字节长度，当报文长度超出1024，则丢弃该段报文，这个参数根据实际情况调整；</li>
<li>第二个参数false表示分隔符不被忽略也就是说分隔符也是作为报文的一部分需要读取。</li>
<li>第三个参数是传入的分隔符，我们选择结束符</Robot>作为分隔符。</li>
</ol>
<p>通过DelimiterBasedFrameDecoder的引入，我们的报文粘包拆包问题得到了解决。通过分隔符确保在客户端读缓冲区的数据是按照一个完整报文的分段被客户端读取，这种方式规避了服务端改动的复杂性，也避免了服务端和客户端同时修改的不一致性，在数据结构性很强的时候优先选择使用。</p>
<h2 id="总结展望"><a href="#总结展望" class="headerlink" title="总结展望"></a>总结展望</h2><p>在边缘数采的实现中，我们通过基于配置的客户端初始化方案，可以在一个边缘端管理多个客户端程序。通过断线重连机制确保了连接的高可用。16进制数据解析和粘包处理确保可以接收到正确的报文进行后续处理。</p>
<p>通过以上技术细节的实现，最终我们基于Netty搭建了一套符合FANUC机器人数采要求的边缘数采客户端。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>应用技术</tag>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Spring Cloud Gateway的路由实践</title>
    <url>/2020/03/13/%E5%9F%BA%E4%BA%8ESpring-Cloud-Gateway%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>在IT和OT融合的道路上，数据能力是很重要的一环。在设备端我们通过软PLC的解决方案覆盖了常见的数采方式和工业协议，那么采来的海量数据如何存储就成了我们当前的重中之重。</p>
<p>在调研了流行的数据存储方案后，我们决定基于开源时序数据库打造一款工业适用、业务定制的数据存储引擎。而接下来要介绍的路由网关可以认为是整个数据存储引擎的代理人，通过路由网关的引入，极大的透明了数据存储引擎的使用。不管是工业应用还是数采网关抑或是数据分析人员都可以方便的对数据进行读写操作，没有一点负担，没有一点门槛。</p>
<span id="more"></span>

<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Spring Cloud Gateway（下文以SCG代替）， 顾名思义这是由Spring 官方出品的一款网关产品，是Spring Cloud的子项目。再看一下官方介绍：</p>
<blockquote>
<p>This project provides a library for building an API Gateway on top of Spring MVC. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring&#x2F;metrics, and resiliency.</p>
</blockquote>
<p>主要突出了路由功能的简单有效，同时可以在安全、监控以及扩展性方面提供不错的支持，毕竟靠着Spring Cloud这面大树。</p>
<h2 id="架构考虑"><a href="#架构考虑" class="headerlink" title="架构考虑"></a>架构考虑</h2><image src="archi.png"/>

<p>这是官方网站的工作原理示意图，从上图可以看出SCG在整个流程中主要担任反向代理的角色。客户端请求抵达SCG后，SCG通过Handler Mapping将请求路由到Web Handler，Web Handler再通过Filter对原始请求进行处理，最终发送到被代理的服务端。</p>
<p>在研究SCG之前，我们发现Spring Cloud下面已经有一个成熟的API套件Spring Cloud Netflix，提供了服务注册发现（Eureka），熔断器（Hystrix），智能路由（Zuul）和客户端负载均衡（Ribbon）等特性，其中就有我们需要的路由功能Zuul。</p>
<p>那为什么在集成一个路由功能后，Spring Cloud还要自己开发一个用于路由的Gateway项目呢？我们来看看他们的一些对比，由于Spring Cloud只集成了Zuul1.0，所以比较也集中在Zuul1.0和SCG之间。</p>
<table>
<thead>
<tr>
<th></th>
<th>连接方式</th>
<th>支持服务器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Zuul1.0</td>
<td>Servlet API</td>
<td>Tomcat，undertow</td>
<td>基本路由规则，仅支持Path的路由</td>
</tr>
<tr>
<td>SCG</td>
<td>Reactor</td>
<td>Netty</td>
<td>较多路由规则，可以支持header，cookie，query，method等丰富的predict定义</td>
</tr>
</tbody></table>
<p>从上面的对比来看，SCG基于Project Reactor可以获得更优秀的吞吐，在功能方面相当于Zuul的优化，更加灵活的配置可以满足几乎所有的网关路由需求。</p>
<p>虽然说Zuul2.0也是基于Netty开发，并增强了路由和过滤器功能，然而他的多次跳票最终让Spring下决心自己做一款网关路由产品，并表示不会将Zuul2.0集成进以后的Spring Cloud中，也算一段趣闻吧。</p>
<h2 id="网关实践"><a href="#网关实践" class="headerlink" title="网关实践"></a>网关实践</h2><p>下面我们实际动手实现一个网关，结合过程中遇到的问题来熟悉SCG的各项特性。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>我们新建一个基于Spring Boot的Maven项目，添加SCG的依赖，主要是下面两个：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们这里选择的是最新的Spring Boot Release版本（2.1.4）以及支持2.1的Spring Cloud分支Greenwich。 </p>
<p>最后建一个SpringBootApplication，参照首页的Demo去掉Hystrix和RateLimit相关的内容就可以跑起来了（<a href="https://spring.io/projects/spring-cloud-gateway%EF%BC%89%E3%80%82">https://spring.io/projects/spring-cloud-gateway）。</a></p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>光有个Demo肯定不行，我们的网关是要实际投产使用的，在分析了实际需求之后我们识别出急需的第一个功能是动态路由。</p>
<p>在文档中提供了两种方式的路由配置方式：</p>
<ol>
<li><p>通过java API</p>
<p>直接通过RouteLocatorBuilder构建如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builder.routes().route(<span class="string">&quot;path_route&quot;</span>, r -&gt; r.path(<span class="string">&quot;/get&quot;</span>).uri(<span class="string">&quot;http://httpbin.org&quot;</span>)).build();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过配置文件</p>
<p>通过YAML文件构建路由如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">path=/foo/&#123;segment&#125;,/bar/&#123;segment&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>但是我们实际需求中存在动态分配路由的场景，以上两种方式显然都不能满足需求。</p>
<p>通过查看源代码发现SCG加载路由是通过RouteDefinitionLocator接口实现，有以下默认实现（框掉的部分可以暂时忽略，这是我们自己的实现）：</p>
<image src="code1.png"/>

<p>在GatewayAutoConfiguration中通过Primary的方式指定CompositeRouteDefinitionLocator作为路由定义加载的入口，通过组合模式将所有的RouteDefinitionLocator代理。最终通过CompositeRouteDefinitionLocator的getRouteDefinitions方法将所有定义加载出来。</p>
<image src="code2.png"/>

<image src="code3.png"/>

<p>通过源代码的解读，我们发现如果需要定义新的路由加载方式，只需要增加一个RouteDefinitionLocator的实现即可，在实际操作中为了方便路由更新我们仿照已有的实现</p>
<p>InMemoryRouteDefinitionRepository进行实现，类图如下：</p>
<image src="class_diagram.png"/>

<p>我们通过新增了一个抽象类类完成RouteDefinitionRepository的扩展，在抽象类里我们实现了基本的get, save, delete方法，另外新增了refresh方法用于刷新缓存，而缓存的实现参考了InMemory的实现方式。</p>
<p>在需要进行扩展的时候我们可以通过继承AbstractRoutConfigure来增加我们自己的configure loader，再通过Configuration方式注入即可：</p>
<image src="code4.png"/>

<p>最终的实现效果是我们通过数据库变更配置后，通过restful接口来调用refresh方法即可完成路由的动态刷新。</p>
<h3 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h3><p>通过上面动态路由的基本实现，我们数据库中的配置是这样的：</p>
<image src="table.png"/>

<p>但是我们是要做微服务和集群的网关，直接写地址显然是不行的。</p>
<p>针对这种情况，SCG提供了一种URI的格式：lb:&#x2F;&#x2F;main-service，其中main-service是我们微服务在注册中心的name。当URI以lb开头，则在进行URI解析的时候会去寻找zookeeper，consul，eureka对应的客户端实现。我们使用的是eureka，并且在数据库中加上以下配置：</p>
<image src="table2.png"/>

<p>这样我们就可以成功代理微服务提供的接口了。</p>
<h3 id="容错管理"><a href="#容错管理" class="headerlink" title="容错管理"></a>容错管理</h3><p>容错管理从以下两方面进行考虑：</p>
<ol>
<li><p>路由未定义</p>
<p>针对路由未找到的情况，提供有意义的报错信息进行有效反馈。</p>
<p>实现层面主要通过定义一个NotFound的路由，通过设置order确保NotFound路由在所有的路由之后执行，这样当所有的路由都没有匹配上的时候就会被路由到NotFound路由，从而反馈有意义的报错信息。</p>
</li>
<li><p>熔断器</p>
<p>熔断器主要应用于请求超时，服务端错误等使用场景，SCG提供了Hystrix的集成，我们只需要在YAML配置文件里面配置default filter并加入fallbackUri的实现即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hystrix</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">fallbackcmd</span></span><br><span class="line">          <span class="attr">fallbackUri:</span> <span class="string">forward:/fallbackcontroller</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过上面两点的配置，我们在请求出错如超时、服务宕机的情况都可以得到对应的错误信息，确保了网关服务的鲁棒性。</p>
<h3 id="限流机制"><a href="#限流机制" class="headerlink" title="限流机制"></a>限流机制</h3><p>SCG使用的限流机制（Rate Limiter）基于令牌桶算法，我们先大致了解一下令牌桶算法。</p>
<image src="rate.png"/>

<p>从上图可以看出，令牌桶算法的主要数据结构是个缓冲区。通过匀速生成的令牌来填充缓冲区相当于生产者，而实际流量则相当于消费者来消费缓冲区中的令牌。 </p>
<p>我们再结合SCG中的实现来看看令牌桶算法如何限流的。</p>
<p>SCG使用RateLimiter需要引入spring-boot-starter-data-redis-reactive，所以SCG的令牌桶实现是基于Redis的，这样可以满足分布式的要求。SCG在使用过程中需要设置三个参数replenishRate ，burstCapacity和KeyResolver。</p>
<ul>
<li>replenishRate表示的是装桶的速率，也就是令牌生成的速率</li>
<li>burstCapacity表示瞬间高爆发的容量，官方文档解释是一秒内允许的最大流量又补充了一句是令牌桶可以装下的令牌数</li>
<li>KeyResolver很好理解，通过key的定义可以明确规定限流的层级，用户级还是IP级别等等</li>
</ul>
<p>对于burstCapacity的理解，只有当replenishRate和burstCapacity相等时也就是请求处理基本是匀速的情况下，burstCapacity才表示一秒内允许的最大流量，否则解释为令牌桶的容量更加贴切。</p>
<p>代码实现主要通过RedisRateLimiter.class和request_rate_limiter.lua两个文件，而主要逻辑是通过脚本文件实现。</p>
<image src="code5.png"/>

<p>这里主要获取java传过来的参数，计算出ttl，ttl的逻辑是桶装满所需时间的两倍。</p>
<image src="code6.png"/>

<p>上面这段代码是实现限流的关键，每次都会通过当前时间和上次刷新时间的间隔计算填充的令牌，只有填充后的令牌 &gt;&#x3D; 请求的令牌数才符合条件允许令牌获取。</p>
<p>当新的请求获取令牌后，更新令牌桶的令牌数和最后刷新时间。</p>
<p>在实际引用中我们根据我们服务器的压力来设定rate和capacity，通过不停的调节来寻求吞吐和负载的平衡。</p>
<h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>日志配置方面除了基本的logback配置，需要加入access_log的配置，根据官方文档我们需要在logback配置文件中加入logger和appender的配置。</p>
<image src="code7.png"/>

<p>如上图所示，通过定义logger接收netty的AccessLog，通过异步发射器发送到accessLog和errorLog两个Appender，在Appender中通过filter来区分日志类型。 </p>
<p>这里需要注意的是Netty AccessLog的配置要到reactor-netty0.7.9之后才支持，所以在使用这个功能之前需要确保我们netty的版本满足要求，项目目前使用的spring版本如下，对应的reactor-netty版本为0.8.6。</p>
<p>配置了这么多，然而access.log文件还是空空如也，因为你漏掉了很重要的一步：</p>
<p>在启动参数中添加 <code>-Dreactor.netty.http.server.accessLogEnabled=true</code>. 注意这个属性是java系统属性而不是spring配置属性，也就是说只能通过启动参数注入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过一些简单的介绍了解了SCG的出现背景，然后通过实际的网关搭建实践来一步步的理解SCG的架构理念和实现细节。</p>
<p>通过动态路由部分我们见证了SCG的可扩展性架构，在服务路由和容错管理部分我们主要和Spring Cloud已有组件（eureka， hystrix）进行集成，而在限流机制部分我们通过阅读源代码理解了基于令牌桶的限流算法以及如何结合Redis实现分布式系统限流，在日志配置部分主要是结合Netty的日志机制来完成网关的访问日志配置。</p>
<p>在我们的实践中我们没有用上SCG的所有特性，但是就目前的情况用于我们自己的API 网关已经够用。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>应用技术</tag>
      </tags>
  </entry>
  <entry>
    <title>基于jsplumb的流程图实现</title>
    <url>/2018/01/02/%E5%9F%BA%E4%BA%8Ejsplumb%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在系统开发中经常需要展示一些流程，这时候需要用到流程图组件，但是在Echarts这些开源的可视化软件中居然没有流程图的支持。这时候我们的解决方案只能是用div和箭头图片自己实现一些简单的连接，如果流程稍微复杂一点，考虑兼顾功能和美观就需要投入大量的人力和精力进行一些造轮子的动作。</p>
<p>jsplumb的出现一定程度上解决了我们的烦恼。</p>
<span id="more"></span>

<h2 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h2><p>jsplumb是一款开源的javascript类库，基于SVG提供页面元素的连接。jsplumb提供了两个分支：</p>
<ul>
<li>Toolkit Edition商用版，基于社区版本进行封装提供更丰富的API支持</li>
<li>Community Edition社区版，基于MIT和GPL2协议进行开源，提供基础的API功能</li>
</ul>
<p>jsplumb的核心思想是对于页面元素的连接，在这个思想上对于连接进行了抽象，从而形成了jsplumb的几个基本要素：</p>
<ul>
<li><p>Anchor – 锚</p>
<p>锚点主要用来定位一个端点的位置，锚点是一个逻辑上而非实体的概念，用户不可以直接创建，而是通过内部的机制生成</p>
</li>
<li><p>Endpoint – 端点</p>
<p>作为每一个连接的终点而存在，可以通过编程来显式的创建</p>
</li>
<li><p>Connector – 连接器</p>
<p>连接器作为连接的抽象，提供了两个元素之间进行连接的方式</p>
</li>
<li><p>Overlay – 镀层</p>
<p>jsplumb通过镀层的方式给为连接器进行用户友好的展示，如通过label的方式</p>
</li>
<li><p>Group – 分组</p>
<p>通过分组可以将一组元素作为一个整体，从而进行整体的拖拽和收缩等</p>
</li>
</ul>
<blockquote>
<p>一般来说两个端点，一个连接器，0到多个镀层一起工作共同组成了一次连接。每一个端点都有一个关联的锚点。</p>
</blockquote>
<h2 id="技术攻关"><a href="#技术攻关" class="headerlink" title="技术攻关"></a>技术攻关</h2><p>在熟悉了jsplumb主要的概念后，可以通过官方API了解一些主要功能。同时可以通过<a href="https://github.com/jsplumb/jsplumb/tree/master/demo">github</a> 下载官方demo进行学习。通过观察，我们发现官方demo中的flowchart比较符合我们的需求，于是我们下载flowchart的demo源码进行研究改造。原始的demo效果图如下：</p>
<img src="original.png"/>

<p>下面列出几个主要攻关点：</p>
<h3 id="代码合并压缩"><a href="#代码合并压缩" class="headerlink" title="代码合并压缩"></a>代码合并压缩</h3><p>我们发现在demo中引入了一堆js和css，我们通过合并压缩最后形成了下面三个文件，</p>
<ol>
<li><p>jsplumb-link.min.js</p>
<p>包含jsbezier.js，mottle.js，biltong.js和katavorio.js</p>
</li>
<li><p>jsplumb-lib.min.js</p>
<p>包含jsplumb核心类库相关的16个js文件，注意合并的顺序</p>
</li>
<li><p>jsPlumb_process.js</p>
<p>process组件相关的js，基于jsplumb的封装和客户化</p>
</li>
</ol>
<h3 id="去除镀层的文字"><a href="#去除镀层的文字" class="headerlink" title="去除镀层的文字"></a>去除镀层的文字</h3><p>在connectionOverlay定义中发现同时对于箭头和文字都做了定义，直接将对于label的定义去除即可：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">ConnectionOverlays<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">[</span> <span class="string">&quot;Arrow&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">                location<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                visible<span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">                width<span class="punctuation">:</span><span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">                length<span class="punctuation">:</span><span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">                id<span class="punctuation">:</span><span class="string">&quot;ARROW&quot;</span><span class="punctuation">,</span></span><br><span class="line">                events<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                    click<span class="punctuation">:</span>function() <span class="punctuation">&#123;</span> alert(<span class="string">&quot;you clicked on the arrow overlay&quot;</span>)<span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line">    		<span class="comment">/*,</span></span><br><span class="line"><span class="comment">            [ &quot;Label&quot;, &#123;</span></span><br><span class="line"><span class="comment">                location: 0.1,</span></span><br><span class="line"><span class="comment">                id: &quot;label&quot;,</span></span><br><span class="line"><span class="comment">                cssClass: &quot;aLabel&quot;,</span></span><br><span class="line"><span class="comment">                events:&#123;</span></span><br><span class="line"><span class="comment">                    tap:function() &#123; alert(&quot;hey&quot;); &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;]*/</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="禁止新增连接"><a href="#禁止新增连接" class="headerlink" title="禁止新增连接"></a>禁止新增连接</h3><p>在官方demo中可以通过鼠标拖动来新增一条连接，而API并没有对于连接的enable和disable的定义。Github有人回复说通过设置ConnectionsDetachable 属性来实现，实际效果并不能达到目的。</p>
<p>最终在初始化方法中通过两个方法的组合实现了这个功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.<span class="title function_">unmakeEveryTarget</span>().<span class="title function_">unmakeEverySource</span>();</span><br></pre></td></tr></table></figure>

<h3 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h3><p>数据导出功能在社区版不提供方法支持，不过我们可以通过一些简单的变通来实现；而导出功能和加载功能是相对应的，实现了数据的导出就可以基于现有的数据结构来实现数据的初始化加载。以下是导出方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">exportData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> blocks=[];			 </span><br><span class="line">    $(<span class="string">&quot;.w&quot;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">idx, elem</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> elem=$(elem);				</span><br><span class="line">        blocks.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="title class_">BlockId</span>:elem.<span class="title function_">attr</span>(<span class="string">&#x27;id&#x27;</span>),</span><br><span class="line">            <span class="title class_">BlockContent</span>:elem.<span class="title function_">text</span>(),</span><br><span class="line">            <span class="title class_">BlockX</span>:<span class="built_in">parseInt</span>(elem.<span class="title function_">css</span>(<span class="string">&quot;left&quot;</span>), <span class="number">10</span>),</span><br><span class="line">            <span class="title class_">BlockY</span>:<span class="built_in">parseInt</span>(elem.<span class="title function_">css</span>(<span class="string">&quot;top&quot;</span>), <span class="number">10</span>)</span><br><span class="line">        &#125;);				</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> serliza=<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(blocks);</span><br><span class="line">    $(<span class="string">&quot;#outputText&quot;</span>).<span class="title function_">text</span>(serliza);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要思路是获取页面元素的id和名称以及他们和容器的相对位置，最终通过json的格式进行存储。至于元素之间的关系通过业务系统保存和维护。</p>
<p>相应的我们可以实现我们的导入方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loadJson = <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> unpack=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">		<span class="keyword">if</span>(!unpack)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;        </span><br><span class="line">		unpack.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">value, index, array</span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> _block = <span class="built_in">eval</span>(value);</span><br><span class="line">			<span class="title function_">newNodeWithName</span>(_block.<span class="property">BlockId</span>,_block.<span class="property">BlockContent</span>, _block.<span class="property">BlockX</span>, _				block.<span class="property">BlockY</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> newNodeWithName = <span class="keyword">function</span>(<span class="params">id, name, x, y</span>)&#123;</span><br><span class="line">	    <span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        d.<span class="property">className</span> = <span class="string">&quot;w&quot;</span>;</span><br><span class="line">        d.<span class="property">id</span> = id;</span><br><span class="line">        d.<span class="property">innerHTML</span> = name.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">7</span>) + <span class="string">&quot;&lt;div class=\&quot;ep\&quot;&gt;&lt;/div&gt;&quot;</span>;</span><br><span class="line">        d.<span class="property">style</span>.<span class="property">left</span> = x+ <span class="string">&quot;px&quot;</span>;</span><br><span class="line">        d.<span class="property">style</span>.<span class="property">top</span> = y+ <span class="string">&quot;px&quot;</span>;</span><br><span class="line">        instance.<span class="title function_">getContainer</span>().<span class="title function_">appendChild</span>(d);</span><br><span class="line">        <span class="title function_">initNode</span>(d);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现思路是通过解析json获取每一个元素的id和name并通过相对位置在容器中绘制出来。</p>
<h3 id="自动对齐"><a href="#自动对齐" class="headerlink" title="自动对齐"></a>自动对齐</h3><p>通过页面拖动的元素不像传统的流程图工具提供自动对齐的功能，我们基于像素级别对元素对齐进行了基本的约束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def</span><br><span class="line"> X(e) = 元素e的起始横坐标</span><br><span class="line"> Y(e) = 元素e的起始纵坐标</span><br><span class="line"> W(e) = 元素e的宽度</span><br><span class="line"> H(e) = 元素e的高</span><br><span class="line">    </span><br><span class="line">if abs(Diff(X(a),X(b))) between (0, W(a)) set X(a) = X(b)</span><br><span class="line">if abs(Diff(Y(a),Y(b))) between (0, H(a)) set Y(a) = Y(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">autoAlignment</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	   <span class="keyword">var</span> baseX = <span class="title class_">Number</span>($(<span class="string">&quot;.w&quot;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">css</span>(<span class="string">&quot;width&quot;</span>).<span class="title function_">replace</span>(<span class="string">&quot;px&quot;</span>,<span class="string">&quot;&quot;</span>));	   </span><br><span class="line">	   <span class="keyword">var</span> baseY = <span class="title class_">Number</span>($(<span class="string">&quot;.w&quot;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">css</span>(<span class="string">&quot;height&quot;</span>).<span class="title function_">replace</span>(<span class="string">&quot;px&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">	   <span class="keyword">var</span> thatX=<span class="number">0</span>, thatY=<span class="number">0</span>, thisX = <span class="number">0</span>, thisY=<span class="number">0</span>, deltaX = <span class="number">0</span>, deltaY = <span class="number">0</span>;</span><br><span class="line">	   <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">	   <span class="keyword">var</span> eleArray = $(<span class="string">&quot;.w&quot;</span>);</span><br><span class="line">	   <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span> ; i &lt; eleArray.<span class="property">length</span>; i++)&#123;</span><br><span class="line">		 thatX = <span class="title class_">Number</span>($(eleArray[i]).<span class="title function_">css</span>(<span class="string">&quot;left&quot;</span>).<span class="title function_">replace</span>(<span class="string">&quot;px&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">		 thatY = <span class="title class_">Number</span>($(eleArray[i]).<span class="title function_">css</span>(<span class="string">&quot;top&quot;</span>).<span class="title function_">replace</span>(<span class="string">&quot;px&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">	     <span class="keyword">for</span>(<span class="keyword">var</span> j =i+<span class="number">1</span>; j &lt; eleArray.<span class="property">length</span>; j++)&#123;</span><br><span class="line">		   thisX = <span class="title class_">Number</span>($(eleArray[j]).<span class="title function_">css</span>(<span class="string">&quot;left&quot;</span>).<span class="title function_">replace</span>(<span class="string">&quot;px&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">		   thisY = <span class="title class_">Number</span>($(eleArray[j]).<span class="title function_">css</span>(<span class="string">&quot;top&quot;</span>).<span class="title function_">replace</span>(<span class="string">&quot;px&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">		   deltaX = <span class="title class_">Math</span>.<span class="title function_">abs</span>(thisX - thatX);</span><br><span class="line">		   deltaY = <span class="title class_">Math</span>.<span class="title function_">abs</span>(thisY - thatY);</span><br><span class="line">		   <span class="keyword">if</span>(deltaX &lt; baseX &amp;&amp; deltaX &gt;<span class="number">0</span> &amp;&amp; deltaY &gt;=baseY)&#123;</span><br><span class="line">		     <span class="comment">// 需要调整x</span></span><br><span class="line">             $(eleArray[j]).<span class="title function_">css</span>(<span class="string">&quot;left&quot;</span>,thatX+<span class="string">&quot;px&quot;</span>);</span><br><span class="line">		   &#125;</span><br><span class="line"></span><br><span class="line">		   <span class="keyword">if</span>(deltaY &lt; baseY &amp;&amp; deltaY &gt;<span class="number">0</span> &amp;&amp; deltaX &gt;=baseX)&#123;</span><br><span class="line">		     $(eleArray[j]).<span class="title function_">css</span>(<span class="string">&quot;top&quot;</span>,thatY+<span class="string">&quot;px&quot;</span>);</span><br><span class="line">		   &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	   &#125;</span><br><span class="line">	   <span class="comment">//通过repaintEverything完成位置调整后的重绘</span></span><br><span class="line">	   instance.<span class="title function_">repaintEverything</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zoom缩放"><a href="#Zoom缩放" class="headerlink" title="Zoom缩放"></a>Zoom缩放</h3><p>同样由于在社区版不提供zoom的接口，我们只能通过自己来实现zoom功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">setZoom</span> = <span class="keyword">function</span> (<span class="params">zoom, instance0, transformOrigin, el</span>) &#123;</span><br><span class="line">        transformOrigin = transformOrigin || [<span class="number">0.5</span>, <span class="number">0.5</span>];</span><br><span class="line">	    instance = instance || jsPlumb;</span><br><span class="line">	    el = el || instance.<span class="title function_">getContainer</span>();</span><br><span class="line">	    <span class="keyword">var</span> p = [<span class="string">&quot;webkit&quot;</span>, <span class="string">&quot;moz&quot;</span>, <span class="string">&quot;ms&quot;</span>, <span class="string">&quot;o&quot;</span>],</span><br><span class="line">            s = <span class="string">&quot;scale(&quot;</span> + zoom + <span class="string">&quot;)&quot;</span>,</span><br><span class="line">            oString = (transformOrigin[<span class="number">0</span>] * <span class="number">100</span>) + <span class="string">&quot;% &quot;</span> + (transformOrigin[<span class="number">1</span>] * <span class="number">100</span>) + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">        </span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	        el.<span class="property">style</span>[p[i] + <span class="string">&quot;Transform&quot;</span>] = s;</span><br><span class="line">	        el.<span class="property">style</span>[p[i] + <span class="string">&quot;TransformOrigin&quot;</span>] = oString;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    el.<span class="property">style</span>[<span class="string">&quot;transform&quot;</span>] = s;</span><br><span class="line">	    el.<span class="property">style</span>[<span class="string">&quot;transformOrigin&quot;</span>] = oString;</span><br><span class="line"></span><br><span class="line">	    instance.<span class="title function_">setZoom</span>(zoom, <span class="literal">true</span>);</span><br><span class="line">	    instance.<span class="title function_">repaintEverything</span>();</span><br><span class="line">	    </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现思路通过监听事件来设置style属性实现滚动，最终调用重绘方法进行整体调整。需要注意的是监听事件应该绑定到容器的上一层，如下图的外层div部分，否则缩放的是整个页面起不到zoom流程图的初衷</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jtk-canvas canvas-wide process-canvas jtk-surface jtk-surface-nopan&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jtk-surface-canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow:visible !important;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>我们通过对于jsplumb的客户化开发，实现了部分商用版本独有的功能，从而使得基于社区版的应用可以满足复杂业务使用的需求。其中比较核心的是数据交互部分，我们在jsplumb已有概念的基础上将页面元素封装成带有位置信息的组件进行保存和加载，实现了前后端的连接。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>开发技术</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>如何监测配置数据的变化</title>
    <url>/2022/12/29/%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<p>在工业互联网平台上存在多种业务应用，每个应用有自己的配置数据，当配置数据发生变更的时候需要及时的下发到边缘节点让配置生效。我们可以通过节点管理模块提供手动下发的功能，即操作人员修改完配置后通知系统管理员进行对应节点的配置下发。实际操作中发现由于引发配置变更的点过于分散，导致经常会忘记下发而无法使配置及时生效。再者业务操作人员自己并不清楚当前操作的配置是否需要下发，会引发很多无效的沟通，降低了生产效率。</p>
<p>如何在配置发生变化的时候及时监测到变更，由系统自动来引导配置变更流程是我们需要解决的问题，我们通过埋点通知的机制来应对。整体解决方案如下图：</p>
<span id="more"></span>

<img src="配置下发方案.png" alt="配置下发方案" style="zoom: 45%;" />

<p>如图所示，对于每个App的配置变更点，我们抽象一个Point Cut，通过对Point Cut的监控，可以获取配置的变化信息。同时通过MQ通知到节点管理服务，节点管理服务处理节点的配置版本管理。</p>
<p>在整个方案中主要的技术细节有两点：</p>
<ol>
<li>配置变更点的抽象</li>
<li>配置版本管理</li>
</ol>
<p>接下来就针对这两点进行详细的实现。</p>
<h3 id="配置变更点"><a href="#配置变更点" class="headerlink" title="配置变更点"></a>配置变更点</h3><p>APP基于SpringBoot开发，所以在配置变更点上我们选用Spring AOP结合注解的方式。</p>
<h4 id="引入Spring-AOP"><a href="#引入Spring-AOP" class="headerlink" title="引入Spring AOP"></a>引入Spring AOP</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AppConfigureChange &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="监控注解"><a href="#监控注解" class="headerlink" title="监控注解"></a>监控注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**App 配置发生变化的切面*/</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.manu.tbs.foundation.service.aop.AppConfigureChange)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appConfigureOnChange</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning(value=&quot;appConfigureOnChange()&quot;,returning = &quot;retObject&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appConfigurePostChange</span><span class="params">(Object retObject)</span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;app configure post with return &#123;&#125;&quot;</span>,retObject);</span><br><span class="line">    <span class="keyword">if</span>(retObject != <span class="literal">null</span> &amp;&amp; retObject <span class="keyword">instanceof</span> ResponseModel)&#123;</span><br><span class="line">        <span class="type">ResponseModel</span> <span class="variable">responseModel</span> <span class="operator">=</span> (ResponseModel)retObject;</span><br><span class="line">        <span class="keyword">if</span>(responseModel.isSuccess())&#123;</span><br><span class="line">            mySender.sendMessage(SystemMqEnum.Q_UPDATE_APP_CONFIGURE.getQueueName(), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;try to change configure fail.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过创建一个切面方法appConfigureOnChange来进行注解监控，通过AfterReturning获得的返回值类型判断是否需要发送变更通知。</p>
<h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>最后一步就是在可能引发配置变更的方法上加上@AppConfigureChange注解即可完成配置监测。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@AppConfigureChange</span></span><br><span class="line"><span class="keyword">public</span> ResponseModel <span class="title function_">importConfig</span><span class="params">(MultipartFile configFile)</span> &#123;</span><br><span class="line">    <span class="comment">//导入逻辑实现</span></span><br><span class="line">    <span class="keyword">return</span> ResponseModel.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在每次配置导入成功的时候即可监测到配置变化，触发变更通知发送。</p>
<h3 id="配置版本管理"><a href="#配置版本管理" class="headerlink" title="配置版本管理"></a>配置版本管理</h3><p>版本管理主要通过两张表来实现：</p>
<ul>
<li><p>应用配置表记录应用的配置历史记录，可以获取应用当前的最新配置</p>
</li>
<li><p>节点配置表记录节点的最新配置，配置下发成功后更新记录</p>
</li>
</ul>
<img src="data-model.png" alt="image-20221229134322441" style="zoom:80%;" />

<p>节点管理服务接收到配置变更的通知后会更新应用配置表的版本信息。</p>
<table>
<thead>
<tr>
<th>history_id</th>
<th>app_id</th>
<th>version_no</th>
<th>version_seq</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>202212291010</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>202212291020</td>
<td>2</td>
</tr>
</tbody></table>
<p>如上表所示app&#x3D;1的的最新版本为2，页面定时任务通过比对节点的当前版本和应用的最新版本来判断是否需要配置下发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">nodeVersionMatch</span><span class="params">(NodeConfigure nodeConfigure, AppConfigureDTO appConfigure)</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">appConfigure</span> <span class="operator">=</span>= <span class="literal">null</span> </span><br><span class="line">            ||(nodeConfigure != <span class="literal">null</span> </span><br><span class="line">               &amp;&amp;appConfigure.getVersionSeq().equals(nodeConfigure.getVersionSeq()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果判断出节点需要进行配置下发，则在下发结束后更新节点配置，更新完成后节点配置表的数据如下：</p>
<table>
<thead>
<tr>
<th>configure_id</th>
<th>node_id</th>
<th>version_no</th>
<th>version_seq</th>
<th>configure_data</th>
<th>bak_data</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>202212291020</td>
<td>2</td>
<td>{json格式的配置数据}</td>
<td>{上一次下发的配置数据}</td>
</tr>
</tbody></table>
<p>如上表所示节点1的最新配置版本为2，配置数据和配置备份数据都可以被保留下来便于问题定位。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在多应用的场景下如何集中管理配置变更是一个很重要的话题，我们通过基于注解的切面实现了一个灵活易用的监测机制，通过对方法添加注解可以快速埋点。在管理端我们通过应用和节点的版本记录实现了简单版本管理和版本变更的判断逻辑。两者结合之下一个可复用的配置数据监测方案基本成型，具体项目中可以结合实际需求进行扩展和使用。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>开发技术</tag>
      </tags>
  </entry>
  <entry>
    <title>微信登录集成</title>
    <url>/2017/09/01/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>平台上线快一年了，注册人数却始终不见起色，看着下面这注册走势可把大伙儿急的。一着急一上火就刷朋友圈，朋友圈，朋友圈？灵感来了有没有？ </p>
<p>如果我们可以支持微信登录，那么微信日活5.7亿岂不都是我们的潜在客户了？不用多久升职加薪，当上总经理，出任CEO，迎娶白富美，走上人生巅峰。想想还有点小激动呢。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>说干就干，程序员一般套路：<code>代码未动，文档先行</code>。先找到微信开放平台（<a href="https://open.weixin.qq.com)-&gt;/">https://open.weixin.qq.com）-&gt;</a> 资源中心-&gt; 网站应用，把开发文档刷一遍。不管看没看懂咱都是看过源代码，噢不原文档的人了。</p>
<p>象征性的总结一下，主要分三步走：</p>
<ol>
<li>授权换code（开门）</li>
<li>code换token（找钥匙）</li>
<li>token获取用户消息（该干啥干啥）</li>
</ol>
<p>当然，如果你觉得找到了钥匙你就拥有了全世界那你就simple simple了。用着人家的文档，坐拥5.7亿的日活，不交点保护费合适吗？</p>
<p>首先你要在开放平台注册一个账号，并通过开发者资质认证（300大洋一年）。然后到管理中心，创建一个网站应用并通过审核，这个不要钱。</p>
<blockquote>
<p>注:这里面有一个很重要的字段，叫授权回调域，最好和实际开发的回调域名保持一致。</p>
<p>网上很多文章说可以配置成顶级域名，开发使用二级域名，反正我试过这样不通，</p>
<p>错误信息：redirect_uri 参数错误。</p>
</blockquote>
<p>OK，到此为止，你才真正拥有了全世界。</p>
<h2 id="集成设计"><a href="#集成设计" class="headerlink" title="集成设计"></a>集成设计</h2><p>既然是登录集成首先我们需要审视用户模型，我们原来的用户模型是简单的用户密码认证方式，简单来说就是一张主用户表，加一堆外延表。这无疑给我们用户的扩展提供了便利，本着KISS的原则，我们的用户模型最终修改如下：</p>
<img src="user-diagram.png"/>

<p>主要的改动点就是增加了一个t_wx_bind_info表，围绕这个数据模型，我们的逻辑可以如下展开：</p>
<ol>
<li>首次微信登录，获取用户信息后保存至t_wx_bind_info, 此时的微信注册信息处于<strong>游离态</strong>，用户通过后续选择a) 绑定到现有用户 b) 创建新用户 将微信注册用户转化为<strong>激活态</strong></li>
<li>未绑定微信用户登录，用户授权后获取access token，通过token里面的unionId获取加载t_wx_bind_info中游离态的用户信息，用户同样需要通过选择来将<strong>游离态</strong>转化为<strong>激活态</strong></li>
<li>已绑定微信用户登录，用户授权后获取access token，通过token里面的unionId获取t_wx_bind_info中激活态的用户并做正常登陆，之后用户可以通过用户管理模块进行微信解绑</li>
<li>系统账号登录，普通账号可以通过账号管理模块进行账号绑定和解绑</li>
</ol>
<p>也许一张图来的更直观点，</p>
<img src="flow.png"/>

<blockquote>
<p>关于用户解绑后t_wx_bind_info的思考<br>正常来说我们有两个选择，<br>	删除这条信息，每次绑定从头来过<br>	恢复至游离态，下次绑定的时候直接使用<br>至于取舍见仁见智，每个选择都是优劣并存的，其实只要明白各自的优劣使用哪种方案并不重要。</p>
</blockquote>
<h2 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h2><p>俗话说的好，talk is cheap, show me the code.</p>
<p>那接下来就是coding show了，主要是记录一下开发的过程，方便以后用到的时候复制粘贴。</p>
<h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h3><p>登录页面增加微信登录的按钮，至于背景图片可以到开放平台的资源中心下载相应尺寸的背景图片。</p>
<p>给登录按钮添加事件，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dName = <span class="variable language_">document</span>.<span class="property">domain</span>;</span><br><span class="line"><span class="keyword">var</span> redirectUri = </span><br><span class="line">	<span class="built_in">encodeURIComponent</span>(<span class="string">&quot;http://&quot;</span> +dName+<span class="string">&quot;&lt;%=request.getContextPath()%&gt;/wechat_callback.do?rout=fromLogin&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> wechatLoginUrl = </span><br><span class="line">	<span class="string">&quot;https://open.weixin.qq.com/connect/qrconnect?appid=wx62c35d8f6a203158&quot;</span></span><br><span class="line">	+<span class="string">&quot;&amp;redirect_uri=&quot;</span>+redirectUri</span><br><span class="line">	+<span class="string">&quot;&amp;response_type=code&amp;scope=snsapi_login&amp;state=123#wechat_redirect&quot;</span>;</span><br><span class="line">location.<span class="property">href</span> = wechatLoginUrl;</span><br></pre></td></tr></table></figure>

<p>实现的效果，是点击按钮后会跳到微信自己的二维码页面。</p>
<img src="qr-code.png"/>

<p>注意点：</p>
<ul>
<li>RedirectUrl需要经过urlEncode</li>
<li>AppId需要通过微信开发者资质认证后获得</li>
<li>其他参数按照文档填写即可</li>
</ul>
<h3 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h3><p>程序入口是redirectUrl指向的地址，一般是一个restful的资源。类图如下：</p>
<img src="class-diagram.png"/>

<p>在wechatCallback类中有两个分支分别处理扫码登录后的回调和账号登录后绑定微信的回调。主要的区别是重定向的页面和错误页面不同。</p>
<ul>
<li><p>扫码登录</p>
<p>成功后跳转到信息补全页面，失败后跳转到登录页面并提示错误信息。</p>
</li>
<li><p>登录绑定</p>
<p>成功后跳转到当前页面，失败后跳转到当前页面并提示错误信息。</p>
</li>
</ul>
<p>BindService主要处理t_wx_bind_info表的CRUD操作，sync方法用于同步微信信息和账户信息。 </p>
<p>WechatUtil类是连接微信API的工具类，主要逻辑是通过httpClient组装请求信息与微信服务器进行信息交换。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><ol>
<li><p>登录页面</p>
<img src="step1.png"/>
</li>
<li><p>扫码成功</p>
<img src="step2.png"/>
</li>
<li><p>跳转到信息补全，可以选择新创建账号还是绑定已有账号</p>
<img src="step3.png"/>
</li>
<li><p>选择绑定到已有账户，输入用户密码后就直接完成登录并可以看到微信绑定状态是已绑定</p>
<img src="step4.png"/></li>
</ol>
<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul>
<li><p>AppId参数不对</p>
<p>这个问题主要是在开发者资质认证阶段，我随便编个参数遇到的问题，填写正确的appId就可以了</p>
</li>
<li><p>RedirectUrl参数不对</p>
<p>这个问题前面也说过了，在网站申请的时候回调域名一定要和开发的redirectUrl一致。比如申请的回调域名是manulism.com, redirectUrl使用test.manulism.com则会出现这个问题。</p>
</li>
<li><p>本地测试的问题</p>
<p>由于微信平台配置的时候只接受回调域名，所以在本地要测试需要修改hosts文件里的域名mapping，文件目录在C:\Windows\System32\drivers\etc</p>
<p>新增一行：</p>
<p>192.168.8.254  test.manulism.com</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>应用技术</tag>
        <tag>系统集成</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务接口认证</title>
    <url>/2022/05/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>在前后端分离的实践中接口定义问题是无法回避的。关于接口的认证和访问权限设置，这里记录一些个人想法。</p>
<p>首先我们将接口分为几个不同的访问等级：</p>
<ol>
<li>level-1 开放接口，对所有人开放无需认证</li>
<li>level-2 认证接口，仅对认证用户开放，每次访问需要通过用户token进行认证</li>
<li>level-3 内部接口，仅对内部开放，通过内部约定的token进行认证</li>
</ol>
<p>根据接口等级的定义，我们可以得到接口的几种访问形式：</p>
<ul>
<li>服务内部模块调用 </li>
<li>跨服务调用 </li>
<li>前端调用 </li>
<li>第三方调用 </li>
<li>公开调用</li>
</ul>
<span id="more"></span>

<p>最终我们可以汇总出接口的访问矩阵</p>
<table>
<thead>
<tr>
<th>访问方式\接口等级</th>
<th>开放接口L1</th>
<th>认证接口L2</th>
<th>内部接口L3</th>
</tr>
</thead>
<tbody><tr>
<td>服务内部调用</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>跨服务调用</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>前端调用</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>第三方调用</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>公开调用</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>JWT，全称Json Web Tokens，是一个开放的、符合工业标准RFC 7519的认证方法，主要用于满足交互双方的安全需求。</p>
<blockquote>
<p>JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.</p>
</blockquote>
<p>JWT由header,payload和signature三部分组成。</p>
<p>header包含了token类型和加密算法。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>payload是信息的主体，可以包含任何想要传递的信息，但是从安全考虑包含的信息应该是不敏感的信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Test&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>header和payload部分都通过base64UrlEncode对内容进行编码。signature是token的签名部分，主要用于确保token没有被篡改。签名算法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>( <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> + <span class="title function_">base64UrlEncode</span>(payload), secret)</span><br></pre></td></tr></table></figure>

<p>这里的 HMACSHA256 是在header部分指定的加密算法，secret是约定的密钥，是安全的保证。</p>
<img src="encode-decode.png" style="zoom:50%;" />

<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>在实际应用场景中，需要使用到JWT认证的有：</p>
<ul>
<li>用户认证，登录用户需要访问系统接口的情况</li>
<li>模块认证，模块之间接口访问的情况</li>
<li>服务认证，系统之间接口访问的情况</li>
</ul>
<h3 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h3><p>针对用户认证场景，我们定义业务类型为1，在JWT的header中增加字段bizType来描述，即用户认证token的header为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bizType&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在payload中需要包含用户的相关信息，如基础的userId,userName，权限相关的角色信息，授权节点信息。以下是一个示例的payload：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Test&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span><span class="string">&quot;1,2,3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;node&quot;</span><span class="punctuation">:</span><span class="string">&quot;1,2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>JWT 用户认证流程如下：</p>
<ol>
<li><p>获取Token</p>
<img src="user-get-token.png" alt="Image" style="zoom: 67%;" />
</li>
<li><p>接口访问</p>
<img src="user-use-token.png" alt="Image" style="zoom:67%;" />
</li>
<li><p>Token失效</p>
<img src="user-expire-token.png" alt="Image" style="zoom:67%;" /></li>
</ol>
<h3 id="模块认证"><a href="#模块认证" class="headerlink" title="模块认证"></a>模块认证</h3><p>模块认证的目的在于确保内部接口只有内部可以访问，所以对于所有需要访问的模块可以共同约定一个内部Token作为JWT的payload。<br>相对于用户认证的流程，模块认证只需要关注接口访问部分。</p>
<h3 id="服务认证"><a href="#服务认证" class="headerlink" title="服务认证"></a>服务认证</h3><p>服务认证目前考虑节点和主站之间互联的认证问题，和用户认证的Token相比差异主要在payload部分：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;nodeId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而在流程上的差异在于服务注册部分，服务的token通过数据库保存不设置失效时间，除非重新注册。</p>
<h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><p>技术实现上主要包含了Redis存储的格式，结合shiro的验证以及ThreadLocal保存用户信息的三个部分。</p>
<h3 id="Redis数据格式"><a href="#Redis数据格式" class="headerlink" title="Redis数据格式"></a>Redis数据格式</h3><p>JWT在Redis中使用Hash存储，key为固定字符“JWT”，field为userId, field_value为生成的JWT。示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">JWT=<span class="punctuation">&#123;</span><span class="number">1</span>=xxxxxxx<span class="punctuation">,</span><span class="number">2</span>=yyyyyyyyyy<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>考虑认证的流程，客户端传入JWT，通过HVALS获取到所有的JWT，即可判断传入的JWT是否合法。</p>
<p>在重新登录或者修改用户信息的场景中，只需要将对应userId的value删除或者替换即可。</p>
<h3 id="结合shiro的验证"><a href="#结合shiro的验证" class="headerlink" title="结合shiro的验证"></a>结合shiro的验证</h3><p>在shiro中通过设置不同的Realm来应对不同业务场景的认证：</p>
<ul>
<li><p>UserJWTRealm </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doGetAuthenticationInfo：</span><br><span class="line">  首先判断当前token是否过期</span><br><span class="line">  判断当前token是否包含在redis token列表中</span><br><span class="line">  返回认证结果  </span><br><span class="line"></span><br><span class="line"><span class="attr">supports</span>:</span><br><span class="line">  当前token类型是<span class="title class_">JWTToken</span>，并且header中获取的bizType=<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>InnerJWTRealm</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doGetAuthenticationInfo：</span><br><span class="line">  首先判断当前token是否过期</span><br><span class="line">  判断当前token是否和预置的<span class="title class_">InnerToken</span>一致</span><br><span class="line">  返回认证结果  </span><br><span class="line"></span><br><span class="line"><span class="attr">supports</span>:</span><br><span class="line">  当前token类型是<span class="title class_">JWTToken</span>，并且header中获取的bizType=<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SystemJWRealm</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doGetAuthenticationInfo：</span><br><span class="line">  首先判断当前token是否过期</span><br><span class="line">  判断当前token在<span class="title class_">MySQL</span>中获取的node是否有效</span><br><span class="line">  返回认证结果  </span><br><span class="line"></span><br><span class="line"><span class="attr">supports</span>:</span><br><span class="line">  当前token类型是<span class="title class_">JWTToken</span>，并且header中获取的bizType=<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal主要用于存储JWT中携带的认证信息，避免了重复解析以及可能的接口调用造成的资源浪费。</p>
<p>ThreadLocal主要存储线程变量，即同一个线程中可以共享的信息。以用户认证为例，完成认证后将用户信息存储到线程变量中，可以在后续的接口调用中进行信息共享。</p>
<p>首先在JWTService中定义全局变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;JWTUser&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">&quot;====&quot;</span>+threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在验证完成的方法中将解析出的JWTUser 对象存入threadLocal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JWTService.threadLocal.set(user.mock());</span><br></pre></td></tr></table></figure>

<p>在使用的时候就可以直接调用获取到JWTUser对象了，详见JWTService的test方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们针对于目前系统中使用的需求，梳理了JWT结合Shiro用于系统认证的三个场景。从流程上分为获取token，使用token和token失效三个主要节点，每个场景针对不同流程节点又有各自的需求。</p>
<p>对于场景和流程节点的需求排列，最终从技术上回归到了三个主要的技术点，Redis、Shiro和ThreadLocal。通过Redis合理的数据结构存储、Shiro Filter机制的分级认证和ThreadLocal的线程变量简化，共同串联起当前的认证流程。</p>
<p>对于JWT来说，Token的过期机制会直接影响到系统的安全性。鉴于目前服务都是在系统闭环内完成，暂时不考虑对于过期机制进行过多设计，仅考虑由于重新申请令牌的过期处理。后续如果接入了第三方系统，或者作为一个开放平台来说需要加强这方面的考虑。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>时序数据可视化的降采样算法</title>
    <url>/2021/09/18/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E9%99%8D%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>工业场景中，时序数据的可视化是一个无法回避的话题。时序数据的超大数据量给图形的展示性能带来了挑战，而通过降采样的方式减少图形的展示点数来迎合性能的同时，又会带来算法复杂度、算法可伸缩以及正确性等多方面的权衡。</p>
<p>下面通过几种常用的可视化降采样算法的研究和实践对比，为时序数据的可视化降采样算法选择提供参考。我们使用实际生产中的一个案例作为算法描述的基础：需求将10w点降采样到4000，以适配页面的展示效果。</p>
<span id="more"></span>

<h2 id="直觉分桶算法"><a href="#直觉分桶算法" class="headerlink" title="直觉分桶算法"></a>直觉分桶算法</h2><p>在一般情况下，面对一个复杂问题最先起作用的往往是我们的直觉。所以在面对大数据集降采样的问题时最先想到的这类算法统称之为直觉算法。</p>
<h3 id="Mode-Median-Bucket"><a href="#Mode-Median-Bucket" class="headerlink" title="Mode-Median-Bucket"></a>Mode-Median-Bucket</h3><p>模式中位数分桶算法，从大类来看是一个分桶算法，从取样方式来看分成了众数取样和中位数取样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先确定桶的数量即threshold等于4000，那么被分配到每个桶的数据点就是25。</span><br><span class="line">遍历每个桶：</span><br><span class="line">	查看桶中是否存在唯一众数，如果存在则应用众数模式，选取众数的最左边点作为桶的代表点</span><br><span class="line">	如果不满足众数模式，则选取桶内点的中位数作为桶的代表点</span><br><span class="line"></span><br><span class="line">作为特殊考虑，如果是第一个桶则选取第一个点，最后一个桶则选取最后一个点，从而确保整个数据集的趋势完整性。</span><br></pre></td></tr></table></figure>

<h3 id="Min-Std-Error-Bucket"><a href="#Min-Std-Error-Bucket" class="headerlink" title="Min-Std-Error-Bucket"></a>Min-Std-Error-Bucket</h3><p>最小标准误差分桶算法，从大类来看是一个分桶算法，从取样方式来看基于线性回归采用标准误差（SEE - standard error of estimate）公式作为取样的依据。</p>
<img src="mseb1.png" />

<img src="mseb2.png" />

<img src="mseb3.png" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先确定桶的数量即threshold等于4000，首尾两个桶都只包含一个点确保数据集的起点和终点被选中，其他点平均分配到桶。</span><br><span class="line"></span><br><span class="line">1， 将每个桶中的点和后一个桶的点两两连成线段，每个线段记为一条边</span><br><span class="line">2， 对于每条边，计算所有x方向穿过的点到边的距离e</span><br><span class="line">3， 通过这些距离结合SEE公式计算边的标准误差作为边的权重</span><br><span class="line"></span><br><span class="line">至此，我们得到了一组带权重的边构成的DAG有向无环。</span><br><span class="line">只需要使用图的最短路径算法（如Dijkstra’s algorithm）就可以得到构成最短标准误差的那些点了。</span><br></pre></td></tr></table></figure>

<p>算法的主要缺陷在于选取最小标准误差的时候总是将图形变的平滑，所以局部的极值和全局的极值总是被忽略。</p>
<h3 id="Longest-Line-Bucket"><a href="#Longest-Line-Bucket" class="headerlink" title="Longest-Line-Bucket"></a>Longest-Line-Bucket</h3><p>最长线段分桶算法，相对于MSEB算法保留了局部极值和全局极值，算法过程类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1， 将每个桶的点和下一个桶的点两两连线段，每个线段记为一条边</span><br><span class="line">2， 计算每个边的长度，记为边的权重</span><br><span class="line"></span><br><span class="line">至此，我们得到了一组带权重的边构成的DAG，需要计算图的最大路径。</span><br><span class="line">由于路径的权重都是正值，所以可以简单的取反转换为计算图的最短路径问题。</span><br></pre></td></tr></table></figure>

<h2 id="制图泛化技术"><a href="#制图泛化技术" class="headerlink" title="制图泛化技术"></a>制图泛化技术</h2><p>上面描述的三个直觉算法一定程度上都能够解决问题，然而又或多或少引入了新的问题。比如MMB可能带来短视的问题，MSEB和LLB引入了额外的复杂度和效率问题。我们参考了几个制图泛化的技术，对直觉分桶算法进行改进。</p>
<h3 id="Douglas-Peucker-algorithm"><a href="#Douglas-Peucker-algorithm" class="headerlink" title="Douglas-Peucker algorithm"></a>Douglas-Peucker algorithm</h3><p>多边形逼近算法，通过递归来逐步逼近原图形效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先定义一个threshold（注意这个threshold和桶没有关系）表示点到线段的最大距离。</span><br><span class="line"></span><br><span class="line">1，	连接首尾点构成初始线段AB</span><br><span class="line">2，	计算AB中间的所有点到AB的垂直距离，获取垂直距离最大的点C和垂直距离e</span><br><span class="line">3，	如果e &lt;= threshold，则AB符合原图趋势，选择AB代表图形，AB中所有点都可以排除</span><br><span class="line">4，	如果e &gt; threshold，则AB不符合趋势，分别连接AC，CB，继续步骤2</span><br><span class="line">5，	如果AB中间已经没有其他点了，则递归结束</span><br></pre></td></tr></table></figure>

<h3 id="Visvalingam–Whyatt-algorithm"><a href="#Visvalingam–Whyatt-algorithm" class="headerlink" title="Visvalingam–Whyatt algorithm"></a>Visvalingam–Whyatt algorithm</h3><p>算法的主要思想是基于点的重要性或者意义来寻找能够代表图形的特征点，而点的重要性是通过有效区域即点构成三角形的面积来判定。</p>
<p>遍历数据集中的每一个点，将该点和邻近的两个点来构成三角形，三角形的区域即为点的有效区域。当有效区域较小时，认定该点对于图形的重要性较低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，	首先计算每个点的有效区域，找出有效区域最小的点，剔除；</span><br><span class="line">2，	重新计算邻接点的有效区域，继续找出有效区域最小的点，剔除；</span><br><span class="line">3，	重复步骤2，直到剩余点的个数满足了绘图要求，算法结束</span><br></pre></td></tr></table></figure>

<p>上面两种绘图泛化技术的特点是比较简单并且在降低数据量方面表现的相当有效。缺点是基于全局的返回可能会损失局部的特点，比如whyatt算法在删除点方面，可能会把一段时间的数据全部删除，这就给人造成了数据缺失的错觉，相应的图形表现力也大打折扣。如下图所示，黑色图形是算法处理后的图形。</p>
<image src="whyatt1.png">

<h2 id="Largest-Triangle-Algorithms"><a href="#Largest-Triangle-Algorithms" class="headerlink" title="Largest Triangle Algorithms"></a>Largest Triangle Algorithms</h2><p>最大三角形算法是结合了Whytt算法和直觉算法的改良版，通过三角形来形成有效区域从而对数据点的重要性进行量化，再结合直觉算法中分桶思想最大程度的保留图形的特点。</p>
<h3 id="Largest-Triangle-One-Bucket"><a href="#Largest-Triangle-One-Bucket" class="headerlink" title="Largest-Triangle-One-Bucket"></a>Largest-Triangle-One-Bucket</h3><p>LTOB最大三角形单桶算法，使用了Whytt算法有效区域的思路，再结合直觉算法中的分桶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,	首先确定桶的大小，并将数据点平分到桶中，注意首尾点各占一个桶确保选中</span><br><span class="line">2,	依次计算每个点和邻接点形成的有效区域，去除无有效区域的点</span><br><span class="line">3,	在每个桶中选取有效区域最大的点代表当前桶</span><br></pre></td></tr></table></figure>

<p>LTOB算法相比原始的Whytt算法，确保了点分布的相对均匀。每个桶都有一个代表点来表示，从而连接成为一个全局的路由。</p>
<h3 id="Largest-Triangle-Three-Buckets"><a href="#Largest-Triangle-Three-Buckets" class="headerlink" title="Largest-Triangle-Three-Buckets"></a>Largest-Triangle-Three-Buckets</h3><p>LTTB最大三角形三桶算法，相比于单桶的短视问题，将有效区域的计算延伸到前后两个桶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，	首先确定桶的大小，并将数据点平分到桶中，注意首尾点各占一个桶确保选中</span><br><span class="line">2，	选中第一个点</span><br><span class="line">3，	从第二个桶开始，遍历桶中的点，计算每个点的有效区域，并选取有效区域最大的点作为桶的代表点。</span><br><span class="line">	三角形的选取为	[前一个桶的选中点，当前点，后一个桶的平均点]。</span><br><span class="line">4，	选中最后一个点</span><br></pre></td></tr></table></figure>

<p>LTTB算法相比LTOB算法，一定程度上减轻了短视的问题。同时通过固定三角形的两个点的方式，提升了算法的效率。</p>
<h3 id="Largest-Triangle-Dynamic"><a href="#Largest-Triangle-Dynamic" class="headerlink" title="Largest-Triangle-Dynamic"></a>Largest-Triangle-Dynamic</h3><p>LTD动态最大三角形，正如名字所说的那样可以动态的决定桶中的数据点个数。在上面提到的所有分桶算法中，我们都使用了同样的分配算法，即首尾各占一个桶，其他均分。这种分配方法无疑是最简单的，并且大多数情况是有效的。</p>
<p>但是当我们遇到一些特殊形状的图形，如数据分布不均匀，一部分时间数据变化很平缓，部分时间变化很陡峭，如下图所示。我们的分桶方式就会显得力不从心。</p>
<img src="ltd1.png">

<p>这时候就需要一个动态的的分桶算法，当数据平缓的时候桶中的点相对较多，当数据陡峭的时候桶中的点相对较少，以此来确保在平缓区域分配较少的桶来选取较少的点，而在陡峭区域分配较多的桶来选取较多的点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,	首先确定桶的大小，并将数据点平分到桶中，注意首尾点各占一个桶确保选中</span><br><span class="line">2,	计算每一个桶的SSE（计算当前桶加上两个邻接点的线性回归线，SSE=桶内所有点到回归线的垂直距离平方之和）</span><br><span class="line">3,	循环迭代直至终止条件触发（一般为有限次的迭代total/threshold*10，案例中为250次）</span><br><span class="line">    	找出最大SSE的桶 F</span><br><span class="line">    	找出SSE之和最小的相邻桶 A 和 B（AB和F不能相同）</span><br><span class="line">    	将F均匀拆分成两个桶</span><br><span class="line">    	将AB合并为一个桶</span><br><span class="line">4,	确定了桶之后即可以采用LTTB算法进行降采样</span><br></pre></td></tr></table></figure>

<p>LTD算法相比LTTB算法在不规则图形上有更好的表现力，但是在规则图形上可能还不如LTTB。LTD的效率显然远不如LTTB，同时循环迭代的终止条件并没有比较好的参考数据需要不断尝试，这在某种程度上增加了算法的复杂性。</p>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>在完成了以上六个算法的研究学习之后，我们可以对各个算法的优劣进行定性的比较，为我们之后的工作提供指导和帮助。</p>
<p>参照的指标有以下几个：</p>
<ul>
<li>速度（Speed），算法的运行速度无疑是很重要的因素，一般我们页面的的响应需要控制在3s以内，算法的速度也应该参考这个基准</li>
<li>可伸缩（Scalability），当数据量持续增长的时候，算法的表现不应发生明显变化</li>
<li>复杂性（Complexity），算法的复杂度在于理解和实现的难度，一个量化的直接就是LOC即实现的代码行</li>
<li>适配能力（Portability），算法在各个环境和语言中支持的程度</li>
<li>正确性（Correctness），算法的运行结果对于原图形的表现力</li>
</ul>
<img src="conclusion.png"/>

<p>从上图可以看出LTTB算法在绝大多数情况下都是表现优异的，当然基于场景的差异可能其他算法会有更好的正确性。所以我们的决策顺序可以是优先LTTB，当LTTB不满足呈现的需求时，我们可以尝试其他算法以获取更好的结果。</p>
<p>最后我们基于我们实际的两组数据进行了测试，一组为单调递增的累积损伤数据，一组为波动的异常诊断数据。</p>
<img src="result.png" />
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>根云平台初体验</title>
    <url>/2020/08/19/%E6%A0%B9%E4%BA%91%E5%B9%B3%E5%8F%B0%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>公司目前的产品偏重于边缘数采和边缘计算，对于规模较大的客户大多需求接入现有的工业互联网平台实现数据统筹管理。</p>
<p>本文从根云互联网平台（以下简称平台）切入，研究边缘一体机接入平台的可行性。</p>
<p>在正式开始之前需要先了解平台关于建模的高层设计。通过控制台进入后可以看到在左侧的物菜单下有物模型、物实例和模型模板库三个子菜单。</p>
<span id="more"></span>

<img src="menu.png"/>

<p>结合介绍文档和页面功能，我们可以总结出平台关于物建模的高层设计。</p>
<img src="high-level.png"/>

<ol>
<li>物模型是物理设备的高层次抽象，定义物理设备通用的属性和行为</li>
<li>物实例是物模型的具体实现，对应现实设备或者网关</li>
<li>模型模板库是物模型的行业知识库，用于快速创建物模型</li>
</ol>
<h2 id="设备建模"><a href="#设备建模" class="headerlink" title="设备建模"></a>设备建模</h2><h3 id="物模型"><a href="#物模型" class="headerlink" title="物模型"></a>物模型</h3><p>基于平台关于建模的设定，我们首先建立我们的物模型。选择物模型类型为网关，填入基本信息即可创建成功。</p>
<img src="model1.png"/>

<p>为物模型添加一个变量标识为AA001对应电流接入。</p>
<img src="model2.png"/>

<h3 id="物实例"><a href="#物实例" class="headerlink" title="物实例"></a>物实例</h3><p>物模型建立完成后就可以基于物模型创建物实例了。</p>
<img src="instance1.png"/>

<h2 id="连接验证"><a href="#连接验证" class="headerlink" title="连接验证"></a>连接验证</h2><p>在设备建模完成后，我们可以通过MQTT网页测试工具向平台发送实时数据。</p>
<p>测试地址：<a href="https://developer-pre.rootcloudapp.com/docs/resource/mqtt-api-test/">https://developer-pre.rootcloudapp.com/docs/resource/mqtt-api-test/</a></p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><img src="connect.png"/>

<p>相关页面输入如下所示，</p>
<p>服务器地址：mqtt-broker-pre.rootcloudapp.com</p>
<p>Username和clientId : xxxxxxx（通过物实例页面获取到的认证标识）</p>
<p>端口：8084</p>
<p>Password：xxxx（通过物实例页面获取到的认证密钥）</p>
<h3 id="发布数据"><a href="#发布数据" class="headerlink" title="发布数据"></a>发布数据</h3><p>连接建立成功后可以通过发布功能发布数据到平台。</p>
<img src="publish-data.png"/>

<p>其中发布的主题是：<code>v4/p/post/thing/live/json/1.1</code>。发布的内容根据需求定义，具体字段可以查看文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;things&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;thingType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Gateway&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">	  <span class="attr">&quot;qBad&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	  <span class="attr">&quot;ts&quot;</span><span class="punctuation">:</span> <span class="number">1620720246796</span><span class="punctuation">,</span></span><br><span class="line">	  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	    <span class="attr">&quot;AA001&quot;</span><span class="punctuation">:</span> <span class="number">13</span></span><br><span class="line">	  <span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如以上报文中我们需要关注几个部分，其中thingType可以选择Device和Gateway，选择Gateway时，id为空字符串即可。ts对应上报的时间戳，properties中的AA001就是我们在物模型中定义的属性名。</p>
<p>发送完之后我们在物实例中可以看到AA001对应的电流的实时值为13。</p>
<img src="result.png"/>

<h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>我们还可以模拟MQTT的客户端进行连接后向平台发送数据。在客户端程序中需要建立连接，模拟数据格式和发送数据。在客户端选型上我们选择了eclipse paho，使用spring-integration-mqtt进行客户端封装。</p>
<img src="code.png"/>

<p>如代码所示，通过暴露的MyGateway接口发送消息到管道，管道接收了消息之后通过创建客户端将消息发送到目标主题。</p>
<p>发送一段时间后在平台端可以看到AA001的变化趋势。</p>
<img src="code-result.png"/>

<h2 id="业务验证"><a href="#业务验证" class="headerlink" title="业务验证"></a>业务验证</h2><p>基于边缘端拓扑结构，我们在平台进行建模如下：</p>
<img src="solution.png"/>

<p>首先一个节点对应一体机，在一体机上安装一个MQTT客户端发送数据到平台的MQTT队列。平台侧通过部署一个多节点网关对多个节点进行管理。呈现效果如下：</p>
<img src="result1.png"/>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<strong>连接验证</strong>，我们确认了可以通过边缘程序发送数据到MQTT队列并在平台进行展示的可行性。通过<strong>业务验证</strong>，我们将边缘端的设备结构和物模型进行匹配，实现了一个网关对应一台边缘智能机并通过复合物进行统一管理的实现路径。</p>
<img src="path.png"/>]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>应用技术</tag>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>统计二进制1的代码解读</title>
    <url>/2019/07/17/%E7%BB%9F%E8%AE%A1%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>为了适应边缘计算的需求决定投入学习Go语言的浪潮，用了10年的java突然要去接受一个风格完全不一样的语言感觉真是太刺激了。 在看《Go语言圣经》的时候看到里面的一个计算二进制中1的个数的程序popcount，觉得挺有意思就拿出来分享一下吧。</p>
<p>程序代码总计也没几行，可以说很一目了然了：</p>
 <span id="more"></span>

<img src="code.png"/>

<p>程序分为两个部分，</p>
<ol>
<li>初始化构造一个长度为256的数组</li>
<li>主程序PopCount通过8次右移操作分别求低8位的1数量然后相加</li>
</ol>
<p>那这么明显的结构，这么清晰的代码有啥好解读呢？主要原因是在第一遍看的时候产生了两个疑问，我觉得有必要记录一下解决疑惑的过程。</p>
<h2 id="初始化数组为什么是256"><a href="#初始化数组为什么是256" class="headerlink" title="初始化数组为什么是256"></a>初始化数组为什么是256</h2><p>这个问题需要和PopCount主程序结合看。</p>
<p>因为在主程序中使用的算法是将64位的无符号整数切割成8个8位，而8位的无符号整数取值范围是0-255，为了完整表示这256个数值的1的位数，所以使用了长度为256的数组。</p>
<h2 id="初始化算法的依据是什么"><a href="#初始化算法的依据是什么" class="headerlink" title="初始化算法的依据是什么"></a>初始化算法的依据是什么</h2><p>其实初始化的算法就一句话 pc[i] &#x3D; pc[i&#x2F;2] + byte(i&amp;1)，一句话就得出了整数中二进制1的个数字典表也太神奇了吧。怎么来理解这个算法呢？经验？定理？当然可以选择记住就行。</p>
<p>但是我们还是可以尝试着大声的念出这段代码的含义，</p>
<blockquote>
<p>整数 i 中1的个数等于整数 i&#x2F;2 中1的个数加上i在低1位的1的个数</p>
</blockquote>
<p>是不是有点灵感了？直接上图吧</p>
<img src="algorithm.png"/>

<p>从图中可以看出每个整数i的1的个数由两部分组成</p>
<ol>
<li>i&#x2F;2的1的个数，这部分就对应算法中的pc[i&#x2F;2]</li>
<li>i&#x2F;2的余数，这部分对应算法中的byte[i&amp;1]</li>
</ol>
<hr>
<p>到这里这段代码的疑惑就全部解开了，嗯就是这么Go！</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式实战之状态模式</title>
    <url>/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>系统启动阶段需要完成一些准备工作，最初是通过Spring Application Runner来实现，实现思路用业务语言描述就是：</p>
<ol>
<li>首先进行启动参数准备</li>
<li>判断是否需要注册主站，如果需要则注册</li>
<li>判断是否需要进行数据同步，如果需要则同步数据</li>
<li>等待数据同步完成，系统准备完成</li>
</ol>
<p>这种设计可以从某种程度上理解为责任链模式，四个Runner组成了一个责任链，流转到对应的节点判断是否属于该节点的责任并采取动作。</p>
<h2 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h2><p>这样的启动流程设计和Spring容器耦合严重导致了可复用性不是很好，并且面向流程的设计不具备可扩展性。如果我们在RegisterRunner中由于网络原因没有注册成功，我们期望的结果是重新注册而不是重启Spring应用。</p>
<p>我们发现在Runner对应的过程中体现的是状态的转移，例如RegisterRunner对应的是正在注册到注册成功或者注册失败状态的转移。而状态的转移又反映在类行为的变化。这正是状态模式适用的场景。</p>
<blockquote>
<p>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>
</blockquote>
<span id="more"></span>

<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>首先结合业务逻辑定义了如下几个状态：</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td>STARTING</td>
<td>正在启动</td>
</tr>
<tr>
<td>REGISTERING</td>
<td>正在注册主站</td>
</tr>
<tr>
<td>DATA_SYNC</td>
<td>正在进行数据同步</td>
</tr>
<tr>
<td>STARTUP_FAIL</td>
<td>启动失败</td>
</tr>
<tr>
<td>STARTUP_SUCCESS</td>
<td>启动成功</td>
</tr>
<tr>
<td>UNKNOWN</td>
<td>未知状态</td>
</tr>
</tbody></table>
<p>基于状态模式可以得到系统类图设计：</p>
<img src="state-class-diagram.png" />

<p>在 ProjectStartupContext 中定义的dispatch方法负责逻辑处理和状态转移，通过isTerminalState方法来判断是否终结状态并结束流转。结合定义的启动模式和类图设计得到的状态转移流程图如下：</p>
<img src="state-flow-diagram.png" />

<p>从状态角度考虑每个状态都需要包含自身的职责和状态的流转逻辑，STARTING状态的职责是进行启动参数初始化，如果初始化失败则直接流转到启动失败状态；如果初始化成功并且是网络模式，则进入主站注册状态，如果是单机模式则直接启动成功。</p>
<p>REGISTERING状态的职责是进行主站注册，如果注册成功则进入数据同步状态，注册失败经过重连处理后进入启动失败状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AbsStartupState</span> <span class="variable">dataSyncState</span> <span class="operator">=</span> ProjectStartupStateFactory.</span><br><span class="line">                    getStartupState(ProjectStartupParamUtil.StartupStatusEnum.DATA_SYNC.getName());</span><br><span class="line">    <span class="type">AbsStartupState</span> <span class="variable">failState</span> <span class="operator">=</span> ProjectStartupStateFactory.</span><br><span class="line">                    getStartupState(ProjectStartupParamUtil.StartupStatusEnum.STARTUP_FAIL.getName());	</span><br><span class="line">    <span class="keyword">while</span>(!doRegisterToMaster(node))&#123;</span><br><span class="line">        tryTimes++;</span><br><span class="line">        <span class="keyword">if</span>(tryTimes &lt; REGISTER_RETRY_TIMES)&#123;</span><br><span class="line">            <span class="built_in">super</span>.startupContext.setState(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(RETRY_DURATION);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">/*do nothing */</span>&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>.startupContext.setState(failState);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">super</span>.startupContext.setState(dataSyncState);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTerminalState</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DATA_SYNC状态的职责是进行数据同步和同步状态跟踪，如果同步成功则启动成功，否则启动失败。</p>
<p>STARTUP_FAIL和STARTUP_SUCCESS这两个属于终结状态不需要进行任何逻辑处理和状态转移操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StartFailState</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>(ProjectStartupParamUtil.StartupStatusEnum.STARTUP_FAIL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">()</span>  &#123;</span><br><span class="line">	LOG.error(<span class="string">&quot;entered dead code segment.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTerminalState</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在具体的调用中，我们通过一个service( ProjectStartupService.start )来提供状态模式的入口，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LOG.info(<span class="string">&quot;Project Startup Service begin.&quot;</span>);</span><br><span class="line"><span class="type">ProjectStartupContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProjectStartupContext</span>();</span><br><span class="line"><span class="type">AbsStartupState</span> <span class="variable">startingState</span> <span class="operator">=</span> ProjectStartupStateFactory.getStartupState(</span><br><span class="line">		ProjectStartupParamUtil.StartupStatusEnum.STARTING.getName()</span><br><span class="line">);</span><br><span class="line"><span class="type">AbsStartupState</span> <span class="variable">successState</span> <span class="operator">=</span> ProjectStartupStateFactory.getStartupState(</span><br><span class="line">		ProjectStartupParamUtil.StartupStatusEnum.STARTUP_SUCCESS.getName()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span>(ProjectStartupParamUtil.isNetMode())&#123;</span><br><span class="line">	context.setState(startingState,<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	context.setState(successState,<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!context.isTerminal())&#123;</span><br><span class="line">	context.dispatch();</span><br><span class="line">&#125;</span><br><span class="line">LOG.info(<span class="string">&quot;Project Startup Service end.&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过封装使得系统启动准备做到了可复用，首次启动的场景中直接在Application Runner中读取参数，调用start方法；通过状态监测页面观测到系统状态为失败的时候，可以通过页面触发重启。反映到后台逻辑就是重置启动参数，执行start方法。</p>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>在上面的例子中，我们利用状态模式对系统启动流程进行了优化重构。</p>
<p>从可扩展性方面看，如果需要增加一个启动动作，如NTP对时，那我们可以通过新增一个状态 [NTP对时]，上游状态是 [注册节点] ，下游状态是 [数据同步]。涉及到的改动是注册节点的成功状态设置由 [数据同步] 改成 [NTP对时] 。</p>
<p>乍看之下不符合开闭原则呀，确实状态模式封装了状态的行为和状态转移在应对新的状态加入时会涉及到原有状态类的修改。我们可以将状态路由单独提取出来，这样符合了封装不变开放变化的设计准则，但同时也会增加复杂度。换一个角度看，状态模式的应用场景大多数是状态类的数量相对固定并且转换规则已经基本确定的场景，通过状态模式实现封装来提高代码的可读性和设计的可复用。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式实战之策略枚举</title>
    <url>/2021/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E7%AD%96%E7%95%A5%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>在开发中经常会遇到一些语句拼接的问题，如用于数据库查询的where条件或者用于逻辑判断的表达式。我们在应对这类问题的时候，直觉是使用if-else或者switch条件判断，下面是一个常见的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">buildStatement</span><span class="params">(<span class="type">int</span> type, String[] value)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">statement</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">1</span>) statement =<span class="string">&quot;value &gt;= %s and value &lt;= %s&quot;</span>;<span class="comment">//介于</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>) statement = <span class="string">&quot;value &lt; %s or value &gt; %s&quot;</span>;<span class="comment">//不介于</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> String.format(statement, value[<span class="number">0</span>], value[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h2><p>这段拼接字符串的代码功能上没什么问题，但是过多的if-else使得代码的阅读和维护都显得不是那么友好。在上面的例子中，我们还隐藏了一个关于type的枚举。考虑扩展性如果需要新增一个类型，我们需要做：</p>
<ul>
<li>Type枚举新增一个类型</li>
<li>新增一个if-else 分支</li>
</ul>
<p>在枚举里面新增一个类型相当于增加了一个单例类，符合设计原则；但是新增if-else分支则涉及到具体类逻辑的修改，不符合开闭原则。</p>
<p>让我们再来思考一下面临的问题：每个类型对应了一种字符串拼接的方法，要求根据高层次模块的需求可以自由切换，而不用关心拼接的细节。这正契合了策略模式的定义：</p>
<blockquote>
<p>策略模式通过定义一组算法将他们封装起来，使得算法之间可以相互替换</p>
</blockquote>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>基于策略模式的定义，我们可以绘制出语句拼接场景下的类图。</p>
<img src="class-diagram.png" alt="Image" />

<p>首先定义了一个策略接口Statement，以及通用行为build。</p>
<p>每一个策略都定义一个实现类，如介于（Between）。在实现类的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数注入类型</span></span><br><span class="line">Between()&#123;</span><br><span class="line">  Super(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">build</span><span class="params">(String[] params)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> String.format(<span class="string">&quot;value &gt;=%s and value &lt;=%s&quot;</span>,value[<span class="number">0</span>],value[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>环境类Context提供了切换拼接方式的入口，高层模块调用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">String[] values = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;20&quot;</span>&#125;;</span><br><span class="line">context.setStatement(<span class="keyword">new</span> <span class="title class_">Between</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">betweenStatement</span> <span class="operator">=</span> context.buildStatement(values);</span><br><span class="line">Context.setStatement(<span class="keyword">new</span> <span class="title class_">Equal</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">equlStatement</span> <span class="operator">=</span> context.buildStatement(values);</span><br></pre></td></tr></table></figure>

<p>通过上面的设计，如果我们新增一个拼接类型只需要新增一个新的实现类即可，不需要涉及任何现有代码的改动，符合开闭原则。</p>
<p>但是如此完美的设计还是逃避不了策略模式的通病：类爆炸。当拼接类型过多的时候，系统中会出现很多的实现类，而且每个类都只有几十行代码，这在无形之中也会增加系统的维护成本。针对这种情形，我们可以引入策略枚举。因为我们知道枚举的值其实就是对应一个单例的实现，我们通常使用的枚举只是定义了这个单例的属性，如下图所示。</p>
<img src="type-enum.png" alt="Image" />

<p>策略枚举可以同时定义属性和行为，看起来更加的物尽其用。具体实现就是在枚举中除了属性定义之外通过抽象方法来定义枚举的行为，而在每一个枚举值中进行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LogicStatement</span>&#123;</span><br><span class="line">        BETWEEN(<span class="number">1</span>,<span class="string">&quot;介于&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">build</span><span class="params">(String... values)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> String.format(<span class="string">&quot;and value&gt;%s and value&lt;%s&quot;</span>,values[<span class="number">0</span>],values[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        NOT_BETWEEN(<span class="number">2</span>,<span class="string">&quot;未介于&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">build</span><span class="params">(String... values)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> String.format(<span class="string">&quot;and (value&gt;=%s or value&lt;=%s)&quot;</span>,values[<span class="number">1</span>],values[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        EQUAL(<span class="number">3</span>,<span class="string">&quot;等于&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">build</span><span class="params">(String... values)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> String.format(<span class="string">&quot;and value=%s&quot;</span>,values[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        LogicStatement(<span class="type">int</span> _value, String _name)&#123;</span><br><span class="line">            <span class="built_in">this</span>.value = _value;</span><br><span class="line">            <span class="built_in">this</span>.name = _name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">build</span><span class="params">(String... values)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，LogicStatement定义了枚举的属性和行为，在每一个枚举中通过构造器注入属性，通过重写来定义行为。通过策略枚举的实现在策略模式的基础上有效的归集了策略模式的实现类，方便管理和维护。</p>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>上面的例子中我们使用策略模式来实现字符串拼接的功能，主要原因是功能的封装和算法的切换符合策略模式的定义。通过策略模式的引进可以增强设计和实现的可维护性和可扩展性。对于简单策略可能带来的类爆炸问题，我们可以通过策略枚举解决。但是需要谨记使用策略枚举的前提：</p>
<ol>
<li>简单策略，即策略的实现代码较少，否则会造成枚举类过大</li>
<li>策略类较多，如果策略类只有五个以内或者更少还是建议使用策略类的方式来实现，毕竟策略枚举的扩展还是要修改已有枚举类代码，并不是纯粹意义的扩展</li>
</ol>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式实战之装饰模式</title>
    <url>/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>装饰模式是指在不改变原类文件并且不使用继承结构的情况下，动态的扩展一个对象的功能。具体实现上是通过创建一个包装对象即一个装饰来包装真实对象，所以装饰模式又称为包装模式。</p>
<p>在装饰模式中主要有以下四个角色：</p>
<ol>
<li>Component，原始的抽象对象</li>
<li>ConcreteComponent，具体的对象实现</li>
<li>Decorator，抽象的装饰，主要定义了装饰者的行为以及与原始抽象对象之间的关系</li>
<li>ConcreteDecorator，具体的装饰类</li>
</ol>
<span id="more"></span>

<img src="class-diagram.png" alt="Image" />

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在模型计算的设计中我们采用了模板方法定义了模型运算的基本框架，</p>
<img src="flow-diagram.png" alt="Image" />

<p>在Persist方法中我们主要实现计算结果保存到数据库，但是实际项目中会有更多针对模型结果的需求：</p>
<ul>
<li>发送统计到Redis</li>
<li>发送到第三方平台进行展示</li>
<li>回写网关进行反向控制</li>
</ul>
<p>目前的做法是在抽象类中实现相应的公用方法，然后到具体的实现类决定是否调用这些方法。</p>
<img src="biz-class-diagram.png" alt="Image" />

<p>如上图所示，在长链条的实现类里面调用了发送统计和反向控制两个方法，而驱动单元的实现类只调用了发送统计的方法。这样实现的问题是对于策略本身的侵入式实现导致策略实现无法灵活的增加和删除这些额外的增强功能，无法满足开闭原则。</p>
<p>这时候我们可以换一种视角来看待这些增强，将发送统计、发送第三方和发送边缘视为策略的装饰，那么使用装饰模式来实现这些增强就显得恰到好处了。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>使用装饰模式之前我们首先进行角色确认</p>
<ol>
<li>Component，原始的抽象对象，对应我们实例中的AbstractFanalysisStrategy</li>
<li>ConcreteComponent，具体的对象实现，在我们的实例中包含了长链条的策略实现和驱动单元的策略实现</li>
<li>Decorator，抽象的装饰器，需要新定义的接口FanalysisDecorator</li>
<li>ConcreteDecorator，具体的装饰器实现，包含了RedisDecorator，ThirdPartyDecorator和EdgeDecorator</li>
</ol>
<p>类图如下：</p>
<img src="future-diagram.png" alt="Image" />

<p>通过FanalysisDecorator实现了抽象类的persist方法，同时定义作为增强类的统一行为run方法，FanalysisDecorator类的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FanalysisDecorator</span> <span class="keyword">extends</span> <span class="title class_">AbstractFanalysisStrategy</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractFanalysisStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">FanalysisDecorator</span><span class="params">(AbstractFanalysisStrategy _strategy)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = _strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">persist</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy.persist();</span><br><span class="line">        <span class="comment">//进行增强</span></span><br><span class="line">        <span class="built_in">this</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个装饰实现类的run方法中实现具体的增强逻辑，对应之前抽象类中的公共方法。这样在调用的地方就可以由客户端等高层模块决定如何去增强而无需侵入原实现类了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取初始策略</span></span><br><span class="line"><span class="type">AbstractFanalysisStrategy</span> <span class="variable">chainStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainStrategy</span>();</span><br><span class="line"><span class="comment">//进行包装</span></span><br><span class="line"><span class="type">AbstractFanalysisStrategy</span> <span class="variable">decorated</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RootCloudDecorator</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RedisDecorator</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">EdgeDecorator</span>(chainStrategy)</span><br><span class="line">    ))</span><br><span class="line">;</span><br><span class="line">decorated.persist();</span><br></pre></td></tr></table></figure>

<p>通过上面的装饰模式实现可以很好的实现功能的动态增强而无需修改原策略类。</p>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>在这个例子中我们结合了模板方法和装饰模式对模型计算功能进行动态增强。</p>
<p>我们在原始的实现中只是使用了模板方法，通过抽象类实现了功能的可复用，这种方式我们称之为静态增强。这时候如果需要新增新的增强方式，需要涉及抽象类的修改和模型实现类的修改，无法满足开闭原则，扩展性不好。</p>
<p>如果引入装饰模式，使用包装类的方式对原始功能进行增强，理论上可以增加任意多的增强。装饰类的新增只需要高层模块的修改，不涉及已有功能的改动，符合了开闭原则。</p>
<p>实际应用中可以结合模板方法，动静结合的对类进行增强。同时需要注意包装类的数量不宜过多，太多的增强可能引发代码复杂度的急剧增加带来维护的难度。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式实战之访问者模式</title>
    <url>/2022/01/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>访问者模式主要解决了数据结构和数据行为的分离，通过访问者模式可以在保持数据结构相对稳定的情况下，对数据行为进行单独扩展。所以访问者模式可以理解为重构模式。</p>
<p>访问者模式主要有四个角色：</p>
<ol>
<li>Visitor接口，通过抽象的访问者接口定义了访问的行为</li>
<li>ConcreteVisitor实现类对访问行为进行具体的逻辑实现</li>
<li>Element接口定义了被访问者的基本操作</li>
<li>Element实现类定义了具体的被访问对象实现</li>
</ol>
<span id="more"></span>

<img src="class-diagram.png" alt="Image" />

<p>访问者模式适用于数据结构相对固定而行为可变的场景，结合类图也就是说Element以及其实现类相对固定，而需要改变的是访问这些Element之后的行为。访问者模式的可扩展性体现在visitor的可扩展。</p>
<p>访问者模式最重要的优点我认为是实现了单一职责原则，每一个visitor实现类实现了一个功能，职责划分非常清晰。</p>
<p>访问者模式的缺点：</p>
<ul>
<li>Element被访问类不可扩展</li>
<li>Visitor直接依赖具体的被访问对象，不符合依赖倒置原则</li>
<li>Visitor直接访问被依赖对象内部的方法，不符合迪米特法则</li>
</ul>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在模型计算的触发中我们定义了三种计算任务，分别是特征计算任务、累积损伤计算任务和异常诊断计算任务。任务类型是相对固定的，而计算任务所对应的行为是有扩展需求的，这恰恰符合了访问者模式定义的使用场景。</p>
<blockquote>
<p>通过访问者模式可以在保持数据结构相对稳定的情况下，对数据行为进行单独扩展</p>
</blockquote>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>在进行详细的类图设计之前，我们进行角色匹配</p>
<ul>
<li>Element角色定义了被访问者的通用属性，对应计算认为的抽象类Task</li>
<li>Element1等具体被访问者就对应了我们场景中的计算任务：FeatureTask、ModelTask等</li>
<li>Visitor角色定义了访问者的行为</li>
<li>ConcreteVisitor角色定义了具体的访问行为，如计算行为可以对应一个具体的CalculateVisitor</li>
</ul>
<p>结合访问者模式得到类图如下：</p>
<img src="new-class-diagram.png" alt="Image" />

<p>CalculateVisitor实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculateVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(FeatureTask featureTask)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行特征计算任务，任务名：&quot;</span>+featureTask.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ModelTask modelTask)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行模型计算任务，任务名：&quot;</span>+modelTask.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于CalculateVisitor来说引起变化的原因只有计算逻辑的变化，因此是符合单一职责原则的。计算任务类型固定，不存在任务的扩展需求，所以从扩展角度来看访问者模式是可以满足要求的。</p>
<p>我们再看一下上面访问者的类图，发现迪米特法则也好依赖倒置原则也罢，问题的根源在于Visitor直接依赖了实现类，那直接依赖接口会怎么样呢？</p>
<img src="future-class-diagram.png" alt="Image" />

<p>依赖倒置的问题解决，Task接口和Visitor接口可以分别扩展，开闭的问题也解决了。CalculateVisitor中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculateVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Task</span>&gt; <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(T task)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行特征计算任务，任务名：&quot;</span>+task.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Task&gt; taskList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    taskList.add(<span class="keyword">new</span> <span class="title class_">FeatureTask</span>(<span class="string">&quot;F_&quot;</span>+i));</span><br><span class="line">    taskList.add(<span class="keyword">new</span> <span class="title class_">ModelTask</span>(<span class="string">&quot;M_&quot;</span>+i));</span><br><span class="line">&#125;</span><br><span class="line">Collections.shuffle(taskList);</span><br><span class="line"><span class="comment">//数据准备完成</span></span><br><span class="line"><span class="type">Visitor</span> <span class="variable">calculateVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculateVisitor</span>();</span><br><span class="line"><span class="keyword">for</span>(Task t: taskList)&#123;</span><br><span class="line">    t.accept(calculateVisitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>在上面的例子中我们首先引入经典的访问者模式，将数据结构和行为分离后发现违背依赖倒置原则引发的扩展性问题其实可以通过泛型来解决。经过改造之后，设计更加灵活，可扩展性更好。</p>
<p>但是我们要谨记每一个设计模式都有其适用的场景，设计模式没有银弹。</p>
<p>对比以上两种访问者模式实现可以发现，第二种设计扩展性更好的同时带来了架构的复杂性，对于被访问者的要求更高了，也就是说他们必须是同类，只有这样才能将公共行为抽取到接口来满足依赖倒置原则；反观第一种设计，由于访问者直接访问实现类，所以被访问者实现类之间只存在accept这一个共性约束，被访问者之间是同事类的关系即可。</p>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
