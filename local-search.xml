<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于可行方向的能耗寻优算法</title>
    <link href="/2023/09/18/%E5%9F%BA%E4%BA%8E%E5%8F%AF%E8%A1%8C%E6%96%B9%E5%90%91%E7%9A%84%E8%83%BD%E8%80%97%E5%AF%BB%E4%BC%98%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/18/%E5%9F%BA%E4%BA%8E%E5%8F%AF%E8%A1%8C%E6%96%B9%E5%90%91%E7%9A%84%E8%83%BD%E8%80%97%E5%AF%BB%E4%BC%98%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在工业场景中，节能减排一直是一个很重要的话题。而在我们服务的汽车制造行业，涂装车间的能耗在四大工艺过程中占比达到了70%，所以如何降低涂装车间的能耗成了降低汽车制造过程能耗的关键。</p><p>本文选择涂装车间的喷房风机作为研究对象，以空调的温湿度作为主要调整指标，尝试通过技术的手段来找到能耗最优解。</p><span id="more"></span><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>已知能耗方程的条件下，设定一组温湿度的限定条件，通过优化算法找出使得能耗最小的温湿度值。</p><blockquote><p>使用穷举？<br>目前选择的优化指标有四个，每个指标的取值跨度为10，按照步长0.01计算，我们需要计算的次数为1000^4</p></blockquote><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>经过研究，我们采用可行方向法作为算法的指导思想，由于存在温湿度的限定条件，所以算法进行了分支处理。</p><blockquote><p>可行方向是指沿该方向作微小移动后，所得到的新点是可行点，且目标函数值有所下降</p></blockquote><p>程序流程如下图所示：</p><img src="程序流.png" alt="image-20230919095324346" style="zoom:80%;" /><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>算法实现部分我们通过对程序流图进行详细说明来描述算法的实现过程。</p><h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p>参数初始化可以根据经验选择限定条件的边界值，如夏季模式下选择温度最大值会降低空调的能耗。</p><p>但是这种单一出发点的选择会导致算法陷入局部最优的困境，最终我们通过随机取样的方法从可行区间内选了10个点，通过多次计算减少了局部最优的可能性。随机选择出发点的同时通过指定伪随机种子，确保了算法的稳定性，即每一次优化都可以得到同样的解；通过种子的合理选择，保证选择的数据分布足够合理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;BigDecimal[]&gt; batchInitParam(List&lt;BigDecimal[]&gt; rangeList)&#123;<br>        List&lt;BigDecimal[]&gt; resultList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        BigDecimal[] result;<br>        <span class="hljs-comment">//取10个随机点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>[rangeList.size()];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">seed</span> <span class="hljs-operator">=</span> i*<span class="hljs-number">10000</span>;<br>            result[<span class="hljs-number">0</span>] = randomFromRange(rangeList.get(<span class="hljs-number">0</span>)[<span class="hljs-number">0</span>],rangeList.get(<span class="hljs-number">0</span>)[<span class="hljs-number">1</span>],seed);<br>            result[<span class="hljs-number">1</span>] = randomFromRange(rangeList.get(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>],rangeList.get(<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>],seed);<br>            result[<span class="hljs-number">2</span>] = randomFromRange(rangeList.get(<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>],rangeList.get(<span class="hljs-number">2</span>)[<span class="hljs-number">1</span>],seed);<br>            result[<span class="hljs-number">3</span>] = randomFromRange(rangeList.get(<span class="hljs-number">3</span>)[<span class="hljs-number">0</span>],rangeList.get(<span class="hljs-number">3</span>)[<span class="hljs-number">1</span>],seed);<br>            resultList.add(result);<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultList;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BigDecimal <span class="hljs-title function_">randomFromRange</span><span class="hljs-params">(BigDecimal low, BigDecimal up, <span class="hljs-type">int</span> seed)</span>&#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> up.subtract(low).abs();<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(seed);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(rd.nextDouble());<br>        <span class="hljs-keyword">return</span> low.add(gap.multiply(factor));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="收敛条件"><a href="#收敛条件" class="headerlink" title="收敛条件"></a>收敛条件</h3><p>算法的收敛条件包含：</p><ol><li><p>循环次数</p><p>根据测试的结果，算法的收敛一般在10-15次循环，所以最终定义最大循环次数为25，超过最大循环次数后直接算法结束，返回最后一次计算的结果。</p></li><li><p>变化值</p><p>通过监控目标函数的值变化，确定算法收敛，根据经验定义为前后两次值变化小于0.1则判定算法收敛，返回最后一次计算的结果。</p></li></ol><h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>约束包含针对优化指标的范围约束和结果函数的合理性约束。</p><ul><li><p>范围约束</p><p>范围约束是用户通过页面输入的温湿度范围，约束的形式为：<code>温度 &gt; 21 &amp;&amp; 温度 &lt; 26</code></p><p>在实现中我们通过Java的Function接口来构建约束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Function&lt;Map&lt;String,Object&gt;, BigDecimal&gt;&gt; <span class="hljs-title function_">buildConstraints</span><span class="hljs-params">(<span class="hljs-keyword">final</span> List&lt;BigDecimal[]&gt; rangeList)</span>&#123;<br>    <span class="hljs-comment">//otobd是自定义的方法，将Object转换为BigDecimal对象</span><br>        List&lt;Function&lt;Map&lt;String,Object&gt;, BigDecimal&gt;&gt; constraintList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        constraintList.add(val -&gt; <br>                           OptimizeUtils.otobd(val.get(<span class="hljs-string">&quot;param_1&quot;</span>)).negate().add(rangeList.get(<span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]));<br>        constraintList.add(val -&gt; <br>                           OptimizeUtils.otobd(val.get(<span class="hljs-string">&quot;param_1&quot;</span>)).subtract(rangeList.get(<span class="hljs-number">0</span>)[<span class="hljs-number">1</span>]));<br>        <span class="hljs-comment">//更多约束条件省略...</span><br>        <span class="hljs-keyword">return</span> constraintList;<br>    &#125;<br></code></pre></td></tr></table></figure><p>检查约束的时候，直接使用Function的apply方法即可完成约束检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Function&lt;Map&lt;String,Object&gt;, BigDecimal&gt;&gt; <span class="hljs-title function_">checkConstraints</span><span class="hljs-params">(BigDecimal[] initParam)</span>&#123;<br>        List&lt;Function&lt;Map&lt;String,Object&gt;, BigDecimal&gt;&gt; retConstraints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Function&lt;Map&lt;String, Object&gt;, BigDecimal&gt; f0 : constraintsList) &#123;<br>            <span class="hljs-comment">//buildPointParam 方法通过将数组映射到Map，方便方法调用</span><br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> f0.apply(OptimizeUtils.buildPointParam(initParam));<br>            <span class="hljs-keyword">if</span> (result.compareTo(BigDecimal.ZERO) &gt; <span class="hljs-number">0</span>) &#123;<br>                retConstraints.add(f0);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> retConstraints;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>合理性约束</p><p>在我们确定了使用Function来实现约束检查的时候，合理性约束只需要提供封装的方法即可。例如需求是小时能耗不能为负数，封装的方法就是返回最小的小时能耗，对应到Function的定义就是：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">val</span></span> -&gt; minHourCostFunction(<span class="hljs-name"><span class="hljs-built_in">val</span></span>).negate())<br></code></pre></td></tr></table></figure><p>这里对于Function的输出进行了negate操作，是为了在判断约束的时候可以统一使用大于0的判断。</p></li></ul><h3 id="KT条件"><a href="#KT条件" class="headerlink" title="KT条件"></a>KT条件</h3><blockquote><p>KT条件是指Karush-Kuhn-Tucker条件，它是数学优化问题中的一组条件，用于判断在约束条件下，某点是否为最优解。</p></blockquote><p>结合KT条件的一般呈现，</p><img src="kt条件.png"><p>我们得出如下结论：<strong>∇f(X)和∇g_i (X)已知，求解K-T条件，是在求解一组线性方程组。</strong></p><p>主要求解过程使用Apache Math3包可以实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span>[][] coefficients = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[initParam.length][constraintsBound.size()];<br><span class="hljs-comment">//省略构建系数矩阵的过程</span><br><span class="hljs-type">RealMatrix</span> <span class="hljs-variable">matrix1</span> <span class="hljs-operator">=</span> MatrixUtils.createRealMatrix(coefficients);<br><span class="hljs-comment">//常数项需要将梯度乘以-1，g为当前点的梯度</span><br>BigDecimal[] constants = gradientDiv(g,BigDecimal.valueOf(-<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//使用QR分解 求线性方程组唯一解</span><br><span class="hljs-type">DecompositionSolver</span> <span class="hljs-variable">solver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QRDecomposition</span>(matrix1).getSolver();<br><span class="hljs-type">double</span>[] constArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[constants.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;constants.length;i++)&#123;<br>constArr[i]=constants[i].doubleValue();<br>&#125;<br><span class="hljs-type">RealMatrix</span> <span class="hljs-variable">vector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array2DRowRealMatrix</span>(constArr);<br><span class="hljs-type">RealMatrix</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> solver.solve(vector);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; solution.getRowDimension(); i++) &#123;<br><span class="hljs-keyword">if</span>(solution.getEntry(i, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//全部非负则满足KKT</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="梯度模收敛"><a href="#梯度模收敛" class="headerlink" title="梯度模收敛"></a>梯度模收敛</h3><p>系统设定一个梯度模阈值（一般来自经验和反复试错），当梯度模小于阈值的时候，我们认为当前点已经到达了一个局部最优，直接返回当前点为本次优化结果。</p><h3 id="计算方向向量"><a href="#计算方向向量" class="headerlink" title="计算方向向量"></a>计算方向向量</h3><p>计算方向是可行方向法的关键，一个好的方向可以让算法更快的完成收敛。从程序流图我们可以发现，计算方向来自两个分支，而针对有约束和无约束我们采用了不同计算方向的策略。</p><ul><li><p>无约束</p><p>无约束情况适用梯度下降算法，当前点的负梯度方向即可行方向。</p></li><li><p>有约束</p><p>有约束情况下适用单纯形法，求解约束附近使得目标函数值最小的方向向量即可行方向。</p><p>定义算法表现形式如下：</p><img src="单纯形法.png"><p>实现过程适用Apache Math3包即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span>[] simplexSolver(<span class="hljs-type">double</span>[] g,<br>                                         BigDecimal[] initParam, Map&lt;String, Object&gt; fixParamMap,<br>                                         List&lt;Function&lt;Map&lt;String,Object&gt;, BigDecimal&gt;&gt; constraints)&#123;<br>        <span class="hljs-comment">//传入目标函数的系数</span><br>        <span class="hljs-type">LinearObjectiveFunction</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearObjectiveFunction</span>(g, <span class="hljs-number">0</span>);<br>        LinearConstraint[] constraintsArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>[constraints.size()+<span class="hljs-number">8</span>];<br>        <span class="hljs-comment">//初始化范围约束</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;constraints.size();i++)&#123;<br>            <span class="hljs-type">double</span>[] g0 = calcGradient(initParam,fixParamMap,constraints.get(i),C_DELTA);<br>            constraintsArr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(g0, Relationship.LEQ, <span class="hljs-number">0</span>);<br>        &#125;<br>    <span class="hljs-comment">//构建值约束，需要在-1到1</span><br>        LinearConstraint[] commonConstraints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, Relationship.LEQ, <span class="hljs-number">1</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, Relationship.GEQ, -<span class="hljs-number">1</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, Relationship.LEQ, <span class="hljs-number">1</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;, Relationship.GEQ, -<span class="hljs-number">1</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span> &#125;, Relationship.LEQ, <span class="hljs-number">1</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span> &#125;, Relationship.GEQ, -<span class="hljs-number">1</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;, Relationship.LEQ, <span class="hljs-number">1</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraint</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;, Relationship.GEQ, -<span class="hljs-number">1</span>)<br>        &#125;;<br>        System.arraycopy(commonConstraints,<span class="hljs-number">0</span>,constraintsArr,constraints.size(),<span class="hljs-number">8</span>);<br>        <span class="hljs-type">LinearConstraintSet</span> <span class="hljs-variable">constraintsSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearConstraintSet</span>(constraintsArr);<br>        <span class="hljs-type">SimplexSolver</span> <span class="hljs-variable">solver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimplexSolver</span>();<br>        <span class="hljs-type">PointValuePair</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> solver.optimize(f,constraintsSet,GoalType.MINIMIZE);<br>        <span class="hljs-keyword">return</span> solution.getPoint();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="约束一维搜索"><a href="#约束一维搜索" class="headerlink" title="约束一维搜索"></a>约束一维搜索</h3><blockquote><p>所谓约束一维搜索，就是求解一元函数约束极小点的算法。在确定初始区间时，对产生的每一个探测点都必须进行可行性判断，如果违反了某个或者某些约束条件，就必须减少步长因子，以使新的探测点落在最近的一个约束边界上或约束边界的一个容许区间内。</p></blockquote><img src="约束一维搜索.png"><p>针对a、b两种单调的情况，x3和x1为相应情况的极小值，在c中我们得到一个[x1,x3]的区间，然后通过黄金分割法查找出区间最小值。</p><p>算法步骤如下：</p><img src="一维搜索程序流.png"><p>在找到一个区间后，我们使用黄金分割法查找区间内的极小值。代码实现上使用递归逐步缩小范围，直到范围达到预定义的阈值，选取范围中心点作为极小点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BigDecimal[] findMinPoint(BigDecimal[] start, BigDecimal[] end,<br>                                      BigDecimal[] p1, BigDecimal[] p2,<br>                                      Map&lt;String, Object&gt; fixParamMap,Function&lt;Map&lt;String, Object&gt;, BigDecimal&gt; f)&#123;<br>        <span class="hljs-comment">//判断满足收敛精度</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> OptimizeUtils.calculateModulus(OptimizeUtils.gradientDiff(start,end));<br>        <span class="hljs-keyword">if</span>(threshold.compareTo(OptimizeUtils.GRATIO_THREASHOLD) &lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> OptimizeUtils.gradientDiv(OptimizeUtils.gradientAdd(start,end), BigDecimal.valueOf(<span class="hljs-number">2</span>));<br>        &#125;<br>        BigDecimal f1,f2;<br>        <span class="hljs-comment">//初始化区间</span><br>        <span class="hljs-keyword">if</span>(p1 == <span class="hljs-literal">null</span>)<br>            p1 = calculateGoldRatio(start,end, OptimizeUtils.GRATIO_DOWN);<br>        f1 = f.apply(buildPointParam(p1,fixParamMap));<br>        <span class="hljs-keyword">if</span>(p2 == <span class="hljs-literal">null</span>)<br>            p2 = calculateGoldRatio(start,end, OptimizeUtils.GRATIO_UP);<br>        f2 = f.apply(buildPointParam(p2,fixParamMap));<br>        <span class="hljs-keyword">if</span>(f1.compareTo(f2) &lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> findMinPoint(start,p2,<span class="hljs-literal">null</span>,p1,fixParamMap,f);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> findMinPoint(p1,end,p2,<span class="hljs-literal">null</span>,fixParamMap,f);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="回顾总结"><a href="#回顾总结" class="headerlink" title="回顾总结"></a>回顾总结</h2><p>在这个案例中我们通过引入可行方向法对汽车制造工艺的涂装车间能耗进行优化。</p><p>在可行方向的方向选择中我们结合了梯度下降法和单纯形法来应对是否存在约束的差异，明确了方向后我们采用了约束一维搜索获取下一次迭代的出发点，最终通过收敛条件得到一个相对最优解。</p><p>为了解决局部最优的困境，我们引入随机多个初始出发点，进行多次求解，减少局部最优出现的可能性。</p><p>最终经过验证的优化效果达到了15%的能耗节约。</p>]]></content>
    
    
    <categories>
      
      <category>工业算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据技术</tag>
      
      <tag>最优化技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从数采到平台，你可能差一个Airbyte</title>
    <link href="/2023/06/13/%E4%BB%8E%E6%95%B0%E9%87%87%E5%88%B0%E5%B9%B3%E5%8F%B0%EF%BC%8C%E4%BD%A0%E5%8F%AF%E8%83%BD%E5%B7%AE%E4%B8%80%E4%B8%AAAirbyte/"/>
    <url>/2023/06/13/%E4%BB%8E%E6%95%B0%E9%87%87%E5%88%B0%E5%B9%B3%E5%8F%B0%EF%BC%8C%E4%BD%A0%E5%8F%AF%E8%83%BD%E5%B7%AE%E4%B8%80%E4%B8%AAAirbyte/</url>
    
    <content type="html"><![CDATA[<p>随着工业互联网规模日渐增长，工业互联网应用对于数据的要求也越来越高。</p><p>面对来自现场设备的运行数据、来自控制器的环境数据以及来自上位机的各种应用数据，如何进行快速的整合归集高效的应用成为工业互联网平台的当务之急。考虑到多种数据的采集需求和采集方式都存在差异，如果有一个平台可以实现高层次抽象、可扩展实现，那无疑可以解决我们的问题，Airbyte带着ELT的理念应运而生。</p><p><a href="https://airbyte.com/">Airbyte</a>是一个开源的数据集成平台，提供了数据迁移的基本骨架，通过用户定制可以完美支持几乎所有的数据迁移需求。</p><span id="more"></span><h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p>从架构上来看，Airbyte由平台和连接器组成。</p><img src="architecture.png" alt="architecture" style="zoom:24%;" /><p>平台由一组微服务构建，实现了数据平台的基础设施，包含了UI、配置服务、调度服务、日志和告警等基础功能。</p><p>连接器提供了Source到Destination的连接，使用docker提供了连接的可扩展。</p><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><h3 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h3><p>实现一次数据迁移的主要载体是一个连接，我们从连接开始。一个连接通常包含了 1）Source Catelog 2）Destination 3）Sync Schedule 4）Sync Mode 5）Transformation</p><ol><li><p>Source Catelog</p><p>Source Catelog解决了数据从哪儿来的问题，通过Catelog定义了一组Stream（表），以及Stream中包含的Field（列）。Source可以是一个数据库，也可以是API或者文件。</p></li><li><p>Destination</p><p>Destination解决了数据到哪儿去的问题，可以是数据库、数据仓库、数据湖或者任何想要使用数据的目的地。</p></li><li><p>Sync Schedule</p><p>同步周期可以设置为手动同步、基于时间同步或者基于Cron表达式同步。</p><p>这里需要注意基于时间同步的情况，如果定义时间同步周期为“Every 12 Hours”，那么触发同步操作的决定是基于最近一次同步的，考虑如下场景：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span>月<span class="hljs-number">1</span>日<span class="hljs-number">10</span>:<span class="hljs-number">00</span> 完成首次自动同步<br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span>月<span class="hljs-number">1</span>日<span class="hljs-number">12</span>:<span class="hljs-number">00</span> 完成手动同步<br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span>月<span class="hljs-number">1</span>日<span class="hljs-number">22</span>:<span class="hljs-number">00</span> 判断距离上次同步未满<span class="hljs-number">12</span>小时，不会进行数据同步<br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span>月<span class="hljs-number">2</span>日<span class="hljs-number">0</span>:<span class="hljs-number">00</span>  完成第二次自动同步<br></code></pre></td></tr></table></figure></li><li><p>Sync Mode</p><p>同步模式主要包含四种，从名称可以很清楚的理解他们的行为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>， Full Refresh - Overwrite<br><span class="hljs-number">2</span>， Full Refresh - Append<br><span class="hljs-number">3</span>， Inc<span class="hljs-comment">remental Sync - Append</span><br><span class="hljs-number">4</span>， Inc<span class="hljs-comment">remental Sync - Dedupted History</span><br></code></pre></td></tr></table></figure></li><li><p>Transformation</p><p>数据转换属于可选项，针对某些特定的数据库可以选用Basic Normalize进行数据转换。</p></li></ol><h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>Airbyte的Normalization从功能上来说属于ELT中的T，基于开源项目实现。</p><p>在Airbyte的Source和Destination中传递的原始数据是以json格式组织，如果不做任何处理那么在目标数据库会以一个json列存储所有的数据。数据使用方要么实现自己的transformer进行格式转换，或者使用支持json的API，这在大数据集中无疑又带来了性能问题。</p><p>为了解决数据使用方的使用痛点，Airbyte针对常用的几种数据库提供了Normalization的支持，实现方式是提供了一个Raw Table和一个Destination Table。</p><p>假设源表名为Cars，表定义如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;make&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alfa romeo&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;model&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4C coupe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;horsepower&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;247&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>经过Airbyte传输到目标数据库后生成的Raw Table的表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> &quot;_airbyte_raw_cars&quot; (<br>    <span class="hljs-comment">-- metadata added by airbyte</span><br>    &quot;_airbyte_ab_id&quot; <span class="hljs-type">VARCHAR</span>, <span class="hljs-comment">-- uuid value assigned by connectors to each row of the data written in the destination.</span><br>    &quot;_airbyte_emitted_at&quot; TIMESTAMP_WITH_TIMEZONE, <span class="hljs-comment">-- time at which the record was emitted.</span><br>    &quot;_airbyte_data&quot; JSONB <span class="hljs-comment">-- data stored as a Json Blob.</span><br>);<br></code></pre></td></tr></table></figure><p>经过Normalization之后的目标表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> &quot;cars&quot; (<br>    &quot;_airbyte_ab_id&quot; <span class="hljs-type">VARCHAR</span>,<br>    &quot;_airbyte_emitted_at&quot; TIMESTAMP_WITH_TIMEZONE,<br>    &quot;_airbyte_cars_hashid&quot; <span class="hljs-type">VARCHAR</span>,<br>    &quot;_airbyte_normalized_at&quot; TIMESTAMP_WITH_TIMEZONE,<br><br>    <span class="hljs-comment">-- data from source</span><br>    &quot;make&quot; <span class="hljs-type">VARCHAR</span>,<br>    &quot;model&quot; <span class="hljs-type">VARCHAR</span>,<br>    &quot;horsepower&quot; <span class="hljs-type">INTEGER</span><br>);<br></code></pre></td></tr></table></figure><p><em>支持Basic Normalization的数据库</em></p><p>BigQuery，MSSQL Server，MySQL 8+，Postgres，Redshift，Snowflake。</p><h2 id="生产应用"><a href="#生产应用" class="headerlink" title="生产应用"></a>生产应用</h2><p>基于本次的数据集成需求：从客户现场上位机的Oracle数据库同步数据到工业互联网平台的Clickhouse，我们制定了如下的数据同步方案：</p><ul><li>主要骨架基于Airbyte实现，实现Oracle数据库抽取数据并发送到RabbitMQ的功能</li><li>编码实现消息消费者，完成数据转换和Clickhouse数据库的写入</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>操作系统方面，通过测试的操作系统有Ubuntu 22.04和Window 10 with Docker Desktop，而测试不通过的操作系统为Centos 7。</p><p>Airbyte需要在Docker环境下运行，所以在方案实施之前需要准备Docker的运行环境，需要特别注意的是Docker Compose需要V2版本以上。</p><p>Airbyte的本地安装只需要下载一个run_ab_platform.sh，并执行 <code>run run_ab_platform.sh -b</code>命令即可，不要按照官方文档下载整个源码库。</p><p>如果需要使用Oracle Source需要首先下载airbyte&#x2F;source-oracle的镜像，使用docker pull命令拉取。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>建立连接的第一步是选择Source，根据需求我们选择了Oracle Source并填入数据库相关信息；</p><p>第二步选择Destination，我们选择了RabbitMQ并填入了相关配置信息；</p><p>最后一步选择同步的表，同步方式和同步周期。</p><img src="connection.png" alt="connection" style="zoom:60%;" /><p>通过连接配置，Airbyte会连接Oracle数据库抽取到数据，以json的格式发送到RabbitMQ的消息队列中。接下来就是实现一个消费者实现数据转换和存储。</p><h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><p>我们通过SpringBoot实现的RabbitListener来进行消息的消费。</p><p>消息格式参考Airbyte的文档定义：</p><blockquote><p>Each stream will be output a RabbitMQ message with properties. The message properties will be</p><ul><li><code>content_type</code>: set as <code>application/json</code></li><li>headers：message headers, which include:<ul><li><code>stream</code>: the name of stream where the data is coming from</li><li><code>namespace</code>: namespace if available from the stream</li><li><code>emitted_at</code>: timestamp the <code>AirbyteRecord</code> was emitted at.</li></ul></li></ul><p>The <code>AirbyteRecord</code> data will be serialized as JSON and set as the RabbitMQ message body.</p></blockquote><p>所以在Consumer中关注headers中的stream字段和Message body的 payload。</p><p>通过Stream对应的表名决定目标表，同时将payload解析成Map格式对应表中的字段和值。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queuesToDeclare = &#123;@Queue(name = &quot;airbyte.oracle-source&quot;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dataSync</span><span class="hljs-params">(Message&lt;String&gt; message)</span>&#123;<br>        LOG.info(message.getHeaders().get(<span class="hljs-string">&quot;stream&quot;</span>).toString());<br>        LOG.info(message.getPayload());<br><span class="hljs-comment">//根据Stream确定表名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> message.getHeaders().get(<span class="hljs-string">&quot;stream&quot;</span>).toString().toUpperCase();<br>        TypeToken&lt;Map&lt;String, String&gt;&gt; type = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;Map&lt;String, String&gt;&gt;()&#123;&#125;;<br>        <span class="hljs-comment">//解析payload得到数据</span><br>        Map&lt;String, String&gt; data = gson.fromJson(message.getPayload(), type.getType());<br>        List&lt;String&gt; columns = clickHouseUtilService.showColumns(tableName);<br>        data.keySet().removeIf(key -&gt; !columns.contains(key.toUpperCase()));<br>        <span class="hljs-keyword">try</span> &#123;<br>            clickHouseUtilService.batchInsert(tableName,columns, Collections.singletonList(data));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            LOG.error(<span class="hljs-string">&quot;error when insert data to clickhouse, &quot;</span>, ex);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>通过上面的研究我们不难发现，Airbyte的基本思想还是基于传统数据迁移的流程化处理，创新点在于将可能成为数据集成瓶颈的数据转换进行了概念弱化和位置后移，从而大大提升了数据移动的速度。擅长的事情做到极致，不擅长的事情交给别人。</p><p>通过引入Airbyte的解决方案作为边缘数据集成平台的骨架，借助已有的source和destination我们可以快速形成边缘数据集成平台的雏形。结合Airbyte开源的特点和基于Docker的连接器架构，我们可以自定义工业限定的连接器来扩展平台的能力并构建平台技术壁垒。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据采集</tag>
      
      <tag>架构设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配后端的多语言方案</title>
    <link href="/2023/04/23/%E9%80%82%E9%85%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%96%B9%E6%A1%88/"/>
    <url>/2023/04/23/%E9%80%82%E9%85%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章中我们实现了基于vue-i18n的前端多语言方案，在这个方案中我们考虑了部分前后端交互中存在的问题如数据库菜单、代码直接返回错误信息等。在实现过程中我们发现如果只是将资源文件在前端工程管理，一些对多语言依赖较强的后端系统就无法正常工作，如日志中心。基于前后端通用的考虑，我们将资源文件作为配置项移动到Nacos进行维护，这篇文章会在这个前提下对基于vue-i18n的前端多语言方案进行系统改造。</p><span id="more"></span><h2 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h2><img src="solution-2.png" alt="solution-2" style="zoom:40%;" /> <p>本方案以日志中心作为后端切入口，进行前后端适配多语言的验证。</p><p>前端vue-i18n中通过openAPI访问Nacos加载翻译资源文件，后端通过Nacos客户端加载资源，并提供用于翻译的辅助方法。下面我们分别从前端资源加载、日志入库和日志查询三个方面详细介绍方案实现细节。</p><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>前端vue-i18n需要在初始化的时候，调用openAPI从Nacos加载翻译资源文件。主要通过两个js实现，</p><h4 id="nacos-js"><a href="#nacos-js" class="headerlink" title="nacos.js"></a>nacos.js</h4><p>nacos.js实现通过openAPI访问Nacos的功能，实现通过语言加载资源的功能，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> serverAddr = <span class="hljs-string">&#x27;/i18n&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getI18nResource</span>(<span class="hljs-params">locale</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: serverAddr + <span class="hljs-string">&#x27;/nacos/v1/cs/configs&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">tenant</span>: <span class="hljs-string">&#x27;local&#x27;</span>,<br>      <span class="hljs-attr">dataId</span>: <span class="hljs-string">&#x27;locale.&#x27;</span> + locale + <span class="hljs-string">&#x27;.json&#x27;</span>,<br>      <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;DEFAULT_GROUP&#x27;</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里定义了serverAddr为服务前缀，通过nginx配置转发到Nacos Server以解决跨域问题。</p><h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4><p>main.js中调用nacos.js定义的方法，加载资源并添加到全局i18n对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> i18n <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/common/lang/i18n&#x27;</span><br><span class="hljs-keyword">import</span> &#123; getI18nResource &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/common/utils/nacos.js&#x27;</span><br><br><span class="hljs-comment">// 异步加载i18n资源</span><br><span class="hljs-keyword">const</span> lang = [<span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;zh-CN&#x27;</span>]<br><span class="hljs-keyword">const</span> langPromises = lang.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">l</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getI18nResource</span>(l)<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(langPromises).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) &#123;<br>  message.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">m, i</span>) &#123;<br>    i18n.<span class="hljs-title function_">mergeLocaleMessage</span>(lang[i], m)<br>  &#125;)  <br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    router,<br>    i18n,<br>    store,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="后端适配"><a href="#后端适配" class="headerlink" title="后端适配"></a>后端适配</h3><p>后端通过LocaleService封装翻译相关的方法，提供Nacos语言包的适配。</p> <img src="LocaleService.png"><ul><li><p>getResourceMap</p><p>加载全局资源到内存，同时将Nacos中储存的级联map格式转换为简单的flat map格式</p></li><li><p>getExactSidByLang</p><p>通过语言和内容精确查找翻译的SID，查找基于加载的ResourceMap</p></li><li><p>getMatchSidByLang</p><p>通过语言和内容模糊查找翻译的SID，查找基于加载的ResourceMap</p></li><li><p>translate</p><p>通过SID和语言翻译成对应的内容，查找基于加载的ResourceMap</p></li><li><p>encodeLocaleObject</p><p>将原始对象进行编码，主要将需要编码的字段转换为SID</p></li><li><p>decodeLocaleObject</p><p>将编码对象进行解码，主要讲需要解码的字段翻译为原始内容</p></li></ul><p>在上述方法中，对于encode和decode的过程，我们引入了一个注解@i18n标注需要编码和解码的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestObject</span> &#123;<br><br>    String name;<br>    <span class="hljs-meta">@I18n</span><br>    String val1;<br>    <span class="hljs-meta">@I18n</span><br>    String val2;<br>&#125;<br></code></pre></td></tr></table></figure><p>encode和decode的原理都是直接使用反射进行取值、翻译和赋值的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Field&gt; fieldList = FieldUtils.getFieldsListWithAnnotation(o.getClass(), I18n.class);<br>        <span class="hljs-keyword">for</span>(Field f : fieldList)&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> FieldUtils.readField(f,o, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">if</span>( val != <span class="hljs-literal">null</span> &amp;&amp; val <span class="hljs-keyword">instanceof</span> String )&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">strValue</span> <span class="hljs-operator">=</span> val.toString();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">finalValue</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getExactSidByLang(lang, strValue);<br>                <span class="hljs-comment">//不为空说明编码成功，才需要替换写入</span><br>                <span class="hljs-keyword">if</span>(StringUtils.isNotBlank(finalValue)) FieldUtils.writeField(f,o,finalValue,<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="场景验证"><a href="#场景验证" class="headerlink" title="场景验证"></a>场景验证</h3><p>在日志的使用场景中主要分为日志入库和日志查询，</p><ul><li><p>日志入库</p><img src="loginput-2.png" alt="img" style="zoom:67%;" /> <p>日志接收后解析为日志原始对象，经过日志编码调用 encodeLocaleObject 方法，将加了@i18n注解的字段进行编码后生成编码对象，编码的时候默认客户端发送的日志都是中文，按照中文进行编码。</p><p>得到编码对象后调用ES客户端将编码对象写入ES。</p></li><li><p>日志查询</p><img src="logoutput-2.png" alt="logoutput-2" style="zoom:67%;" /> <p>用户在发起日志查询的时候需要输入目标语言和查询条件。</p><p>日志查询请求首先根据参数注解进行编码，然后依据编码后的参数进行日志查询。查询得到编码的对象后需要根据注解调用 decodeLocaleObject 方法进行解码，解码的时候使用用户输入的目标语言，最终生成了目标语言对象。这时候将目标语言对象返回就是用户的查询结果了。</p></li></ul><h2 id="方案回顾"><a href="#方案回顾" class="headerlink" title="方案回顾"></a>方案回顾</h2><p>我们在基于前端的多语言方案中引入了Nacos作为配置中心存放语言资源文件，实现了前后端的多语言可用。</p><p>前端在初始化vue实例的时候动态获取Nacos的资源包，注入到i18n对象中实现多语言的支持；后端实现的时候通过注解结合反射的方式，基于对象进行多语言的编解码，对实现细节实现封装简化了开发难度。</p><p>此外引入了语言枚举类，来提高多语言接口的容错能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">LangEnum</span>&#123;<br>        en(<span class="hljs-string">&quot;en&quot;</span>,<span class="hljs-string">&quot;en&quot;</span>),<br>        cn(<span class="hljs-string">&quot;zh-CN&quot;</span>,<span class="hljs-string">&quot;zh,cn,zh-cn&quot;</span>);<br>        String lang;<br>        String potential;<br>        LangEnum(String l, String p)&#123;<br>            lang = l;<br>            potential = p;<br>        &#125;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLang</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> lang;<br>        &#125;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPotential</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> potential;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*识别用户输入的语言，匹配到预定义的系统语言*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LangEnum <span class="hljs-title function_">getLangEnum</span><span class="hljs-params">(String input)</span>&#123;<br>        <span class="hljs-keyword">if</span>(StringUtils.isBlank(input)) <span class="hljs-keyword">return</span> LangEnum.cn;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">upperInput</span> <span class="hljs-operator">=</span> input.toUpperCase();<br>        <span class="hljs-keyword">for</span>(LangEnum lang : LangEnum.values())&#123;<br>            <span class="hljs-keyword">if</span>(Arrays.stream(lang.getPotential().split(<span class="hljs-string">&quot;,&quot;</span>))<br>               .anyMatch(p-&gt; p.toUpperCase().contains(upperInput)))<br>                <span class="hljs-keyword">return</span> lang;<br>        &#125;<br>        <span class="hljs-comment">//默认语言中文简体</span><br>        <span class="hljs-keyword">return</span> LangEnum.cn;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>架构设计</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于前端的多语言实施方案</title>
    <link href="/2023/03/31/%E5%9F%BA%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%96%BD%E6%96%B9%E6%A1%88/"/>
    <url>/2023/03/31/%E5%9F%BA%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%96%BD%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>随着公司产品的进一步成熟，按照走出园区走出街道的发展路线，走出国门是走向巅峰的必经之路，而打通国际化的第一步就是多语言版本的支持。目前产品的技术架构是vue+SpringBoot的前后端分离架构，我们选择了基于vue-i18n的前端实施方案。</p><span id="more"></span><h2 id="方案概述"><a href="#方案概述" class="headerlink" title="方案概述"></a>方案概述</h2><p>多语言的核心是将页面hard code的资源如label标签、表格title等元素抽象成语言配置项，通过监测用户的语言偏好注入合适的语言包，以满足多语言支持和切换的需求。</p><img src="overview.png" alt="overview" style="zoom:30%;" /><p>vue-i18n是一个基于vue.js的国际化组件，通过提供一组简单的API封装提供了基于vue的国际化解决方案。</p><p>从宏观层面，vue-i18n的应用步骤可以概括如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 准备语言包，可以是js格式也可以是json格式<br><span class="hljs-bullet">2.</span> 通过一个js（建议命名为i18n.js）将语言包引入vue-i18n对象<br><span class="hljs-bullet">3.</span> 设置系统使用的locale来具体定位语言包<br><span class="hljs-bullet">4.</span> 修改页面所有hard code的地方，使用语言包中的配置项代替hard code<br></code></pre></td></tr></table></figure><p>从微观实施角度出发，项目的应用步骤为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 多语言框架搭建（包含语言包、i18n.js和locale相关的准备工作）<br><span class="hljs-bullet">2.</span> 识别页面所有的配置项，进行命名<br><span class="hljs-bullet">3.</span> 依据已经识别的配置项更新语言包<br><span class="hljs-bullet">4.</span> 测试并重复步骤2<br><span class="hljs-bullet">5.</span> 所有配置项都被识别出之后，调整页面样式适配多语言<br></code></pre></td></tr></table></figure><p>下面我们基于微观角度来看看具体到项目实施，如何实现多语言。</p><h2 id="项目实施"><a href="#项目实施" class="headerlink" title="项目实施"></a>项目实施</h2><h3 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h3><p>框架搭建可以基于官网的startup，当然这个startup为了考虑通用性，应用到具体项目的时候还需要进行一些适当的扩展和裁剪。</p><p>首先需要安装vue-i18n插件，安装的时候需要区分项目的vue版本，如果是vue2则使用vue-i18n@8，否则使用vue-i18n@9。</p><p>然后我们在项目目录src&#x2F;common 下创建了lang&#x2F;locale的目录结构，主要包含了三个文件：</p><ol><li><p>lang&#x2F;i18n.js</p><p>通过i18n.js，构造一个包含语言包的Vuei18n对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueI18</span>n <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-i18n&#x27;</span><br><span class="hljs-keyword">import</span> enLocale <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./locale/en&#x27;</span><br><span class="hljs-keyword">import</span> cnLocal <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./locale/zh-CN&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueI18</span>n)<br><span class="hljs-keyword">const</span> messages = &#123;<br>  <span class="hljs-attr">en</span>: &#123;<br>    ...enLocale<br>  &#125;,<br>  <span class="hljs-attr">zh</span>: &#123;<br>    ...cnLocal<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> i18n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueI18</span>n(&#123;<br>  <span class="hljs-attr">locale</span>: <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;lang&#x27;</span>) || <span class="hljs-string">&#x27;en&#x27;</span>,<br>  messages,<br>  <span class="hljs-attr">fallbackLocale</span>: <span class="hljs-string">&#x27;zh&#x27;</span>,<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> i18n<br><br></code></pre></td></tr></table></figure></li><li><p>lang&#x2F;locale&#x2F;en.json</p><p>英文语言包，json格式，大概的内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;common&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <br>    <span class="hljs-attr">&quot;userProfile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>      <br>      <span class="hljs-attr">&quot;changePassword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Change Password&quot;</span><span class="hljs-punctuation">,</span>      <br>      <span class="hljs-attr">&quot;originalPassword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Original Password&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;newPassword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;New Password&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;cancel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Cancel&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;save&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Save&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>lang&#x2F;locale&#x2F;zh-CN.json</p><p>中文的语言包</p></li></ol><p>最后将vue-i18n对象通过main.js注入到全局的vue对象中，我们基于vue-i18n的多语言前端框架就搭建完成了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*main.js*/</span><br><span class="hljs-keyword">import</span> i18n <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/common/lang/i18n&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  i18n,<br>  store,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="识别配置项"><a href="#识别配置项" class="headerlink" title="识别配置项"></a>识别配置项</h3><p>在开始之前我们确定了配置项的三层配置结构：</p><p><code>&#123;app&#125;.&#123;module&#125;.&#123;SID&#125;</code></p><p>以上文出现过的 “common.userProfile.newPassword” 为例，应用是公共平台，模块是用户信息，唯一标识就是newPassword。</p><p>在识别配置项的时候我们可以引入vscode的多语言插件 - i18n Ally。通过i18n Ally可以快速的定位出页面的hard code编码，并通过Ally编辑器快速的编辑多语言信息。</p><p>安装好插件后，首先编辑项目目录下的.vscode&#x2F;settings.json文件加入Ally的配置，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;i18n-ally.localesPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/common/lang/locale&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;i18n-ally.keystyle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nested&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;i18n-ally.sortKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;i18n-ally.enabledParsers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;json&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;i18n-ally.sourceLanguage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zh-CN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;i18n-ally.displayLanguage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zh-CN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;i18n-ally.enabledFrameworks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;vue&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>重启VSCode后就可以看到左边出现了i18n Ally的图标，</p><img src="ally.png" alt="image-20230317133051553" style="zoom:50%;" /><p>选择待翻译文件，点击Ally图标就可以识别出文件中hard code的配置项了。</p><img src="ally-view.png" alt="image-20230317133551544" style="zoom:50%;" /><p>如图所示，当前页面有4个待翻译项，选择一个hard code string可以添加为配置项，也可以定位到具体位置，修改为已有配置项。更新完成后代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-button<br>          class=&quot;submit&quot;<br>          type=&quot;primary&quot;<br>          @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;<br>          &gt;&#123;&#123; $t(&#x27;common.save&#x27;) &#125;&#125;&lt;/el-button&gt;<br></code></pre></td></tr></table></figure><img src="ally-edit.png" alt="image-20230317134325836" style="zoom:50%;" /><p>翻译进度部分主要处理多语言不一致的情况，如果一个配置项加了英文没有加中文翻译，那么在中文的进度就会提示有缺失的文案或者空值，提醒用户有遗漏。这时候点击改配置项可以进入配置项的Ally编辑器，来编辑对应的中英文信息。</p><p>在翻译树部分展示的是系统现有的配置项，可以作为配置项定义的结构参考，也可以直接复制配置项路径应用到当前文件。</p><h3 id="更新语言包"><a href="#更新语言包" class="headerlink" title="更新语言包"></a>更新语言包</h3><p>经过识别配置项，我们可以得到一个初始版本的配置项和系统中文翻译的对应关系。</p><p>为了方便管理维护和多方协作，我们定义了语言包管理的模板，格式如下：</p><table><thead><tr><th>APP</th><th>Module</th><th>SID</th><th>en</th><th>zh-CN</th><th>其他语言</th></tr></thead><tbody><tr><td>common</td><td></td><td>cancel</td><td>Cancel</td><td>取消</td><td></td></tr><tr><td>common</td><td>userProfile</td><td>newPassword</td><td>New Password</td><td>新密码</td><td></td></tr></tbody></table><p>前面三列组成了唯一的配置项ID，后面一列对应一种语言，所以经过识别语言包我们的1-3列和zh-CN列已经填充完成，需要组织翻译人员完成en列的填写即可。</p><p>为了方便实际操作，<a href="https://gitee.com/luischen/toolbox">我们还开发了一款语言包生成工具</a> ，支持Excel和json文件的互转。当Excel版本的语言包更新完成后可以自动根据语言列生成对应的json文件，部署到环境即可完成语言包的实时更新。</p><p><strong>语言包的更新是一个迭代的过程，通过测试发现问题后需要重新识别配置项并更新语言包。</strong></p><h3 id="页面样式调整"><a href="#页面样式调整" class="headerlink" title="页面样式调整"></a>页面样式调整</h3><p>在完成多语言的更新后，由于语言描述的长度差异会对页面展示造成冲击，如图所示一个很简单的例子：</p><img src="change-after.png" alt=""/><p>原密码和新密码在中文模式下是一行，换成英文后变成了两行，这时候就需要调整页面label的宽度来适配中英文了。</p><p>页面样式调整主要通过全页面的测试来覆盖，也可以理解为一个迭代的过程。</p><h2 id="方案回顾"><a href="#方案回顾" class="headerlink" title="方案回顾"></a>方案回顾</h2><p>在上述多语言方案和具体实施过程中，我们首先基于现有系统技术架构明确方案是基于前端的多语言实施方案，采用了vue生态中比较常用的vue-i18n作为主要实现基座。在识别配置项的过程中我们引入了i18n-Ally插件协助我们快速发现待配置项，识别出配置项后考虑语言包管理的便捷性，我们采用统一的Excel模板管理语言包，并通过自研工具完成json语言包和Excel语言包的转换。在实施过程中运用迭代更新的策略，逐步完善语言包和系统样式，最终实现了系统的多语言支持。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>附录部分主要记录一些语言替换过程中遇到的坑。</p><ol><li><p>目前有部分配置项内容是写在数据库中的，如app name，menu name等。</p><p>将数据库更新为唯一的配置项ID，而不是hard code，页面上通过配置项解析实现多语言支持。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app-name&quot;</span>&gt;</span><br>                  &#123;&#123; $t(app.appName) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>placeholder，title这些html属性需要改成动态赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">:placeholder=&quot;$t(&#x27;login.password_placeholder&#x27;)&quot;<br></code></pre></td></tr></table></figure></li><li><p>后端直接返回的错误信息。</p><p>后端定义错误返回信息的时候需要定义成{app}.{“err”}.{errId}的格式在前端进行解析。</p></li><li><p>通用字符串的配置，采用插值</p><p>例如有的label需要配置冒号，这时候可以定义成：</p><p><code>common.label.region= Region&#123;post&#125;</code></p><p>在使用的时候将post传值进去：</p><p><code>this.$t(&#39;common.label.region&#39;,&#123;post:&#39;:&#39;&#125;)</code></p><p>解析出来就是 “Region :”</p></li><li><p>复数的配置,采用预定义函数tc</p><p>如查询页面的时间范围可能为1小时，2小时…12小时，这时候可以使用tc函数</p><p>配置的时候配置成：</p><p><code>common.search.hour = &#123;num&#125;hour | &#123;num&#125;hours</code></p><p>使用的时候：</p><p><code>this.$tc(&#39;common.search.hour&#39;,10,&#123;num:&#39;10&#39;&#125;)</code></p><p>这时候解析出来就是 10小时，对应的英文是 10 hours</p></li><li><p>嵌套多语言的运用</p><p>如页面的非空校验，一般的提示是“请输入xxx”，这时候我们可以使用嵌套多语言减少资源的定义。</p><p><code>data.collect.selectWarning = Please choose &#123;field&#125;</code></p><p>使用的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs uev">this.$t(&#x27;data.collect.selectWarning&#x27;, &#123;<br>            field: this.$t(&#x27;data.searchField.region&#x27;)<br>          &#125;)<br></code></pre></td></tr></table></figure><p>这样解析出来就是 “Please choose region”</p></li><li><p>ElementUI的国际化</p><p>首先需要在i18n.js中引入element-ui的语言包，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">import eleEnLocale from &#x27;element-ui/lib/locale/lang/en&#x27;<br>import eleZhLocale from &#x27;element-ui/lib/locale/lang/zh-CN&#x27;<br>...<br>const messages = &#123;<br>  en: &#123;<br>    ...enLocale,<br>    ...eleEnLocale<br>  &#125;,<br>  zh: &#123;<br>    ...cnLocal,<br>    ...eleZhLocale<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在main,js中注入ElementUI的时候传入i18n属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">Vue.use(ElementUI, &#123;<br>  i18n: (key, value) =&gt; i18n.t(key, value)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>Echarts的国际化</p><p>Echarts中的Tooltip在使用format函数的时候，函数作用域无法获取i18n的$t方法，这时候需要在图表创建方法时将i18n方法代理到当前作用域中：</p><p><code>let that = this</code></p><p>然后在format函数中使用 that.$t 即可</p></li><li><p>子组件中的props的默认值</p><p>将props中的默认值，通过computed进行封装，使用的时候使用computed的值</p></li><li><p>嵌套组件中赋值不能加this</p><p>如图所示的使用方式，在img中无法通过this来获取i18n对象，这时候把this去掉即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-table-column :label=&quot;this.$t(&#x27;common.operation&#x27;)&quot; min-width=&quot;4%&quot;&gt;<br>    &lt;template #default=&quot;&#123; row &#125;&quot;&gt;<br>    &lt;el-button&gt;<br>    &lt;img :title=&quot;$t(&#x27;core.configure.collectItem&#x27;)&quot;/&gt;<br>    &lt;/el-button&gt;<br>    &lt;/template&gt;<br>&lt;/el-table-column&gt;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何监测配置数据的变化</title>
    <link href="/2022/12/29/%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <url>/2022/12/29/%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>在工业互联网平台上存在多种业务应用，每个应用有自己的配置数据，当配置数据发生变更的时候需要及时的下发到边缘节点让配置生效。我们可以通过节点管理模块提供手动下发的功能，即操作人员修改完配置后通知系统管理员进行对应节点的配置下发。实际操作中发现由于引发配置变更的点过于分散，导致经常会忘记下发而无法使配置及时生效。再者业务操作人员自己并不清楚当前操作的配置是否需要下发，会引发很多无效的沟通，降低了生产效率。</p><p>如何在配置发生变化的时候及时监测到变更，由系统自动来引导配置变更流程是我们需要解决的问题，我们通过埋点通知的机制来应对。整体解决方案如下图：</p><span id="more"></span><img src="配置下发方案.png" alt="配置下发方案" style="zoom: 45%;" /><p>如图所示，对于每个App的配置变更点，我们抽象一个Point Cut，通过对Point Cut的监控，可以获取配置的变化信息。同时通过MQ通知到节点管理服务，节点管理服务处理节点的配置版本管理。</p><p>在整个方案中主要的技术细节有两点：</p><ol><li>配置变更点的抽象</li><li>配置版本管理</li></ol><p>接下来就针对这两点进行详细的实现。</p><h3 id="配置变更点"><a href="#配置变更点" class="headerlink" title="配置变更点"></a>配置变更点</h3><p>APP基于SpringBoot开发，所以在配置变更点上我们选用Spring AOP结合注解的方式。</p><h4 id="引入Spring-AOP"><a href="#引入Spring-AOP" class="headerlink" title="引入Spring AOP"></a>引入Spring AOP</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AppConfigureChange &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="监控注解"><a href="#监控注解" class="headerlink" title="监控注解"></a>监控注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**App 配置发生变化的切面*/</span><br><span class="hljs-meta">@Pointcut(&quot;@annotation(com.manu.tbs.foundation.service.aop.AppConfigureChange)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appConfigureOnChange</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-meta">@AfterReturning(value=&quot;appConfigureOnChange()&quot;,returning = &quot;retObject&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appConfigurePostChange</span><span class="hljs-params">(Object retObject)</span>&#123;<br>    LOGGER.info(<span class="hljs-string">&quot;app configure post with return &#123;&#125;&quot;</span>,retObject);<br>    <span class="hljs-keyword">if</span>(retObject != <span class="hljs-literal">null</span> &amp;&amp; retObject <span class="hljs-keyword">instanceof</span> ResponseModel)&#123;<br>        <span class="hljs-type">ResponseModel</span> <span class="hljs-variable">responseModel</span> <span class="hljs-operator">=</span> (ResponseModel)retObject;<br>        <span class="hljs-keyword">if</span>(responseModel.isSuccess())&#123;<br>            mySender.sendMessage(SystemMqEnum.Q_UPDATE_APP_CONFIGURE.getQueueName(), <span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            LOGGER.error(<span class="hljs-string">&quot;try to change configure fail.&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过创建一个切面方法appConfigureOnChange来进行注解监控，通过AfterReturning获得的返回值类型判断是否需要发送变更通知。</p><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>最后一步就是在可能引发配置变更的方法上加上@AppConfigureChange注解即可完成配置监测。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@AppConfigureChange</span><br><span class="hljs-keyword">public</span> ResponseModel <span class="hljs-title function_">importConfig</span><span class="hljs-params">(MultipartFile configFile)</span> &#123;<br>    <span class="hljs-comment">//导入逻辑实现</span><br>    <span class="hljs-keyword">return</span> ResponseModel.success();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在每次配置导入成功的时候即可监测到配置变化，触发变更通知发送。</p><h3 id="配置版本管理"><a href="#配置版本管理" class="headerlink" title="配置版本管理"></a>配置版本管理</h3><p>版本管理主要通过两张表来实现：</p><ul><li><p>应用配置表记录应用的配置历史记录，可以获取应用当前的最新配置</p></li><li><p>节点配置表记录节点的最新配置，配置下发成功后更新记录</p></li></ul><img src="data-model.png" alt="image-20221229134322441" style="zoom:80%;" /><p>节点管理服务接收到配置变更的通知后会更新应用配置表的版本信息。</p><table><thead><tr><th>history_id</th><th>app_id</th><th>version_no</th><th>version_seq</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>202212291010</td><td>1</td></tr><tr><td>2</td><td>1</td><td>202212291020</td><td>2</td></tr></tbody></table><p>如上表所示app&#x3D;1的的最新版本为2，页面定时任务通过比对节点的当前版本和应用的最新版本来判断是否需要配置下发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nodeVersionMatch</span><span class="hljs-params">(NodeConfigure nodeConfigure, AppConfigureDTO appConfigure)</span>&#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">appConfigure</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> <br>            ||(nodeConfigure != <span class="hljs-literal">null</span> <br>               &amp;&amp;appConfigure.getVersionSeq().equals(nodeConfigure.getVersionSeq()));<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果判断出节点需要进行配置下发，则在下发结束后更新节点配置，更新完成后节点配置表的数据如下：</p><table><thead><tr><th>configure_id</th><th>node_id</th><th>version_no</th><th>version_seq</th><th>configure_data</th><th>bak_data</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>202212291020</td><td>2</td><td>{json格式的配置数据}</td><td>{上一次下发的配置数据}</td></tr></tbody></table><p>如上表所示节点1的最新配置版本为2，配置数据和配置备份数据都可以被保留下来便于问题定位。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在多应用的场景下如何集中管理配置变更是一个很重要的话题，我们通过基于注解的切面实现了一个灵活易用的监测机制，通过对方法添加注解可以快速埋点。在管理端我们通过应用和节点的版本记录实现了简单版本管理和版本变更的判断逻辑。两者结合之下一个可复用的配置数据监测方案基本成型，具体项目中可以结合实际需求进行扩展和使用。</p>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技术</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务接口认证</title>
    <link href="/2022/05/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%AE%A4%E8%AF%81/"/>
    <url>/2022/05/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>在前后端分离的实践中接口定义问题是无法回避的。关于接口的认证和访问权限设置，这里记录一些个人想法。</p><p>首先我们将接口分为几个不同的访问等级：</p><ol><li>level-1 开放接口，对所有人开放无需认证</li><li>level-2 认证接口，仅对认证用户开放，每次访问需要通过用户token进行认证</li><li>level-3 内部接口，仅对内部开放，通过内部约定的token进行认证</li></ol><p>根据接口等级的定义，我们可以得到接口的几种访问形式：</p><ul><li>服务内部模块调用 </li><li>跨服务调用 </li><li>前端调用 </li><li>第三方调用 </li><li>公开调用</li></ul><span id="more"></span><p>最终我们可以汇总出接口的访问矩阵</p><table><thead><tr><th>访问方式\接口等级</th><th>开放接口L1</th><th>认证接口L2</th><th>内部接口L3</th></tr></thead><tbody><tr><td>服务内部调用</td><td>√</td><td>×</td><td>√</td></tr><tr><td>跨服务调用</td><td>√</td><td>×</td><td>√</td></tr><tr><td>前端调用</td><td>√</td><td>√</td><td>×</td></tr><tr><td>第三方调用</td><td>√</td><td>√</td><td>×</td></tr><tr><td>公开调用</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>JWT，全称Json Web Tokens，是一个开放的、符合工业标准RFC 7519的认证方法，主要用于满足交互双方的安全需求。</p><blockquote><p>JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.</p></blockquote><p>JWT由header,payload和signature三部分组成。</p><p>header包含了token类型和加密算法。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>payload是信息的主体，可以包含任何想要传递的信息，但是从安全考虑包含的信息应该是不敏感的信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;userId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;userName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Test&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>header和payload部分都通过base64UrlEncode对内容进行编码。signature是token的签名部分，主要用于确保token没有被篡改。签名算法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">HMACSHA256</span>( <span class="hljs-title function_">base64UrlEncode</span>(header) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-title function_">base64UrlEncode</span>(payload), secret)<br></code></pre></td></tr></table></figure><p>这里的 HMACSHA256 是在header部分指定的加密算法，secret是约定的密钥，是安全的保证。</p><img src="encode-decode.png" style="zoom:50%;" /><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>在实际应用场景中，需要使用到JWT认证的有：</p><ul><li>用户认证，登录用户需要访问系统接口的情况</li><li>模块认证，模块之间接口访问的情况</li><li>服务认证，系统之间接口访问的情况</li></ul><h3 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h3><p>针对用户认证场景，我们定义业务类型为1，在JWT的header中增加字段bizType来描述，即用户认证token的header为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;bizType&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在payload中需要包含用户的相关信息，如基础的userId,userName，权限相关的角色信息，授权节点信息。以下是一个示例的payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;userId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;userName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Test&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;role&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1,2,3&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1,2&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>JWT 用户认证流程如下：</p><ol><li><p>获取Token</p><img src="user-get-token.png" alt="Image" style="zoom: 67%;" /></li><li><p>接口访问</p><img src="user-use-token.png" alt="Image" style="zoom:67%;" /></li><li><p>Token失效</p><img src="user-expire-token.png" alt="Image" style="zoom:67%;" /></li></ol><h3 id="模块认证"><a href="#模块认证" class="headerlink" title="模块认证"></a>模块认证</h3><p>模块认证的目的在于确保内部接口只有内部可以访问，所以对于所有需要访问的模块可以共同约定一个内部Token作为JWT的payload。<br>相对于用户认证的流程，模块认证只需要关注接口访问部分。</p><h3 id="服务认证"><a href="#服务认证" class="headerlink" title="服务认证"></a>服务认证</h3><p>服务认证目前考虑节点和主站之间互联的认证问题，和用户认证的Token相比差异主要在payload部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;nodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>而在流程上的差异在于服务注册部分，服务的token通过数据库保存不设置失效时间，除非重新注册。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><p>技术实现上主要包含了Redis存储的格式，结合shiro的验证以及ThreadLocal保存用户信息的三个部分。</p><h3 id="Redis数据格式"><a href="#Redis数据格式" class="headerlink" title="Redis数据格式"></a>Redis数据格式</h3><p>JWT在Redis中使用Hash存储，key为固定字符“JWT”，field为userId, field_value为生成的JWT。示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">JWT=<span class="hljs-punctuation">&#123;</span><span class="hljs-number">1</span>=xxxxxxx<span class="hljs-punctuation">,</span><span class="hljs-number">2</span>=yyyyyyyyyy<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>考虑认证的流程，客户端传入JWT，通过HVALS获取到所有的JWT，即可判断传入的JWT是否合法。</p><p>在重新登录或者修改用户信息的场景中，只需要将对应userId的value删除或者替换即可。</p><h3 id="结合shiro的验证"><a href="#结合shiro的验证" class="headerlink" title="结合shiro的验证"></a>结合shiro的验证</h3><p>在shiro中通过设置不同的Realm来应对不同业务场景的认证：</p><ul><li><p>UserJWTRealm </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">doGetAuthenticationInfo：<br>  首先判断当前token是否过期<br>  判断当前token是否包含在redis token列表中<br>  返回认证结果  <br><br><span class="hljs-attr">supports</span>:<br>  当前token类型是<span class="hljs-title class_">JWTToken</span>，并且header中获取的bizType=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>InnerJWTRealm</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">doGetAuthenticationInfo：<br>  首先判断当前token是否过期<br>  判断当前token是否和预置的<span class="hljs-title class_">InnerToken</span>一致<br>  返回认证结果  <br><br><span class="hljs-attr">supports</span>:<br>  当前token类型是<span class="hljs-title class_">JWTToken</span>，并且header中获取的bizType=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>SystemJWRealm</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">doGetAuthenticationInfo：<br>  首先判断当前token是否过期<br>  判断当前token在<span class="hljs-title class_">MySQL</span>中获取的node是否有效<br>  返回认证结果  <br><br><span class="hljs-attr">supports</span>:<br>  当前token类型是<span class="hljs-title class_">JWTToken</span>，并且header中获取的bizType=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal主要用于存储JWT中携带的认证信息，避免了重复解析以及可能的接口调用造成的资源浪费。</p><p>ThreadLocal主要存储线程变量，即同一个线程中可以共享的信息。以用户认证为例，完成认证后将用户信息存储到线程变量中，可以在后续的接口调用中进行信息共享。</p><p>首先在JWTService中定义全局变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;JWTUser&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(Thread.currentThread()+<span class="hljs-string">&quot;====&quot;</span>+threadLocal.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在验证完成的方法中将解析出的JWTUser 对象存入threadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JWTService.threadLocal.set(user.mock());<br></code></pre></td></tr></table></figure><p>在使用的时候就可以直接调用获取到JWTUser对象了，详见JWTService的test方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们针对于目前系统中使用的需求，梳理了JWT结合Shiro用于系统认证的三个场景。从流程上分为获取token，使用token和token失效三个主要节点，每个场景针对不同流程节点又有各自的需求。</p><p>对于场景和流程节点的需求排列，最终从技术上回归到了三个主要的技术点，Redis、Shiro和ThreadLocal。通过Redis合理的数据结构存储、Shiro Filter机制的分级认证和ThreadLocal的线程变量简化，共同串联起当前的认证流程。</p><p>对于JWT来说，Token的过期机制会直接影响到系统的安全性。鉴于目前服务都是在系统闭环内完成，暂时不考虑对于过期机制进行过多设计，仅考虑由于重新申请令牌的过期处理。后续如果接入了第三方系统，或者作为一个开放平台来说需要加强这方面的考虑。</p>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构设计</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式实战之访问者模式</title>
    <link href="/2022/01/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>访问者模式主要解决了数据结构和数据行为的分离，通过访问者模式可以在保持数据结构相对稳定的情况下，对数据行为进行单独扩展。所以访问者模式可以理解为重构模式。</p><p>访问者模式主要有四个角色：</p><ol><li>Visitor接口，通过抽象的访问者接口定义了访问的行为</li><li>ConcreteVisitor实现类对访问行为进行具体的逻辑实现</li><li>Element接口定义了被访问者的基本操作</li><li>Element实现类定义了具体的被访问对象实现</li></ol><span id="more"></span><img src="class-diagram.png" alt="Image" /><p>访问者模式适用于数据结构相对固定而行为可变的场景，结合类图也就是说Element以及其实现类相对固定，而需要改变的是访问这些Element之后的行为。访问者模式的可扩展性体现在visitor的可扩展。</p><p>访问者模式最重要的优点我认为是实现了单一职责原则，每一个visitor实现类实现了一个功能，职责划分非常清晰。</p><p>访问者模式的缺点：</p><ul><li>Element被访问类不可扩展</li><li>Visitor直接依赖具体的被访问对象，不符合依赖倒置原则</li><li>Visitor直接访问被依赖对象内部的方法，不符合迪米特法则</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在模型计算的触发中我们定义了三种计算任务，分别是特征计算任务、累积损伤计算任务和异常诊断计算任务。任务类型是相对固定的，而计算任务所对应的行为是有扩展需求的，这恰恰符合了访问者模式定义的使用场景。</p><blockquote><p>通过访问者模式可以在保持数据结构相对稳定的情况下，对数据行为进行单独扩展</p></blockquote><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>在进行详细的类图设计之前，我们进行角色匹配</p><ul><li>Element角色定义了被访问者的通用属性，对应计算认为的抽象类Task</li><li>Element1等具体被访问者就对应了我们场景中的计算任务：FeatureTask、ModelTask等</li><li>Visitor角色定义了访问者的行为</li><li>ConcreteVisitor角色定义了具体的访问行为，如计算行为可以对应一个具体的CalculateVisitor</li></ul><p>结合访问者模式得到类图如下：</p><img src="new-class-diagram.png" alt="Image" /><p>CalculateVisitor实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculateVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(FeatureTask featureTask)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始执行特征计算任务，任务名：&quot;</span>+featureTask.getName());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ModelTask modelTask)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始执行模型计算任务，任务名：&quot;</span>+modelTask.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于CalculateVisitor来说引起变化的原因只有计算逻辑的变化，因此是符合单一职责原则的。计算任务类型固定，不存在任务的扩展需求，所以从扩展角度来看访问者模式是可以满足要求的。</p><p>我们再看一下上面访问者的类图，发现迪米特法则也好依赖倒置原则也罢，问题的根源在于Visitor直接依赖了实现类，那直接依赖接口会怎么样呢？</p><img src="future-class-diagram.png" alt="Image" /><p>依赖倒置的问题解决，Task接口和Visitor接口可以分别扩展，开闭的问题也解决了。CalculateVisitor中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculateVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Task</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(T task)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始执行特征计算任务，任务名：&quot;</span>+task.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Task&gt; taskList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>    taskList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FeatureTask</span>(<span class="hljs-string">&quot;F_&quot;</span>+i));<br>    taskList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelTask</span>(<span class="hljs-string">&quot;M_&quot;</span>+i));<br>&#125;<br>Collections.shuffle(taskList);<br><span class="hljs-comment">//数据准备完成</span><br><span class="hljs-type">Visitor</span> <span class="hljs-variable">calculateVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CalculateVisitor</span>();<br><span class="hljs-keyword">for</span>(Task t: taskList)&#123;<br>    t.accept(calculateVisitor);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>在上面的例子中我们首先引入经典的访问者模式，将数据结构和行为分离后发现违背依赖倒置原则引发的扩展性问题其实可以通过泛型来解决。经过改造之后，设计更加灵活，可扩展性更好。</p><p>但是我们要谨记每一个设计模式都有其适用的场景，设计模式没有银弹。</p><p>对比以上两种访问者模式实现可以发现，第二种设计扩展性更好的同时带来了架构的复杂性，对于被访问者的要求更高了，也就是说他们必须是同类，只有这样才能将公共行为抽取到接口来满足依赖倒置原则；反观第一种设计，由于访问者直接访问实现类，所以被访问者实现类之间只存在accept这一个共性约束，被访问者之间是同事类的关系即可。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式实战之装饰模式</title>
    <link href="/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>装饰模式是指在不改变原类文件并且不使用继承结构的情况下，动态的扩展一个对象的功能。具体实现上是通过创建一个包装对象即一个装饰来包装真实对象，所以装饰模式又称为包装模式。</p><p>在装饰模式中主要有以下四个角色：</p><ol><li>Component，原始的抽象对象</li><li>ConcreteComponent，具体的对象实现</li><li>Decorator，抽象的装饰，主要定义了装饰者的行为以及与原始抽象对象之间的关系</li><li>ConcreteDecorator，具体的装饰类</li></ol><span id="more"></span><img src="class-diagram.png" alt="Image" /><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在模型计算的设计中我们采用了模板方法定义了模型运算的基本框架，</p><img src="flow-diagram.png" alt="Image" /><p>在Persist方法中我们主要实现计算结果保存到数据库，但是实际项目中会有更多针对模型结果的需求：</p><ul><li>发送统计到Redis</li><li>发送到第三方平台进行展示</li><li>回写网关进行反向控制</li></ul><p>目前的做法是在抽象类中实现相应的公用方法，然后到具体的实现类决定是否调用这些方法。</p><img src="biz-class-diagram.png" alt="Image" /><p>如上图所示，在长链条的实现类里面调用了发送统计和反向控制两个方法，而驱动单元的实现类只调用了发送统计的方法。这样实现的问题是对于策略本身的侵入式实现导致策略实现无法灵活的增加和删除这些额外的增强功能，无法满足开闭原则。</p><p>这时候我们可以换一种视角来看待这些增强，将发送统计、发送第三方和发送边缘视为策略的装饰，那么使用装饰模式来实现这些增强就显得恰到好处了。</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>使用装饰模式之前我们首先进行角色确认</p><ol><li>Component，原始的抽象对象，对应我们实例中的AbstractFanalysisStrategy</li><li>ConcreteComponent，具体的对象实现，在我们的实例中包含了长链条的策略实现和驱动单元的策略实现</li><li>Decorator，抽象的装饰器，需要新定义的接口FanalysisDecorator</li><li>ConcreteDecorator，具体的装饰器实现，包含了RedisDecorator，ThirdPartyDecorator和EdgeDecorator</li></ol><p>类图如下：</p><img src="future-diagram.png" alt="Image" /><p>通过FanalysisDecorator实现了抽象类的persist方法，同时定义作为增强类的统一行为run方法，FanalysisDecorator类的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanalysisDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFanalysisStrategy</span>&#123;<br>    <span class="hljs-keyword">private</span> AbstractFanalysisStrategy strategy;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">FanalysisDecorator</span><span class="hljs-params">(AbstractFanalysisStrategy _strategy)</span>&#123;<br>        <span class="hljs-built_in">this</span>.strategy = _strategy;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">persist</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.strategy.persist();<br>        <span class="hljs-comment">//进行增强</span><br>        <span class="hljs-built_in">this</span>.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在每个装饰实现类的run方法中实现具体的增强逻辑，对应之前抽象类中的公共方法。这样在调用的地方就可以由客户端等高层模块决定如何去增强而无需侵入原实现类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取初始策略</span><br><span class="hljs-type">AbstractFanalysisStrategy</span> <span class="hljs-variable">chainStrategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainStrategy</span>();<br><span class="hljs-comment">//进行包装</span><br><span class="hljs-type">AbstractFanalysisStrategy</span> <span class="hljs-variable">decorated</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootCloudDecorator</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisDecorator</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">EdgeDecorator</span>(chainStrategy)<br>    ))<br>;<br>decorated.persist();<br></code></pre></td></tr></table></figure><p>通过上面的装饰模式实现可以很好的实现功能的动态增强而无需修改原策略类。</p><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>在这个例子中我们结合了模板方法和装饰模式对模型计算功能进行动态增强。</p><p>我们在原始的实现中只是使用了模板方法，通过抽象类实现了功能的可复用，这种方式我们称之为静态增强。这时候如果需要新增新的增强方式，需要涉及抽象类的修改和模型实现类的修改，无法满足开闭原则，扩展性不好。</p><p>如果引入装饰模式，使用包装类的方式对原始功能进行增强，理论上可以增加任意多的增强。装饰类的新增只需要高层模块的修改，不涉及已有功能的改动，符合了开闭原则。</p><p>实际应用中可以结合模板方法，动静结合的对类进行增强。同时需要注意包装类的数量不宜过多，太多的增强可能引发代码复杂度的急剧增加带来维护的难度。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InfluxDB数据接入MQTT</title>
    <link href="/2021/12/22/InfluxDB%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%85%A5MQTT/"/>
    <url>/2021/12/22/InfluxDB%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%85%A5MQTT/</url>
    
    <content type="html"><![CDATA[<p>在边缘计算场景中数据存储在边缘的时序数据库如 InfluxDB 中，如果不能将数据进行归集以统筹管理则可能形成数据孤岛，无法充分有效的发挥大数据的威力。</p><p>边缘端的数据流是数采网关直连InfluxDB，通过restful的方式将采集到的数据发送到时序数据库。这种方式的优点是架构简单，没有中间环节数据传输效率高、实时性有保障。缺点则是可扩展性低，无法满足数据处理、数据转发等需求。</p><p>在某大型客户的案例中我们面临的挑战是边缘时序数据需要接入对方的工业互联网平台，鉴于平台支持MQTT方式接入，我们的问题就转化为：<em>边缘时序数据发送到MQTT队列</em></p><span id="more"></span><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>在分析了我们现在连接方式后我们总结出三种方案来应对挑战。</p><img src="solution.png"/><ol><li>方案一，网关直接连接MQTT</li><li>方案二，定时任务去InfluxDB拉取后发送到MQTT</li><li>方案三，模拟一个InfluxDB的订阅者，作为中间层</li></ol><p>综合来看方案一实现方式比较简单，直接由网关发起双写。缺点是对网关性能要求比较高，同样也面临后期扩展性的问题。</p><p>方案二和方案三都是通过增加一个中间层来解决问题，通过中间层可以实现数据预处理、数据分发等功能保留了扩展性。不同点在于方案二采用主动拉取的方式，方案三采用了订阅者模式由InfluxDB推送数据更新到订阅者。相比较而言方案三的实时性更好，性能损耗也相对更小。</p><p>最终我们选择方案三作为InfluxDB到MQTT的连接方案。</p><img src="solution2.png"/><h2 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h2><p>我们从三个方面来依次阐述方案实现：</p><h3 id="InfluxDB-设置"><a href="#InfluxDB-设置" class="headerlink" title="InfluxDB 设置"></a>InfluxDB 设置</h3><p>在InfluxDB设置中，订阅是默认开启的。如果已经关闭注意打开即可，配置项段落如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">subscriber</span>]<br><span class="hljs-comment"># determine whether the subscriber service is enabled</span><br><span class="hljs-string">enable</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>在完成了配置后需要重启服务生效。然后通过执行语句创建subscription，完成订阅。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SUBSCRIPTION &quot;mysub&quot; <span class="hljs-keyword">ON</span> &quot;test&quot;.&quot;autogen&quot; DESTINATIONS <span class="hljs-keyword">ALL</span> <span class="hljs-string">&#x27;http://192.168.8.181:9090&#x27;</span><br></code></pre></td></tr></table></figure><p>其中 mysub 是订阅的名称，test 和 autogen 分别是数据库和保留策略的名称，<a href="http://192.168.8.181:9090/">http://192.168.8.181:9090</a> 是订阅者地址，InfluxDB会将fork的请求发送到这个地址。</p><h3 id="订阅者实现"><a href="#订阅者实现" class="headerlink" title="订阅者实现"></a>订阅者实现</h3><p>订阅者实现是整个方案的核心，我们通过类图来说明。</p><img src="class-diagram.png" /><p>Router是订阅者对外暴露的端点，通过receive方法接收请求后将请求流转到Transformer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/write&quot;)</span><br><span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title function_">receive</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String data)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">mqttdata</span> <span class="hljs-operator">=</span> transformer.transform(data);<br>    gateway.sendToMqtt(mqttdata);<br>    <span class="hljs-keyword">return</span> Mono.empty();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Transformer将数据从InfluxDB的line protocol转换为平台接收的MQTT数据格式，通过MQTT客户端发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">transform</span><span class="hljs-params">(String lineData)</span> &#123;<br><span class="hljs-type">RootCloudThing</span> <span class="hljs-variable">thing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootCloudThing</span>();<br><br>String[] lines = lineData.split(<span class="hljs-string">&quot;\n&quot;</span>);<br>List&lt;RootCloudItem&gt; items = Arrays.stream(lines)<br>.filter(line-&gt; itemConfigure.isValidLine(line))<br>.map(RootCloudItem::buildFromLine).collect(Collectors.toList());<br>thing.setItems(items);<br><br>Map&lt;String,List&lt;RootCloudThing&gt;&gt; innerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>innerMap.put(<span class="hljs-string">&quot;things&quot;</span>, Arrays.asList(thing));<br>Map&lt;String,Object&gt; outerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>outerMap.put(<span class="hljs-string">&quot;body&quot;</span>, innerMap);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>().toJson(outerMap);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>transform方法主要实现了line数据的过滤和向RootCloudThing对象的转换，最后以Json格式返回给Router用以发送到MQTT broker。</p><h3 id="发送MQTT"><a href="#发送MQTT" class="headerlink" title="发送MQTT"></a>发送MQTT</h3><p>我们基于eclipse paho作为MQTT的客户端实现，pom文件引入如下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.integration<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-integration-mqtt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过配置文件注入配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># mqtt configure</span><br><span class="hljs-string">mqtt.broker.uri=tcp://mqtt-broker-pre.rootcloudapp.com:1883</span><br><span class="hljs-string">mqtt.broker.username=xxxxxxxx</span><br><span class="hljs-string">mqtt.broker.passcode=xxxxxxxx</span><br><span class="hljs-string">mqtt.broker.topic=v4/p/post/thing/live/json/1.1</span><br></code></pre></td></tr></table></figure><p>通过ProducerConfigure类实现配置读取并初始化客户端bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;mqtt.broker&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConfigure</span> &#123;<br><br><span class="hljs-keyword">private</span> String uri;<br><span class="hljs-keyword">private</span> String username;<br><span class="hljs-keyword">private</span> String passcode;<br><span class="hljs-keyword">private</span> String topic;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MqttPahoClientFactory <span class="hljs-title function_">mqttClientFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">DefaultMqttPahoClientFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMqttPahoClientFactory</span>();<br><span class="hljs-type">MqttConnectOptions</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MqttConnectOptions</span>();<br>options.setServerURIs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; uri &#125;);<br>options.setUserName(username);<br>options.setPassword(passcode.toCharArray());<br>options.setCleanSession(<span class="hljs-literal">true</span>);<br>factory.setConnectionOptions(options);<br><span class="hljs-keyword">return</span> factory;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageChannel <span class="hljs-title function_">mqttOutboundChannel</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectChannel</span>();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ServiceActivator(inputChannel = &quot;mqttOutboundChannel&quot;)</span><br><span class="hljs-keyword">public</span> MessageHandler <span class="hljs-title function_">mqttOutbound</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">MqttPahoMessageHandler</span> <span class="hljs-variable">messageHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MqttPahoMessageHandler</span>(username, mqttClientFactory());<br>messageHandler.setAsync(<span class="hljs-literal">true</span>);<br>messageHandler.setDefaultTopic(topic);<br><span class="hljs-keyword">return</span> messageHandler;<br>&#125;<br><br><span class="hljs-meta">@MessagingGateway(defaultRequestChannel = &quot;mqttOutboundChannel&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyGateway</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sendToMqtt</span><span class="hljs-params">(String data)</span>;<br>&#125;<br><span class="hljs-comment">//getter setter ....</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>通过方案实现章节的三个步骤我们已经基本实现了一个用于订阅InfluxDB的中间层，反观实现原理和Canal（ <a href="https://github.com/alibaba/canal/">https://github.com/alibaba/canal/</a> ） 有点类似。</p><p>通过中间层的引入，在网关直连到InfluxDB的已有方式不需要任何改动的前提下，我们实现了数据的预处理和分发。基于中间层我们可以将时序数据发送到任意目的地，满足数据归集、数据备份、数据展示和数据分析等多种需求。</p><p>附源代码地址（版本更新后可能和原文实现有差异）：<a href="https://gitee.com/luischen/databridge">https://gitee.com/luischen/databridge</a></p>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>InfluxDB</tag>
      
      <tag>数据技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式实战之状态模式</title>
    <link href="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>系统启动阶段需要完成一些准备工作，最初是通过Spring Application Runner来实现，实现思路用业务语言描述就是：</p><ol><li>首先进行启动参数准备</li><li>判断是否需要注册主站，如果需要则注册</li><li>判断是否需要进行数据同步，如果需要则同步数据</li><li>等待数据同步完成，系统准备完成</li></ol><p>这种设计可以从某种程度上理解为责任链模式，四个Runner组成了一个责任链，流转到对应的节点判断是否属于该节点的责任并采取动作。</p><h2 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h2><p>这样的启动流程设计和Spring容器耦合严重导致了可复用性不是很好，并且面向流程的设计不具备可扩展性。如果我们在RegisterRunner中由于网络原因没有注册成功，我们期望的结果是重新注册而不是重启Spring应用。</p><p>我们发现在Runner对应的过程中体现的是状态的转移，例如RegisterRunner对应的是正在注册到注册成功或者注册失败状态的转移。而状态的转移又反映在类行为的变化。这正是状态模式适用的场景。</p><blockquote><p>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p></blockquote><span id="more"></span><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>首先结合业务逻辑定义了如下几个状态：</p><table><thead><tr><th>状态名</th><th>状态描述</th></tr></thead><tbody><tr><td>STARTING</td><td>正在启动</td></tr><tr><td>REGISTERING</td><td>正在注册主站</td></tr><tr><td>DATA_SYNC</td><td>正在进行数据同步</td></tr><tr><td>STARTUP_FAIL</td><td>启动失败</td></tr><tr><td>STARTUP_SUCCESS</td><td>启动成功</td></tr><tr><td>UNKNOWN</td><td>未知状态</td></tr></tbody></table><p>基于状态模式可以得到系统类图设计：</p><img src="state-class-diagram.png" /><p>在 ProjectStartupContext 中定义的dispatch方法负责逻辑处理和状态转移，通过isTerminalState方法来判断是否终结状态并结束流转。结合定义的启动模式和类图设计得到的状态转移流程图如下：</p><img src="state-flow-diagram.png" /><p>从状态角度考虑每个状态都需要包含自身的职责和状态的流转逻辑，STARTING状态的职责是进行启动参数初始化，如果初始化失败则直接流转到启动失败状态；如果初始化成功并且是网络模式，则进入主站注册状态，如果是单机模式则直接启动成功。</p><p>REGISTERING状态的职责是进行主站注册，如果注册成功则进入数据同步状态，注册失败经过重连处理后进入启动失败状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">AbsStartupState</span> <span class="hljs-variable">dataSyncState</span> <span class="hljs-operator">=</span> ProjectStartupStateFactory.<br>                    getStartupState(ProjectStartupParamUtil.StartupStatusEnum.DATA_SYNC.getName());<br>    <span class="hljs-type">AbsStartupState</span> <span class="hljs-variable">failState</span> <span class="hljs-operator">=</span> ProjectStartupStateFactory.<br>                    getStartupState(ProjectStartupParamUtil.StartupStatusEnum.STARTUP_FAIL.getName());<br>    <span class="hljs-keyword">while</span>(!doRegisterToMaster(node))&#123;<br>        tryTimes++;<br>        <span class="hljs-keyword">if</span>(tryTimes &lt; REGISTER_RETRY_TIMES)&#123;<br>            <span class="hljs-built_in">super</span>.startupContext.setState(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(RETRY_DURATION);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">/*do nothing */</span>&#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">super</span>.startupContext.setState(failState);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">super</span>.startupContext.setState(dataSyncState);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminalState</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>DATA_SYNC状态的职责是进行数据同步和同步状态跟踪，如果同步成功则启动成功，否则启动失败。</p><p>STARTUP_FAIL和STARTUP_SUCCESS这两个属于终结状态不需要进行任何逻辑处理和状态转移操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">StartFailState</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">super</span>(ProjectStartupParamUtil.StartupStatusEnum.STARTUP_FAIL);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">()</span>  &#123;<br>LOG.error(<span class="hljs-string">&quot;entered dead code segment.&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminalState</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在具体的调用中，我们通过一个service( ProjectStartupService.start )来提供状态模式的入口，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">LOG.info(<span class="hljs-string">&quot;Project Startup Service begin.&quot;</span>);<br><span class="hljs-type">ProjectStartupContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProjectStartupContext</span>();<br><span class="hljs-type">AbsStartupState</span> <span class="hljs-variable">startingState</span> <span class="hljs-operator">=</span> ProjectStartupStateFactory.getStartupState(<br>ProjectStartupParamUtil.StartupStatusEnum.STARTING.getName()<br>);<br><span class="hljs-type">AbsStartupState</span> <span class="hljs-variable">successState</span> <span class="hljs-operator">=</span> ProjectStartupStateFactory.getStartupState(<br>ProjectStartupParamUtil.StartupStatusEnum.STARTUP_SUCCESS.getName()<br>);<br><span class="hljs-keyword">if</span>(ProjectStartupParamUtil.isNetMode())&#123;<br>context.setState(startingState,<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>context.setState(successState,<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">while</span>(!context.isTerminal())&#123;<br>context.dispatch();<br>&#125;<br>LOG.info(<span class="hljs-string">&quot;Project Startup Service end.&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>通过封装使得系统启动准备做到了可复用，首次启动的场景中直接在Application Runner中读取参数，调用start方法；通过状态监测页面观测到系统状态为失败的时候，可以通过页面触发重启。反映到后台逻辑就是重置启动参数，执行start方法。</p><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>在上面的例子中，我们利用状态模式对系统启动流程进行了优化重构。</p><p>从可扩展性方面看，如果需要增加一个启动动作，如NTP对时，那我们可以通过新增一个状态 [NTP对时]，上游状态是 [注册节点] ，下游状态是 [数据同步]。涉及到的改动是注册节点的成功状态设置由 [数据同步] 改成 [NTP对时] 。</p><p>乍看之下不符合开闭原则呀，确实状态模式封装了状态的行为和状态转移在应对新的状态加入时会涉及到原有状态类的修改。我们可以将状态路由单独提取出来，这样符合了封装不变开放变化的设计准则，但同时也会增加复杂度。换一个角度看，状态模式的应用场景大多数是状态类的数量相对固定并且转换规则已经基本确定的场景，通过状态模式实现封装来提高代码的可读性和设计的可复用。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式实战之策略枚举</title>
    <link href="/2021/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E7%AD%96%E7%95%A5%E6%9E%9A%E4%B8%BE/"/>
    <url>/2021/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E7%AD%96%E7%95%A5%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<p>在开发中经常会遇到一些语句拼接的问题，如用于数据库查询的where条件或者用于逻辑判断的表达式。我们在应对这类问题的时候，直觉是使用if-else或者switch条件判断，下面是一个常见的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">buildStatement</span><span class="hljs-params">(<span class="hljs-type">int</span> type, String[] value)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>) statement =<span class="hljs-string">&quot;value &gt;= %s and value &lt;= %s&quot;</span>;<span class="hljs-comment">//介于</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">2</span>) statement = <span class="hljs-string">&quot;value &lt; %s or value &gt; %s&quot;</span>;<span class="hljs-comment">//不介于</span><br>    ……<br>    <span class="hljs-keyword">return</span> String.format(statement, value[<span class="hljs-number">0</span>], value[<span class="hljs-number">1</span>]);<br>&#125;<br><br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h2><p>这段拼接字符串的代码功能上没什么问题，但是过多的if-else使得代码的阅读和维护都显得不是那么友好。在上面的例子中，我们还隐藏了一个关于type的枚举。考虑扩展性如果需要新增一个类型，我们需要做：</p><ul><li>Type枚举新增一个类型</li><li>新增一个if-else 分支</li></ul><p>在枚举里面新增一个类型相当于增加了一个单例类，符合设计原则；但是新增if-else分支则涉及到具体类逻辑的修改，不符合开闭原则。</p><p>让我们再来思考一下面临的问题：每个类型对应了一种字符串拼接的方法，要求根据高层次模块的需求可以自由切换，而不用关心拼接的细节。这正契合了策略模式的定义：</p><blockquote><p>策略模式通过定义一组算法将他们封装起来，使得算法之间可以相互替换</p></blockquote><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>基于策略模式的定义，我们可以绘制出语句拼接场景下的类图。</p><img src="class-diagram.png" alt="Image" /><p>首先定义了一个策略接口Statement，以及通用行为build。</p><p>每一个策略都定义一个实现类，如介于（Between）。在实现类的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造函数注入类型</span><br>Between()&#123;<br>  Super(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">build</span><span class="hljs-params">(String[] params)</span>&#123;<br>  <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;value &gt;=%s and value &lt;=%s&quot;</span>,value[<span class="hljs-number">0</span>],value[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>环境类Context提供了切换拼接方式的入口，高层模块调用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>String[] values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>&#125;;<br>context.setStatement(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Between</span>());<br><span class="hljs-type">String</span> <span class="hljs-variable">betweenStatement</span> <span class="hljs-operator">=</span> context.buildStatement(values);<br>Context.setStatement(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Equal</span>());<br><span class="hljs-type">String</span> <span class="hljs-variable">equlStatement</span> <span class="hljs-operator">=</span> context.buildStatement(values);<br></code></pre></td></tr></table></figure><p>通过上面的设计，如果我们新增一个拼接类型只需要新增一个新的实现类即可，不需要涉及任何现有代码的改动，符合开闭原则。</p><p>但是如此完美的设计还是逃避不了策略模式的通病：类爆炸。当拼接类型过多的时候，系统中会出现很多的实现类，而且每个类都只有几十行代码，这在无形之中也会增加系统的维护成本。针对这种情形，我们可以引入策略枚举。因为我们知道枚举的值其实就是对应一个单例的实现，我们通常使用的枚举只是定义了这个单例的属性，如下图所示。</p><img src="type-enum.png" alt="Image" /><p>策略枚举可以同时定义属性和行为，看起来更加的物尽其用。具体实现就是在枚举中除了属性定义之外通过抽象方法来定义枚举的行为，而在每一个枚举值中进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">LogicStatement</span>&#123;<br>        BETWEEN(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;介于&quot;</span>)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">build</span><span class="hljs-params">(String... values)</span> &#123;<br>                <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;and value&gt;%s and value&lt;%s&quot;</span>,values[<span class="hljs-number">0</span>],values[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;,<br>        NOT_BETWEEN(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;未介于&quot;</span>)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">build</span><span class="hljs-params">(String... values)</span> &#123;<br>                <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;and (value&gt;=%s or value&lt;=%s)&quot;</span>,values[<span class="hljs-number">1</span>],values[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;,<br>        EQUAL(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;等于&quot;</span>)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">build</span><span class="hljs-params">(String... values)</span> &#123;<br>                <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;and value=%s&quot;</span>,values[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">private</span> String name;<br>        LogicStatement(<span class="hljs-type">int</span> _value, String _name)&#123;<br>            <span class="hljs-built_in">this</span>.value = _value;<br>            <span class="hljs-built_in">this</span>.name = _name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">build</span><span class="hljs-params">(String... values)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，LogicStatement定义了枚举的属性和行为，在每一个枚举中通过构造器注入属性，通过重写来定义行为。通过策略枚举的实现在策略模式的基础上有效的归集了策略模式的实现类，方便管理和维护。</p><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>上面的例子中我们使用策略模式来实现字符串拼接的功能，主要原因是功能的封装和算法的切换符合策略模式的定义。通过策略模式的引进可以增强设计和实现的可维护性和可扩展性。对于简单策略可能带来的类爆炸问题，我们可以通过策略枚举解决。但是需要谨记使用策略枚举的前提：</p><ol><li>简单策略，即策略的实现代码较少，否则会造成枚举类过大</li><li>策略类较多，如果策略类只有五个以内或者更少还是建议使用策略类的方式来实现，毕竟策略枚举的扩展还是要修改已有枚举类代码，并不是纯粹意义的扩展</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时序数据可视化的降采样算法</title>
    <link href="/2021/09/18/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E9%99%8D%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    <url>/2021/09/18/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E9%99%8D%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>工业场景中，时序数据的可视化是一个无法回避的话题。时序数据的超大数据量给图形的展示性能带来了挑战，而通过降采样的方式减少图形的展示点数来迎合性能的同时，又会带来算法复杂度、算法可伸缩以及正确性等多方面的权衡。</p><p>下面通过几种常用的可视化降采样算法的研究和实践对比，为时序数据的可视化降采样算法选择提供参考。我们使用实际生产中的一个案例作为算法描述的基础：需求将10w点降采样到4000，以适配页面的展示效果。</p><span id="more"></span><h2 id="直觉分桶算法"><a href="#直觉分桶算法" class="headerlink" title="直觉分桶算法"></a>直觉分桶算法</h2><p>在一般情况下，面对一个复杂问题最先起作用的往往是我们的直觉。所以在面对大数据集降采样的问题时最先想到的这类算法统称之为直觉算法。</p><h3 id="Mode-Median-Bucket"><a href="#Mode-Median-Bucket" class="headerlink" title="Mode-Median-Bucket"></a>Mode-Median-Bucket</h3><p>模式中位数分桶算法，从大类来看是一个分桶算法，从取样方式来看分成了众数取样和中位数取样。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">首先确定桶的数量即threshold等于4000，那么被分配到每个桶的数据点就是25。<br>遍历每个桶：<br><span class="hljs-code">查看桶中是否存在唯一众数，如果存在则应用众数模式，选取众数的最左边点作为桶的代表点</span><br><span class="hljs-code">如果不满足众数模式，则选取桶内点的中位数作为桶的代表点</span><br><span class="hljs-code"></span><br>作为特殊考虑，如果是第一个桶则选取第一个点，最后一个桶则选取最后一个点，从而确保整个数据集的趋势完整性。<br></code></pre></td></tr></table></figure><h3 id="Min-Std-Error-Bucket"><a href="#Min-Std-Error-Bucket" class="headerlink" title="Min-Std-Error-Bucket"></a>Min-Std-Error-Bucket</h3><p>最小标准误差分桶算法，从大类来看是一个分桶算法，从取样方式来看基于线性回归采用标准误差（SEE - standard error of estimate）公式作为取样的依据。</p><img src="mseb1.png" /><img src="mseb2.png" /><img src="mseb3.png" /><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm">首先确定桶的数量即threshold等于<span class="hljs-number">4000</span>，首尾两个桶都只包含一个点确保数据集的起点和终点被选中，其他点平均分配到桶。<br><br><span class="hljs-number">1</span>， 将每个桶中的点和后一个桶的点两两连成线段，每个线段记为一条边<br><span class="hljs-number">2</span>， 对于每条边，计算所有<span class="hljs-keyword">x</span>方向穿过的点到边的距离e<br><span class="hljs-number">3</span>， 通过这些距离结合SEE公式计算边的标准误差作为边的权重<br><br>至此，我们得到了一组带权重的边构成的DAG有向无环。<br>只需要使用图的最短路径算法（如Dijkstra’s algorithm）就可以得到构成最短标准误差的那些点了。<br></code></pre></td></tr></table></figure><p>算法的主要缺陷在于选取最小标准误差的时候总是将图形变的平滑，所以局部的极值和全局的极值总是被忽略。</p><h3 id="Longest-Line-Bucket"><a href="#Longest-Line-Bucket" class="headerlink" title="Longest-Line-Bucket"></a>Longest-Line-Bucket</h3><p>最长线段分桶算法，相对于MSEB算法保留了局部极值和全局极值，算法过程类似。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1， 将每个桶的点和下一个桶的点两两连线段，每个线段记为一条边<br>2， 计算每个边的长度，记为边的权重<br><br>至此，我们得到了一组带权重的边构成的DAG，需要计算图的最大路径。<br>由于路径的权重都是正值，所以可以简单的取反转换为计算图的最短路径问题。<br></code></pre></td></tr></table></figure><h2 id="制图泛化技术"><a href="#制图泛化技术" class="headerlink" title="制图泛化技术"></a>制图泛化技术</h2><p>上面描述的三个直觉算法一定程度上都能够解决问题，然而又或多或少引入了新的问题。比如MMB可能带来短视的问题，MSEB和LLB引入了额外的复杂度和效率问题。我们参考了几个制图泛化的技术，对直觉分桶算法进行改进。</p><h3 id="Douglas-Peucker-algorithm"><a href="#Douglas-Peucker-algorithm" class="headerlink" title="Douglas-Peucker algorithm"></a>Douglas-Peucker algorithm</h3><p>多边形逼近算法，通过递归来逐步逼近原图形效果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">首先定义一个threshold（注意这个threshold和桶没有关系）表示点到线段的最大距离。<br><br><span class="hljs-number">1</span>，连接首尾点构成初始线段AB<br><span class="hljs-number">2</span>，计算AB中间的所有点到AB的垂直距离，获取垂直距离最大的点C和垂直距离e<br><span class="hljs-number">3</span>，如果e &lt;<span class="hljs-operator">=</span> threshold，则AB符合原图趋势，选择AB代表图形，AB中所有点都可以排除<br><span class="hljs-number">4</span>，如果e &gt; threshold，则AB不符合趋势，分别连接AC，CB，继续步骤<span class="hljs-number">2</span><br><span class="hljs-number">5</span>，如果AB中间已经没有其他点了，则递归结束<br></code></pre></td></tr></table></figure><h3 id="Visvalingam–Whyatt-algorithm"><a href="#Visvalingam–Whyatt-algorithm" class="headerlink" title="Visvalingam–Whyatt algorithm"></a>Visvalingam–Whyatt algorithm</h3><p>算法的主要思想是基于点的重要性或者意义来寻找能够代表图形的特征点，而点的重要性是通过有效区域即点构成三角形的面积来判定。</p><p>遍历数据集中的每一个点，将该点和邻近的两个点来构成三角形，三角形的区域即为点的有效区域。当有效区域较小时，认定该点对于图形的重要性较低。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>，首先计算每个点的有效区域，找出有效区域最小的点，剔除；<br><span class="hljs-attribute">2</span>，重新计算邻接点的有效区域，继续找出有效区域最小的点，剔除；<br><span class="hljs-attribute">3</span>，重复步骤<span class="hljs-number">2</span>，直到剩余点的个数满足了绘图要求，算法结束<br></code></pre></td></tr></table></figure><p>上面两种绘图泛化技术的特点是比较简单并且在降低数据量方面表现的相当有效。缺点是基于全局的返回可能会损失局部的特点，比如whyatt算法在删除点方面，可能会把一段时间的数据全部删除，这就给人造成了数据缺失的错觉，相应的图形表现力也大打折扣。如下图所示，黑色图形是算法处理后的图形。</p><image src="whyatt1.png"><h2 id="Largest-Triangle-Algorithms"><a href="#Largest-Triangle-Algorithms" class="headerlink" title="Largest Triangle Algorithms"></a>Largest Triangle Algorithms</h2><p>最大三角形算法是结合了Whytt算法和直觉算法的改良版，通过三角形来形成有效区域从而对数据点的重要性进行量化，再结合直觉算法中分桶思想最大程度的保留图形的特点。</p><h3 id="Largest-Triangle-One-Bucket"><a href="#Largest-Triangle-One-Bucket" class="headerlink" title="Largest-Triangle-One-Bucket"></a>Largest-Triangle-One-Bucket</h3><p>LTOB最大三角形单桶算法，使用了Whytt算法有效区域的思路，再结合直觉算法中的分桶。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1,首先确定桶的大小，并将数据点平分到桶中，注意首尾点各占一个桶确保选中<br>2,依次计算每个点和邻接点形成的有效区域，去除无有效区域的点<br>3,在每个桶中选取有效区域最大的点代表当前桶<br></code></pre></td></tr></table></figure><p>LTOB算法相比原始的Whytt算法，确保了点分布的相对均匀。每个桶都有一个代表点来表示，从而连接成为一个全局的路由。</p><h3 id="Largest-Triangle-Three-Buckets"><a href="#Largest-Triangle-Three-Buckets" class="headerlink" title="Largest-Triangle-Three-Buckets"></a>Largest-Triangle-Three-Buckets</h3><p>LTTB最大三角形三桶算法，相比于单桶的短视问题，将有效区域的计算延伸到前后两个桶。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>，首先确定桶的大小，并将数据点平分到桶中，注意首尾点各占一个桶确保选中<br><span class="hljs-number">2</span>，选中第一个点<br><span class="hljs-number">3</span>，从第二个桶开始，遍历桶中的点，计算每个点的有效区域，并选取有效区域最大的点作为桶的代表点。<br>三角形的选取为<span class="hljs-selector-attr">[前一个桶的选中点，当前点，后一个桶的平均点]</span>。<br><span class="hljs-number">4</span>，选中最后一个点<br></code></pre></td></tr></table></figure><p>LTTB算法相比LTOB算法，一定程度上减轻了短视的问题。同时通过固定三角形的两个点的方式，提升了算法的效率。</p><h3 id="Largest-Triangle-Dynamic"><a href="#Largest-Triangle-Dynamic" class="headerlink" title="Largest-Triangle-Dynamic"></a>Largest-Triangle-Dynamic</h3><p>LTD动态最大三角形，正如名字所说的那样可以动态的决定桶中的数据点个数。在上面提到的所有分桶算法中，我们都使用了同样的分配算法，即首尾各占一个桶，其他均分。这种分配方法无疑是最简单的，并且大多数情况是有效的。</p><p>但是当我们遇到一些特殊形状的图形，如数据分布不均匀，一部分时间数据变化很平缓，部分时间变化很陡峭，如下图所示。我们的分桶方式就会显得力不从心。</p><img src="ltd1.png"><p>这时候就需要一个动态的的分桶算法，当数据平缓的时候桶中的点相对较多，当数据陡峭的时候桶中的点相对较少，以此来确保在平缓区域分配较少的桶来选取较少的点，而在陡峭区域分配较多的桶来选取较多的点。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-number">1</span><span class="hljs-punctuation">,</span>首先确定桶的大小，并将数据点平分到桶中，注意首尾点各占一个桶确保选中<br><span class="hljs-number">2</span><span class="hljs-punctuation">,</span>计算每一个桶的SSE（计算当前桶加上两个邻接点的线性回归线，SSE<span class="hljs-operator">=</span>桶内所有点到回归线的垂直距离平方之和）<br><span class="hljs-number">3</span><span class="hljs-punctuation">,</span>循环迭代直至终止条件触发（一般为有限次的迭代total<span class="hljs-operator">/</span>threshold<span class="hljs-operator">*</span><span class="hljs-number">10</span>，案例中为<span class="hljs-number">250</span>次）<br>    找出最大SSE的桶 <span class="hljs-built_in">F</span><br>    找出SSE之和最小的相邻桶 A 和 B（AB和<span class="hljs-built_in">F</span>不能相同）<br>    将<span class="hljs-built_in">F</span>均匀拆分成两个桶<br>    将AB合并为一个桶<br><span class="hljs-number">4</span><span class="hljs-punctuation">,</span>确定了桶之后即可以采用LTTB算法进行降采样<br></code></pre></td></tr></table></figure><p>LTD算法相比LTTB算法在不规则图形上有更好的表现力，但是在规则图形上可能还不如LTTB。LTD的效率显然远不如LTTB，同时循环迭代的终止条件并没有比较好的参考数据需要不断尝试，这在某种程度上增加了算法的复杂性。</p><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>在完成了以上六个算法的研究学习之后，我们可以对各个算法的优劣进行定性的比较，为我们之后的工作提供指导和帮助。</p><p>参照的指标有以下几个：</p><ul><li>速度（Speed），算法的运行速度无疑是很重要的因素，一般我们页面的的响应需要控制在3s以内，算法的速度也应该参考这个基准</li><li>可伸缩（Scalability），当数据量持续增长的时候，算法的表现不应发生明显变化</li><li>复杂性（Complexity），算法的复杂度在于理解和实现的难度，一个量化的直接就是LOC即实现的代码行</li><li>适配能力（Portability），算法在各个环境和语言中支持的程度</li><li>正确性（Correctness），算法的运行结果对于原图形的表现力</li></ul><img src="conclusion.png"/><p>从上图可以看出LTTB算法在绝大多数情况下都是表现优异的，当然基于场景的差异可能其他算法会有更好的正确性。所以我们的决策顺序可以是优先LTTB，当LTTB不满足呈现的需求时，我们可以尝试其他算法以获取更好的结果。</p><p>最后我们基于我们实际的两组数据进行了测试，一组为单调递增的累积损伤数据，一组为波动的异常诊断数据。</p><img src="result.png" />]]></content>
    
    
    <categories>
      
      <category>工业算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据技术</tag>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InfluxDB备份策略</title>
    <link href="/2021/08/19/InfluxDB%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/"/>
    <url>/2021/08/19/InfluxDB%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>设备数据采集的时序数据使用InfluxDB进行存储，InfluxDB提供了两大类备份策略来保障数据安全：</p><ul><li><p>数据库实时主备</p><p>实时主备是指通过内置的subscription机制，将主库收到的请求通过go-routine的方式到从库进行重放来实现数据的主备存储。这种方式可以认为是热备。</p></li><li><p>数据定期备份</p><p>定期备份是指通过客户端工具提供的backup命令将数据备份到其他地方进行保存，需要恢复的时候通过restore命令加载数据备份。这种方式根据数据备份的频率存在丢失数据的风险。</p></li></ul><span id="more"></span><h2 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h2><h3 id="实时备份"><a href="#实时备份" class="headerlink" title="实时备份"></a>实时备份</h3><p>通过subscription的方式实现主备的架构如下图：</p><img src="arch.png" /><p>首先在InfluxDB的主服务器上通过命令建立订阅，包含如下信息：</p><ol><li>订阅名称 mysub</li><li>订阅的数据库和保留策略 mydb.autogen</li><li>数据目的策略，可选ALL（全部发送）和ANY（Round Robin发送任一）</li><li>数据目的地，以逗号分隔的目标主机信息</li></ol><p>创建完成后在主服务器上会生成一个类似路由表的数据结构，数采客户端发送数据（1）到主服务器后，主服务器根据路由策略生成一个或者多个writer（2）将数据同步发送到备库。</p><h3 id="全量备份"><a href="#全量备份" class="headerlink" title="全量备份"></a>全量备份</h3><p>全量备份通过influxd命令行工具，主要语法如下：</p><img src="command.png" /><p>基于全量备份的备份恢复策略可以用如下的流程图来表示：</p><img src="flow.png" /><p>每天通过系统定时任务的方式触发 bk_influx.sh 的shell脚本进行数据备份，备份完成后传输到归档位置，可以是挂载的usb设备也可以是用户定义的网络位置。最后备份进行滚动替换，删除过期的备份数据。当数据库损坏或者需要搭建影子环境的时候只需要直接使用restore命令进行恢复即可。</p><h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><p>增量备份的是在上述全量备份的时候通过指定start和end进行区间过滤，但是start和end的实现上存在缺陷使得我们即使进行了过滤，一样会占用很多的系统资源进行大量的无用数据文件读操作。恢复的时候需要额外写工具进行数据导入。备份恢复的流程如下：</p><img src="flow2.png" /><p>从流程图上看增量备份的备份过程和全量备份基本一致，主要差异有：</p><ol><li>bk_influx.sh的逻辑差异，备份时需要指定开始结束时间</li><li>由于是增量备份，每一个备份都是相对独立的不需要备份替换过程</li><li>数据恢复过程需要一个临时库存储增量数据，然后使用工具通过java 客户端从临时库读取数据并写入到主库</li></ol><h3 id="离线备份"><a href="#离线备份" class="headerlink" title="离线备份"></a>离线备份</h3><p>离线备份是InfluxDB早期版本提供的功能，准确的说应该是在线备份离线恢复，对应于MySQL的物理备份。</p><p>在InfluxDB的数据目录结构可以看出数据是分成meta、data和wal三个维度存储的。Meta存储的是元数据例如数据库结构，用户信息等；data目录中以tsm的文件格式存储时序数据；wal目录存储的是预写入日志。离线备份模式下会获取meta和data目录下对应的文件，wal目录下的文件因为没有同步到数据文件不做处理。</p><p>离线备份的语法如下，</p><img src="command2.png" /><p>离线备份恢复流程如下：</p><img src="flow3.png" /><ol><li>定时任务运行增量备份，备份当前时间对应的shard ID</li><li>传输备份数据到指定位置，usb或者网络位置</li><li>进行备份恢复之前需要关闭目标服务</li><li>运行客户端命令进行离线恢复</li><li>启动目标服务检查数据正确性</li></ol><p>从以上流程可以看出主要的难点有两点:</p><ul><li><p>如何确定备份的频率</p><p>我们通过show retention policies可以确定shard定义的范围。如果一个shard范围是一周，我们可以定义备份的频率为一周，当然小于一周也是可以的，只不过操作的是同一个数据文件在备份的时候进行滚动替换。</p></li><li><p>如何确定最新的shard ID</p><p>通过show shards命令可以确定shard的分布。然后进入到data 目录下找到当前retention policy目录下最大的shard目录即为最新的shard ID。出于完备性考虑，如果某一次备份没有进行则需要从最近一次备份的shard Id进行，所以可以新建文件来保存最近备份的shard ID，这样下次备份只需要找到大于最近备份的shard的所有shard进行备份即可。</p><p>获取shard id的逻辑如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>，获取最近一次备份的<span class="hljs-keyword">shard </span>ID，如无则返回<span class="hljs-number">0</span><br><span class="hljs-number">2</span>，遍历data目录，获取大于<span class="hljs-keyword">shard </span>ID的所有文件夹名称<br><span class="hljs-number">3</span>，循环进行增量备份<br><span class="hljs-number">4</span>，备份完成后更新最近的<span class="hljs-keyword">shard </span>ID<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>InfluxDB 提供了四种备份策略，可以通过下表进行一个简单比较。</p><table><thead><tr><th>备份策略</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>数据库主备</td><td>实时备份<br />数据安全性较高</td><td>架构复杂，系统资源消耗大</td><td>需要实现时序数据库高可用的情况</td></tr><tr><td>全量备份</td><td>兼容性好<br />恢复操作简单</td><td>海量数据的场景备份恢复占<br />用大量的系统资源，<br />影响实时业务</td><td>数据量不多（&lt;10G）或者硬件性能<br />较好的情况</td></tr><tr><td>增量备份</td><td>备份窗口<br />时间缩短</td><td>恢复过程需要引入其他客户端工具，<br />提供的start和end参数存在bug</td><td>已有InfluxDB迁移工具的情况</td></tr><tr><td>离线备份</td><td>物理备份速度快<br />资源占用少</td><td>备份的时候需要管理Shard ID，<br />只能离线恢复并重启服务</td><td>数据恢复主要应用于离线分析和影子<br />环境的场景</td></tr></tbody></table><p>从上表可以看出数据库主备的方式架构复杂而且系统资源消耗极大，一般情况下直接忽略。</p><p>在项目初期数据量较小的时候可以选择全量备份，减少操作的复杂度。随着数据量的逐渐增加，可以选择增量备份或者离线备份。如果选择增量备份需要自己准备InfluxDB迁移工具用于从临时库到主库的数据迁移，而选择离线备份则需要在备份脚本中增加shard ID的管理，当然因此换来的备份资源大幅缩减还是能值回票价的。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>InfluxDB</tag>
      
      <tag>数据技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慧工云融资思考</title>
    <link href="/2021/03/10/%E6%85%A7%E5%B7%A5%E4%BA%91%E8%9E%8D%E8%B5%84%E6%80%9D%E8%80%83/"/>
    <url>/2021/03/10/%E6%85%A7%E5%B7%A5%E4%BA%91%E8%9E%8D%E8%B5%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>有感于慧工云最新发布的融资新闻《慧工云完成亿元B轮融资，持续驱动中国高效制造》，同样诞生于智能制造元年（2016），同样立足离散制造行业，是什么样的选择导致了慧工云比大制科技走的更快更稳呢？下面从公司使命、产品、行业细分和地域四个方面进行深度剖析。</p><span id="more"></span><h2 id="公司使命"><a href="#公司使命" class="headerlink" title="公司使命"></a>公司使命</h2><p>慧工云主页的四个banner给我们传递了如下信息：</p><ul><li>融入现代工业体系的<span style="color:red">数字化解决方案</span>，聚焦离散制造业的运营挑战</li><li>完整双核的IN3制造运营平台，全面帮助<span style="color:red">制造企业数字化转型</span></li><li>工厂全面提效的定制化专家，持续为<span style="color:red">客户</span>创造最大价值</li><li>精益数字化的人才交流圈，专注<span style="color:red">离散制造业数字化转型</span>的公益学习平台</li></ul><p>从以上信息我们可以总结出慧工云的主要战略方向是为离散制造企业数字化转型提供解决方案，持续为客户创造价值。</p><p>企业的核心竞争力来源是数字化解决方案，愿景是持续为客户创造最大价值，同时通过公益学习平台培养并构建用户生态。</p><p>大制科技的主页传递了以下信息：</p><ul><li>设备边缘大脑，感知、学习计算与执行三位一体</li><li>大制荣获xxx百强称号</li><li>大制科技深度参编首个预测性维护国际和国家标准</li><li>顶级企业供应商和联合开发合作伙伴</li></ul><p>除了可以看出一点边缘计算产品的影子，其他的信息基本上是凑数的。从主页的展示上来看，大制科技的公司使命没有能够很直观的传递出来。</p><h2 id="公司产品"><a href="#公司产品" class="headerlink" title="公司产品"></a>公司产品</h2><p>慧工云主打的是数字化运营平台，涵盖了营销管理、供应链管理、生产执行管理、精益数字化、数据决策和客户服务等模块。实现技术驱动业务运营与业务创新，塑造企业发展的第二引擎。大制科技主打的产品包括边缘智能机和工业智能技术平台，边缘智能机实现边缘数据采集，工业智能技术平台提供数据分析的手段。</p><p>从以上分析来看，慧工云的产品注重<span style="color:red">连接和融合</span>，通过全过程的运营数字化实践解决数据孤岛和服务孤岛，发挥数据作用和整体作战能力，从而为企业持续创造价值。大制科技的产品关注数据从采集到分析到决策的切面，力求形成<span style="color:red">数据的闭环</span>，从而达到企业降本增效的目的。</p><p>对比下来慧工云的产品更加接近于企业的认知范围，制造运营是很现实的内容同样面临比较具体的痛点，所以制造运营平台更加容易落地并产生效果。大制科技的产品关注点是企业可能从来没有触碰过的点，如果没有很强的背书或者成功案例，很难说服企业去采购一套超出认知范围的产品。同时大制科技在数据的选用上仅仅关注生产数据，而没有关注运营数据，相当于在数据决策的华山一条路上又选了一条很窄的缝，这种自我设限的做法必然会大大降低用户选择的可能性。</p><h2 id="行业细分"><a href="#行业细分" class="headerlink" title="行业细分"></a>行业细分</h2><p>慧工云的客户定位是离散制造企业，从主页展示的成功案例也可以看出来，既包含了常熟开关厂这样的民族领军企业也有新能源领域的充电连接器工厂。大制科技的客户定位是汽车整车制造企业以及汽车设备零部件企业，从主页展示的成功案例也可以看出来基本都是汽车、机器人等设备的研究。</p><p>一般的理解是公司的行业细分或者客户细分越细，表明公司的专注程度越高，在特定领域形成护城河的可能性越大。但是细分的同时也意味着放弃了其他可能的机会，将公司的命运牢牢的绑定在一棵树上。私以为对于初创公司而言，这种做法是不太妥帖的。在公司还没有完成A轮的情况下，产品也好商业模式也好都是处于验证阶段，过早的选定赛道意味着公司在通往A轮的道路上要么过关要么灭亡。更加稳妥的做法是参考金字塔理论，在公司初期选择一个大的赛道，如离散制造赛道，进行广撒网式的产品验证和模式验证，这个过程会消耗大量的人力、财力和物力<span style="color:red">所以创业公司的种子轮和PreA轮都是至关重要的，不能因为眼前的资金能够满足日常运营就不去融资</span>。在顺利通过市场验证后，公司成功完成A轮，这时候可以选择细分领域进行发力，如投入80%的研发运营成本用于汽车整车制造的产品研发和市场拓展，20%的研发运营成本投入到其他离散制造的产品研发和市场跟踪确保风口来了能马上起飞。</p><h2 id="地域优势"><a href="#地域优势" class="headerlink" title="地域优势"></a>地域优势</h2><p>慧工云立足苏州，辐射全国，充分利用了苏州制造业的行业优势和政府资源，可以完成比较快的扩张和发展。在树立标杆客户上选择了地方的民族领军企业，通过客户的深入参与可以很快的达成效果，互相成就。</p><p>大制科技诞生于上海，基本没有明显的地域优势。在选择标杆客户方面选择上汽集团作为标杆，客户参与度不高，更多的是实验性质的合作，没有起到标杆背书的作用，反而消耗了大量的资源。</p>]]></content>
    
    
    <categories>
      
      <category>团队管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根云平台初体验</title>
    <link href="/2020/08/19/%E6%A0%B9%E4%BA%91%E5%B9%B3%E5%8F%B0%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2020/08/19/%E6%A0%B9%E4%BA%91%E5%B9%B3%E5%8F%B0%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>公司目前的产品偏重于边缘数采和边缘计算，对于规模较大的客户大多需求接入现有的工业互联网平台实现数据统筹管理。</p><p>本文从根云互联网平台（以下简称平台）切入，研究边缘一体机接入平台的可行性。</p><p>在正式开始之前需要先了解平台关于建模的高层设计。通过控制台进入后可以看到在左侧的物菜单下有物模型、物实例和模型模板库三个子菜单。</p><span id="more"></span><img src="menu.png"/><p>结合介绍文档和页面功能，我们可以总结出平台关于物建模的高层设计。</p><img src="high-level.png"/><ol><li>物模型是物理设备的高层次抽象，定义物理设备通用的属性和行为</li><li>物实例是物模型的具体实现，对应现实设备或者网关</li><li>模型模板库是物模型的行业知识库，用于快速创建物模型</li></ol><h2 id="设备建模"><a href="#设备建模" class="headerlink" title="设备建模"></a>设备建模</h2><h3 id="物模型"><a href="#物模型" class="headerlink" title="物模型"></a>物模型</h3><p>基于平台关于建模的设定，我们首先建立我们的物模型。选择物模型类型为网关，填入基本信息即可创建成功。</p><img src="model1.png"/><p>为物模型添加一个变量标识为AA001对应电流接入。</p><img src="model2.png"/><h3 id="物实例"><a href="#物实例" class="headerlink" title="物实例"></a>物实例</h3><p>物模型建立完成后就可以基于物模型创建物实例了。</p><img src="instance1.png"/><h2 id="连接验证"><a href="#连接验证" class="headerlink" title="连接验证"></a>连接验证</h2><p>在设备建模完成后，我们可以通过MQTT网页测试工具向平台发送实时数据。</p><p>测试地址：<a href="https://developer-pre.rootcloudapp.com/docs/resource/mqtt-api-test/">https://developer-pre.rootcloudapp.com/docs/resource/mqtt-api-test/</a></p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><img src="connect.png"/><p>相关页面输入如下所示，</p><p>服务器地址：mqtt-broker-pre.rootcloudapp.com</p><p>Username和clientId : xxxxxxx（通过物实例页面获取到的认证标识）</p><p>端口：8084</p><p>Password：xxxx（通过物实例页面获取到的认证密钥）</p><h3 id="发布数据"><a href="#发布数据" class="headerlink" title="发布数据"></a>发布数据</h3><p>连接建立成功后可以通过发布功能发布数据到平台。</p><img src="publish-data.png"/><p>其中发布的主题是：<code>v4/p/post/thing/live/json/1.1</code>。发布的内容根据需求定义，具体字段可以查看文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;things&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;thingType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Gateway&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;qBad&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;ts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1620720246796</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;AA001&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">13</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>例如以上报文中我们需要关注几个部分，其中thingType可以选择Device和Gateway，选择Gateway时，id为空字符串即可。ts对应上报的时间戳，properties中的AA001就是我们在物模型中定义的属性名。</p><p>发送完之后我们在物实例中可以看到AA001对应的电流的实时值为13。</p><img src="result.png"/><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>我们还可以模拟MQTT的客户端进行连接后向平台发送数据。在客户端程序中需要建立连接，模拟数据格式和发送数据。在客户端选型上我们选择了eclipse paho，使用spring-integration-mqtt进行客户端封装。</p><img src="code.png"/><p>如代码所示，通过暴露的MyGateway接口发送消息到管道，管道接收了消息之后通过创建客户端将消息发送到目标主题。</p><p>发送一段时间后在平台端可以看到AA001的变化趋势。</p><img src="code-result.png"/><h2 id="业务验证"><a href="#业务验证" class="headerlink" title="业务验证"></a>业务验证</h2><p>基于边缘端拓扑结构，我们在平台进行建模如下：</p><img src="solution.png"/><p>首先一个节点对应一体机，在一体机上安装一个MQTT客户端发送数据到平台的MQTT队列。平台侧通过部署一个多节点网关对多个节点进行管理。呈现效果如下：</p><img src="result1.png"/><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<strong>连接验证</strong>，我们确认了可以通过边缘程序发送数据到MQTT队列并在平台进行展示的可行性。通过<strong>业务验证</strong>，我们将边缘端的设备结构和物模型进行匹配，实现了一个网关对应一台边缘智能机并通过复合物进行统一管理的实现路径。</p><img src="path.png"/>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据采集</tag>
      
      <tag>应用技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你的SpringBoot可以启动的再快点</title>
    <link href="/2020/06/15/%E4%BD%A0%E7%9A%84SpringBoot%E5%8F%AF%E4%BB%A5%E5%90%AF%E5%8A%A8%E7%9A%84%E5%86%8D%E5%BF%AB%E7%82%B9/"/>
    <url>/2020/06/15/%E4%BD%A0%E7%9A%84SpringBoot%E5%8F%AF%E4%BB%A5%E5%90%AF%E5%8A%A8%E7%9A%84%E5%86%8D%E5%BF%AB%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>公司最近推出了一款一体机产品，于是老板就天天提个小箱子跑客户做POC，倍儿有范儿。跑了一阵子客户反响（问题）不错（不少），其中最大的问题就是开机进系统太慢，按照老板的说法：</p><blockquote><p>我按下开机键已经准备天花乱坠了，愣是给我一个系统维护界面5分钟才能进去。只好跟他们解释说我们是工业一体机比较严谨，开机前要做好充分的自检。</p></blockquote><p> 其实开机慢我们是有预期的，我们的应用是云端微服务应用，为了快速响应公司号召稍加改造就变成了边缘应用。在资源配置各方面大幅缩水的情况下，不慢都对不起我们30w行的代码量。 </p><p>言归正传，万里长征第一步：重现。通过秒表多次测量的结果显示：</p><ul><li><p>开机进入维护界面需要30s，</p></li><li><p>进入登录页需要2分30s，</p></li><li><p>登录进系统需要近4分钟</p></li></ul><p>虽然没有反馈的那么夸张，这个速度也确实有点慢了。</p><span id="more"></span><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>基于上面的测量结果，我们可以得到如下分布图：</p><img src="time-distribute.png"/><p>系统启动时间占比较小，而且在操作系统级别的优化比较复杂收益不高，我们将优化的重心放在应用启动和系统登录两个部分。</p><ul><li><p>应用启动</p><p>我们通过查看应用日志可以发现应用的实际启动时间为109s，这个时间和我们之前实测的时间也比较吻合，可以作为我们应用优化的基线。</p></li><li><p>系统登录</p><p>系统登录时间的消耗看起来不太合理，这是因为我们的应用使用了Eureka作为微服务的注册发现组件，导致了在应用启动后要经历多次心跳验证才能真正可用。这部分的优化策略是在一体机中去掉Eureka，RestTemplate直接访问本机Restful服务即可。</p></li></ul><p>经过以上初步分析，我们明确了我们优化的对象就是109s的应用启动时间。在开始之前我们先说一下我们面临的应用规模，30w业务代码行，800+ spring管理的对象，Jar包大小70M左右。</p><h2 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h2><p>通过查阅资料可以找到一些先行者，虽然案例大多是很简单的应用，比如说只有一个依赖的情况优化到1s之内，但是原理上还是相通的。</p><h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>我们可以通过@Lazy指定单个bean的延迟初始化，或者通过@ComponentScan指定lazyInit&#x3D;true，也可以实现一个LazyInitBeanFactoryPostProcessor类来灵活的指定。</p><p>在实际过程中我们发现不是所有的类都能设置为lazyInit的，比如消息队列的监听类如果一开始不进行实例化那么就永远不会被实例化，这会导致消息永远都不会被消费；还有定时任务类，同样不适合设置成lazyInit。</p><p>最终我们采用LazyInitBeanFactoryPostProcessor的方式实现了两个数组进行灵活定制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] COMMON_INIT_LIST= &#123;<br>  <span class="hljs-string">&quot;springContextUtil&quot;</span>,<br>  <span class="hljs-string">&quot;custJobFactory&quot;</span><br>&#125;;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] CUST_INIT_LIST= &#123;<br>  <span class="hljs-string">&quot;userMsgReceiver&quot;</span>,<br>  <span class="hljs-string">&quot;dgnsOperateReceiver&quot;</span>,<br>  <span class="hljs-string">&quot;equipCondCalcReceiver&quot;</span>,<br>  <span class="hljs-string">&quot;modelAnalysisReceiver&quot;</span>,<br>  <span class="hljs-string">&quot;modelAnalysisScheduler&quot;</span><br>&#125;;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;   <br><span class="hljs-keyword">if</span>(!needInitBean(beanName)) &#123;<br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> beanFactory.getBeanDefinition(beanName);<br>definition.setLazyInit(<span class="hljs-literal">true</span>);<br>&#125;<br>      &#125;<br>&#125;<br>  <br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needInitBean</span><span class="hljs-params">(String beanName)</span> &#123;<br><span class="hljs-keyword">return</span> ArrayUtils.contains(COMMON_INIT_LIST, beanName) || ArrayUtils.contains(CUST_INIT_LIST, beanName);  <br><br></code></pre></td></tr></table></figure><p>通过延迟初始化，应用启动时间从109s提升到48s，效果非常明显。</p><h3 id="JVM启动参数优化"><a href="#JVM启动参数优化" class="headerlink" title="JVM启动参数优化"></a>JVM启动参数优化</h3><p>这里主要涉及的启动参数设置是下面两个：</p><ol><li><p>-XX:TieredStopAtLevel&#x3D;1</p><p>使用C1编译器，又称为客户端模式，相对于C2也就是服务端模式，C1编译生成的机器码更加关注快速启动但是由于机器码没有经过编译优化所以不适合在线上环境稳定运行。</p></li><li><p>-Xverify:none&#x2F; -noverify</p><p>通过去除字节码的验证来提升JVM启动速度，同样不适合线上对安全有要求的环境使用。</p></li></ol><p>我们平时开发的时候可能注意到在IDE如Eclipse中启动一个SpringBoot应用的时候有一个选项叫Fast-startup，如图：</p><img src="fast-startup.png"/><p>我们一般都是默认勾选的，殊不知这个选项对应的参数就是以上两个JVM参数。</p><img src="fast-startup2.png"/><p>这两个参数的设置可以大大提升我们本地启动的速度，而本地启动不存在稳定性和安全性的问题，所以适用这两个参数。 </p><p>实际案例中我们通过这两个参数的设置，可以将启动时间提升到40s。</p><h3 id="生成组件索引"><a href="#生成组件索引" class="headerlink" title="生成组件索引"></a>生成组件索引</h3><p>通过引入Maven依赖spring-context-indexer在编译阶段来为组件生成索引加快类扫描速度。具体做法分为两步：</p><ol><li><p>添加Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-indexer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置Maven Plugin</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!--$NO-MVN-MAN-VER$--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-indexer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过Maven install命令运行后在生成的jar包的META-INF目录下面会生成spring.components文件。如果你的项目是多模块项目，那么在每个模块的jar下面都会生成一个索引文件。</p><p>通过这步优化，启动时间可以提升到38s，效果不算明显。这和我们项目本身的规模还有路径扫描的速度有关，如果项目本身类不多或者路径扫描本身很快，那建索引就没有多大意义了，目前看来2s的提升聊胜于无吧。</p></li></ol><h2 id="上下求索"><a href="#上下求索" class="headerlink" title="上下求索"></a>上下求索</h2><p>在通用优化建议的基础上，我们还根据自己的经验和尝试，进行了进一步的优化。</p><h3 id="延迟初始化-1"><a href="#延迟初始化-1" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>这次的延迟初始化是从代码层面来进行。通过第一步的延迟初始化处理，我们筛选出一些需要提前初始化的类。而这些类的初始化由于存在类依赖等因素又会牵扯出一大串的初始化，导致我们在少量类的初始化上花费了较多的时间。</p><p>举个例子，我们有个消息消费类通过@Autowired强依赖类5个service，那么在这个Receiver类初始化的时候这5个service也会被触发初始化，service类中又通过@Autowired引入了其他类的初始化，层层传递导致一个类的初始化实际触发了几十个类的初始化，已经破坏了我们延迟初始化的设定。</p><p>针对这种情况可以在@Autowired字段上加上@Lazy注解，但是容器在注册属性的时候会提示一个warning：AnnotationUtils - Failed to meta-introspect annotation。虽然不影响后续初始化，但是看着还是很糟心的。所以我选择的方式是干脆把这几个需要提前初始化的类里面的@Autowired字段全部移除，使用的时候到ApplicationContext获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> EquipCondService condService;<br><span class="hljs-comment">//替换为使用时获取,做到真正的延迟实例化</span><br><span class="hljs-type">EquipCondService</span> <span class="hljs-variable">condService</span> <span class="hljs-operator">=</span> SpringContextUtil.getBean(EquipCondService.class);<br><br></code></pre></td></tr></table></figure><p>通过代码改造之后的延迟初始化升级，启动时间提升到29s，效果还不错。</p><h3 id="Shiro初始化优化"><a href="#Shiro初始化优化" class="headerlink" title="Shiro初始化优化"></a>Shiro初始化优化</h3><p>Shiro的问题是通过查看Spring debug日志中的跳变发现的。</p><img src="shiro1.png"/><p>在正常的日志中一般两个日志的间隔也就几十毫秒，而在shiro的初始化过程中我们发现了一段3s的间隔，那一定是发生了什么不可告人的事情。通过二分查找的Debug终于发现了问题所在。</p><p>在shiroConfig中需要定一个securityManager，我们使用了Apache包里自带的DefaultWebSecurityManager。以下是DefaultWebSecurityManager类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultWebSecurityManager</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>();<br>((DefaultSubjectDAO) <span class="hljs-built_in">this</span>.subjectDAO).setSessionStorageEvaluator(<span class="hljs-keyword">new</span><br>                                                                     <span class="hljs-title class_">DefaultWebSessionStorageEvaluator</span>());<br><span class="hljs-built_in">this</span>.sessionMode = HTTP_SESSION_MODE;<br>setSubjectFactory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultWebSubjectFactory</span>());<br>setRememberMeManager(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CookieRememberMeManager</span>());<br>setSessionManager(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContainerSessionManager</span>());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractRememberMeManager</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.serializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSerializer</span>&lt;PrincipalCollection&gt;();<br>        <span class="hljs-type">AesCipherService</span> <span class="hljs-variable">cipherService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AesCipherService</span>();<br>        <span class="hljs-built_in">this</span>.cipherService = cipherService;<br>        setCipherKey(cipherService.generateNewKey().getEncoded());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现在SecurityManager初始化的时候会初始化依赖的CookieRememberMeManager，最终调用到抽象类的构造函数。在这里有一句话最终造成了3s的启动延时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cipherService.generateNewKey()<br></code></pre></td></tr></table></figure><p>这是生成对称加解密密钥的方法，通过单元测试发现这句话单独执行时间也是在3s左右，验证了我们的结论。</p><p>解决方法简单粗暴，使用自定义的WebSecurityManager，去掉setRememberMeManager的调用即可。</p><p>经过这一步优化后，启动时间优化到26s，刚好是3s的提升。</p><h2 id="温故知新"><a href="#温故知新" class="headerlink" title="温故知新"></a>温故知新</h2><p>在一体机开机速度提升的需求驱动下，我们首先甄别出需要解决的关键问题就是应用启动时间。我们通过借鉴先行者的成功经验，成功的将应用启动时间从109s提升到38s。然后从日志分析入手，找出日志中的跳变点，解决了@Autowired引发的伪延迟问题和Shiro生成密钥的时间损耗。最终我们成功的将启动时间控制到了30s之内（26s），而相应的一体机从开机到老板开始天花乱坠也就只需要1分半钟，喝口水就掩饰过去了。</p><p>下面罗列一下我们的优化路径，供后续参考借鉴。</p><img src="path.png"/>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的锁机制</title>
    <link href="/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/05/25/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>说起Java中的并发，有一个永恒的话题就是锁机制，而提及Java中的锁，我们一般认为有两种形式，</p><ol><li>通过synchronized关键字的实现</li><li>通过Lock接口的实现</li></ol><p>网上关于两种方式的对比已经比较详尽，从使用角度来看synchronized关键字方式属于自动档，只需一条指令加锁释放全搞定，而Lock接口实现的锁则相当于手动挡，需要关注加锁、锁中断和解锁的一系列细节，搞不好就得熄火。特别是在JDK1.6对于synchronized关键字做了大量的优化后，已经做到大部分业务都够用了，所以废话不在多，今天的主题：自动档synchronized发车！</p><h2 id="同步对象"><a href="#同步对象" class="headerlink" title="同步对象"></a>同步对象</h2><p>通过synchronized关键字修饰的部分我们一般称之为同步块，而同步块的实现是对于同步块指定一个唯一访问的对象。在实现过程中我们会涉及两类同步对象，四种同步代码实现方式。</p><span id="more"></span><h3 id="实例对象同步"><a href="#实例对象同步" class="headerlink" title="实例对象同步"></a>实例对象同步</h3><p>实例对象同步是指同步块的唯一访问对象是一个实例对象，实例对象同步的时候会尝试获取实例对象的monitor，这种时候需要注意的是不同线程如果同步的是同一个类的不同实例，是起不到对象同步的作用的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">test2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test1).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test2).start();<br></code></pre></td></tr></table></figure><p>实例对象同步我们又分为两种形式，</p><ul><li>实例方法的synchronized关键字</li><li>实例方法中的synchronized代码块</li></ul><h3 id="类对象同步"><a href="#类对象同步" class="headerlink" title="类对象同步"></a>类对象同步</h3><p>类对象同步是指同步块的唯一访问对象是一个类对象，类对象同步的时候会尝试获取类对象的monitor。所以在类对象同步的时候我们可能面临过度锁的问题，即类对象中的同步块被线程锁定导致所有类实例都无法被其他线程访问。</p><p>类对象同步我们有两种代码实现方式，</p><ul><li>静态方法的synchronized关键字</li><li>静态方法中的synchronized代码块</li></ul><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>我们知道synchronized关键字主要是通过JVM层面进行实现，而这时候来看一下JVM的字节码就是一个很有（显）必（逼）要（格）的事情了。针对上面提到的四种代码实现方式，我们简单撸一段代码：</p><img src="code.png"/><p>然后使用javac先编译成class文件再使用javap来查看字节码。</p><img src="compile.png"/><p>通过字节码的结果比对我们发现，通过synchronized关键字修饰的同步块都在字节码中以monitorenter和monitorexit的指令形式体现了出来，而通过关键字修饰的方法都没有体现。</p><p>难道是加在方法上的关键字不起作用？我们可以反过来想一下，如果针对这两种情况加monitorenter和monitorexit指令我们是加在哪里呢？方法的开头和结尾，那么直接给这个方法加一个标记每次进入这个方法的时候通过标记去获取锁离开的时候再通过标记去释放不就行了吗。所以我们在方法定义下面看到了一行flag，而其中有一个ACC_SYNCHRONIZED正是起到了这个同步标记的作用。</p><p>总结起来，synchronized关键字的底层实现分成显式的指令实现和隐式的标记实现。显式实现主要针对同步块，通过将同步块代码包含在monitorenter和monitorexit指令中实现代码块的同步访问。关于monitorenter和monitorexit的实现原理，摘抄官方说明如下：</p><blockquote><p>monitorenter</p><p>​     Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p><p>​     • If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</p><p>​     • If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</p><p>​     • If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p><p>monitorexit</p><p>  The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</p><p>​     The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></blockquote><p>隐式实现主要针对同步方法，字节码层面通过ACC_SYNCHRONIZED标志位实现。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置。如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。关于monitor的获取释放规则和指令级别的实现一致。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>在synchronized关键字刚刚出现的时候，往往会成为我们性能调优的常客，甚至很多代码规范中明确指出尽可能的避免使用synchronized关键字来实现代码同步。终于在JDK1.6的时候，官方爸爸出手了，优化点包含：</p><ol><li><p>引入适应性自旋锁</p><p>在传统锁实现中，如果线程获取锁失败则进入阻塞，CPU进行状态切换，而往往状态切换的代价是很大的。为了解决这个问题，自旋应运而生，简单来说就是通过不停的尝试直到获取到锁。当等待的任务执行时间较长时，无限制的自旋会浪费CPU时间，一般会给自旋加一个固定的次数限制。适应性自旋则更进一步，由前一次在同一个锁上的自旋时间和锁的拥有者的状态共同决定自旋的次数，如果前一次自旋成功并且当前拥有者正常运行则允许当前自旋占用较多的CPU时间来进行自旋，如果在当前锁上的自旋极少成功则分配较少的自旋次数避免资源浪费。</p></li><li><p>通过逃逸分析的锁消除</p><p>主要是指JIT对于不存在同步访问的同步块进行锁消除操作，具体来说就是在字节码转机器码阶段忽略掉不必要的monitorenter和monitorexit指令。</p></li><li><p>锁粗化</p><p>JIT在进行动态编译的阶段，如果发现前后两个同步块对同一个对象进行加锁，则将锁粗化成一个，避免了反复获取释放锁的开销。</p></li><li><p>通过锁分级引入偏向锁和轻量锁</p><p>锁分级的理念是基于锁的应用场景进行了细分，研究发现在实际应用中大部分的同步场景都出现在无竞争状态，小部分出现在存在少量竞争的场景，还有小部分是存在大量竞争的场景。</p><p>针对无竞争场景，提出了偏向锁，通过在对象头中存储偏向的线程ID，下次再进入的时候就可以无代价获取到锁。</p><p>针对低竞争场景，推出了轻量锁，通过CAS操作来尝试替换对象头中的线程指向，如果多次自旋失败表明跳出了低竞争场景则进行锁膨胀，升级为重量级锁。</p></li></ol><h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>所谓的可重入性，在锁机制的上下文中我们可以理解为如果一个线程获取了对象的锁之后多次访问对象的同步块都不会发生阻塞。通俗来讲可以理解为，我们获取了一个大房子（对象）的钥匙，那么以后想进哪间房间（同步块）就进哪间房间。</p><p>提到可重入性，比较迷惑的是JUC中的ReentrantLock，让人觉得如果要实现锁的可重入性必须使用这个类，事实上synchronized实现的锁默认也是可重入的。</p><h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>锁的公平性是指获取锁的顺序严格的按照线程加锁请求到达的顺序，即满足先到先得原则。在Java中synchronized实现的锁是非公平的，而Lock接口的实现中如ReentrantLock中的锁也是默认非公平的。不同点在于synchronized无法实现公平锁，而ReentrantLock可以通过传入参数指定使用公平锁或者非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>     sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>这里主要看一下synchronized在ConcurrentHashMap中的应用。</p><p>在JDK1.8中对于ConcurrentHashMap有一项很重要的变更是取消了Segment的使用，取而代之的是使用Node数组结合synchronized的方式对单条记录进行加锁来进一步提高数据结构的并发性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">synchronized</span> (f) &#123;<br><span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br><span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>binCount = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>K ek;<br><span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>((ek = e.key) == key ||<br> (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>oldVal = e.val;<br><span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>e.val = value;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>Node&lt;K,V&gt; pred = e;<br><span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>  value, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>Node&lt;K,V&gt; p;<br>binCount = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>   value)) != <span class="hljs-literal">null</span>) &#123;<br>oldVal = p.val;<br><span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>p.val = value;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Segment是基于ReentrantLock实现的，我们不妨发散一下将这次升级解读成：</p><ol><li>synchronized的优化到1.8版本已经经过足够的验证可以出现在基础数据结构中</li><li>在锁的使用上官方推荐synchronized的方式，后续应该还有持续发力</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们从使用方式和底层实现两个方面出发全面认识了Java中的加锁方式synchronized关键字。特别是经过JDK1.6的脱胎换骨，现在的synchronized关键字已经成为了更多并发实现的首选。通过对锁机制的一般特性如重入性和公平性的理解，我们不难发现不管是synchronized方式还是Lock方式，实现思想上都是一脉相承的。而之所以并存的原因大概也是为了可以通过多种选择的提供达到相互促进的目的吧。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Spring Cloud Gateway的路由实践</title>
    <link href="/2020/03/13/%E5%9F%BA%E4%BA%8ESpring-Cloud-Gateway%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E8%B7%B5/"/>
    <url>/2020/03/13/%E5%9F%BA%E4%BA%8ESpring-Cloud-Gateway%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>在IT和OT融合的道路上，数据能力是很重要的一环。在设备端我们通过软PLC的解决方案覆盖了常见的数采方式和工业协议，那么采来的海量数据如何存储就成了我们当前的重中之重。</p><p>在调研了流行的数据存储方案后，我们决定基于开源时序数据库打造一款工业适用、业务定制的数据存储引擎。而接下来要介绍的路由网关可以认为是整个数据存储引擎的代理人，通过路由网关的引入，极大的透明了数据存储引擎的使用。不管是工业应用还是数采网关抑或是数据分析人员都可以方便的对数据进行读写操作，没有一点负担，没有一点门槛。</p><span id="more"></span><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Spring Cloud Gateway（下文以SCG代替）， 顾名思义这是由Spring 官方出品的一款网关产品，是Spring Cloud的子项目。再看一下官方介绍：</p><blockquote><p>This project provides a library for building an API Gateway on top of Spring MVC. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring&#x2F;metrics, and resiliency.</p></blockquote><p>主要突出了路由功能的简单有效，同时可以在安全、监控以及扩展性方面提供不错的支持，毕竟靠着Spring Cloud这面大树。</p><h2 id="架构考虑"><a href="#架构考虑" class="headerlink" title="架构考虑"></a>架构考虑</h2><image src="archi.png"/><p>这是官方网站的工作原理示意图，从上图可以看出SCG在整个流程中主要担任反向代理的角色。客户端请求抵达SCG后，SCG通过Handler Mapping将请求路由到Web Handler，Web Handler再通过Filter对原始请求进行处理，最终发送到被代理的服务端。</p><p>在研究SCG之前，我们发现Spring Cloud下面已经有一个成熟的API套件Spring Cloud Netflix，提供了服务注册发现（Eureka），熔断器（Hystrix），智能路由（Zuul）和客户端负载均衡（Ribbon）等特性，其中就有我们需要的路由功能Zuul。</p><p>那为什么在集成一个路由功能后，Spring Cloud还要自己开发一个用于路由的Gateway项目呢？我们来看看他们的一些对比，由于Spring Cloud只集成了Zuul1.0，所以比较也集中在Zuul1.0和SCG之间。</p><table><thead><tr><th></th><th>连接方式</th><th>支持服务器</th><th>功能</th></tr></thead><tbody><tr><td>Zuul1.0</td><td>Servlet API</td><td>Tomcat，undertow</td><td>基本路由规则，仅支持Path的路由</td></tr><tr><td>SCG</td><td>Reactor</td><td>Netty</td><td>较多路由规则，可以支持header，cookie，query，method等丰富的predict定义</td></tr></tbody></table><p>从上面的对比来看，SCG基于Project Reactor可以获得更优秀的吞吐，在功能方面相当于Zuul的优化，更加灵活的配置可以满足几乎所有的网关路由需求。</p><p>虽然说Zuul2.0也是基于Netty开发，并增强了路由和过滤器功能，然而他的多次跳票最终让Spring下决心自己做一款网关路由产品，并表示不会将Zuul2.0集成进以后的Spring Cloud中，也算一段趣闻吧。</p><h2 id="网关实践"><a href="#网关实践" class="headerlink" title="网关实践"></a>网关实践</h2><p>下面我们实际动手实现一个网关，结合过程中遇到的问题来熟悉SCG的各项特性。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>我们新建一个基于Spring Boot的Maven项目，添加SCG的依赖，主要是下面两个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们这里选择的是最新的Spring Boot Release版本（2.1.4）以及支持2.1的Spring Cloud分支Greenwich。 </p><p>最后建一个SpringBootApplication，参照首页的Demo去掉Hystrix和RateLimit相关的内容就可以跑起来了（<a href="https://spring.io/projects/spring-cloud-gateway%EF%BC%89%E3%80%82">https://spring.io/projects/spring-cloud-gateway）。</a></p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>光有个Demo肯定不行，我们的网关是要实际投产使用的，在分析了实际需求之后我们识别出急需的第一个功能是动态路由。</p><p>在文档中提供了两种方式的路由配置方式：</p><ol><li><p>通过java API</p><p>直接通过RouteLocatorBuilder构建如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">builder.routes().route(<span class="hljs-string">&quot;path_route&quot;</span>, r -&gt; r.path(<span class="hljs-string">&quot;/get&quot;</span>).uri(<span class="hljs-string">&quot;http://httpbin.org&quot;</span>)).build();<br></code></pre></td></tr></table></figure></li><li><p>通过配置文件</p><p>通过YAML文件构建路由如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">host_route</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span><br>        <span class="hljs-attr">predicates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">path=/foo/&#123;segment&#125;,/bar/&#123;segment&#125;</span><br><br></code></pre></td></tr></table></figure></li></ol><p>但是我们实际需求中存在动态分配路由的场景，以上两种方式显然都不能满足需求。</p><p>通过查看源代码发现SCG加载路由是通过RouteDefinitionLocator接口实现，有以下默认实现（框掉的部分可以暂时忽略，这是我们自己的实现）：</p><image src="code1.png"/><p>在GatewayAutoConfiguration中通过Primary的方式指定CompositeRouteDefinitionLocator作为路由定义加载的入口，通过组合模式将所有的RouteDefinitionLocator代理。最终通过CompositeRouteDefinitionLocator的getRouteDefinitions方法将所有定义加载出来。</p><image src="code2.png"/><image src="code3.png"/><p>通过源代码的解读，我们发现如果需要定义新的路由加载方式，只需要增加一个RouteDefinitionLocator的实现即可，在实际操作中为了方便路由更新我们仿照已有的实现</p><p>InMemoryRouteDefinitionRepository进行实现，类图如下：</p><image src="class_diagram.png"/><p>我们通过新增了一个抽象类类完成RouteDefinitionRepository的扩展，在抽象类里我们实现了基本的get, save, delete方法，另外新增了refresh方法用于刷新缓存，而缓存的实现参考了InMemory的实现方式。</p><p>在需要进行扩展的时候我们可以通过继承AbstractRoutConfigure来增加我们自己的configure loader，再通过Configuration方式注入即可：</p><image src="code4.png"/><p>最终的实现效果是我们通过数据库变更配置后，通过restful接口来调用refresh方法即可完成路由的动态刷新。</p><h3 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h3><p>通过上面动态路由的基本实现，我们数据库中的配置是这样的：</p><image src="table.png"/><p>但是我们是要做微服务和集群的网关，直接写地址显然是不行的。</p><p>针对这种情况，SCG提供了一种URI的格式：lb:&#x2F;&#x2F;main-service，其中main-service是我们微服务在注册中心的name。当URI以lb开头，则在进行URI解析的时候会去寻找zookeeper，consul，eureka对应的客户端实现。我们使用的是eureka，并且在数据库中加上以下配置：</p><image src="table2.png"/><p>这样我们就可以成功代理微服务提供的接口了。</p><h3 id="容错管理"><a href="#容错管理" class="headerlink" title="容错管理"></a>容错管理</h3><p>容错管理从以下两方面进行考虑：</p><ol><li><p>路由未定义</p><p>针对路由未找到的情况，提供有意义的报错信息进行有效反馈。</p><p>实现层面主要通过定义一个NotFound的路由，通过设置order确保NotFound路由在所有的路由之后执行，这样当所有的路由都没有匹配上的时候就会被路由到NotFound路由，从而反馈有意义的报错信息。</p></li><li><p>熔断器</p><p>熔断器主要应用于请求超时，服务端错误等使用场景，SCG提供了Hystrix的集成，我们只需要在YAML配置文件里面配置default filter并加入fallbackUri的实现即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hystrix</span><br>        <span class="hljs-attr">args:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fallbackcmd</span><br>          <span class="hljs-attr">fallbackUri:</span> <span class="hljs-string">forward:/fallbackcontroller</span><br><br></code></pre></td></tr></table></figure></li></ol><p>通过上面两点的配置，我们在请求出错如超时、服务宕机的情况都可以得到对应的错误信息，确保了网关服务的鲁棒性。</p><h3 id="限流机制"><a href="#限流机制" class="headerlink" title="限流机制"></a>限流机制</h3><p>SCG使用的限流机制（Rate Limiter）基于令牌桶算法，我们先大致了解一下令牌桶算法。</p><image src="rate.png"/><p>从上图可以看出，令牌桶算法的主要数据结构是个缓冲区。通过匀速生成的令牌来填充缓冲区相当于生产者，而实际流量则相当于消费者来消费缓冲区中的令牌。 </p><p>我们再结合SCG中的实现来看看令牌桶算法如何限流的。</p><p>SCG使用RateLimiter需要引入spring-boot-starter-data-redis-reactive，所以SCG的令牌桶实现是基于Redis的，这样可以满足分布式的要求。SCG在使用过程中需要设置三个参数replenishRate ，burstCapacity和KeyResolver。</p><ul><li>replenishRate表示的是装桶的速率，也就是令牌生成的速率</li><li>burstCapacity表示瞬间高爆发的容量，官方文档解释是一秒内允许的最大流量又补充了一句是令牌桶可以装下的令牌数</li><li>KeyResolver很好理解，通过key的定义可以明确规定限流的层级，用户级还是IP级别等等</li></ul><p>对于burstCapacity的理解，只有当replenishRate和burstCapacity相等时也就是请求处理基本是匀速的情况下，burstCapacity才表示一秒内允许的最大流量，否则解释为令牌桶的容量更加贴切。</p><p>代码实现主要通过RedisRateLimiter.class和request_rate_limiter.lua两个文件，而主要逻辑是通过脚本文件实现。</p><image src="code5.png"/><p>这里主要获取java传过来的参数，计算出ttl，ttl的逻辑是桶装满所需时间的两倍。</p><image src="code6.png"/><p>上面这段代码是实现限流的关键，每次都会通过当前时间和上次刷新时间的间隔计算填充的令牌，只有填充后的令牌 &gt;&#x3D; 请求的令牌数才符合条件允许令牌获取。</p><p>当新的请求获取令牌后，更新令牌桶的令牌数和最后刷新时间。</p><p>在实际引用中我们根据我们服务器的压力来设定rate和capacity，通过不停的调节来寻求吞吐和负载的平衡。</p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>日志配置方面除了基本的logback配置，需要加入access_log的配置，根据官方文档我们需要在logback配置文件中加入logger和appender的配置。</p><image src="code7.png"/><p>如上图所示，通过定义logger接收netty的AccessLog，通过异步发射器发送到accessLog和errorLog两个Appender，在Appender中通过filter来区分日志类型。 </p><p>这里需要注意的是Netty AccessLog的配置要到reactor-netty0.7.9之后才支持，所以在使用这个功能之前需要确保我们netty的版本满足要求，项目目前使用的spring版本如下，对应的reactor-netty版本为0.8.6。</p><p>配置了这么多，然而access.log文件还是空空如也，因为你漏掉了很重要的一步：</p><p>在启动参数中添加 <code>-Dreactor.netty.http.server.accessLogEnabled=true</code>. 注意这个属性是java系统属性而不是spring配置属性，也就是说只能通过启动参数注入。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过一些简单的介绍了解了SCG的出现背景，然后通过实际的网关搭建实践来一步步的理解SCG的架构理念和实现细节。</p><p>通过动态路由部分我们见证了SCG的可扩展性架构，在服务路由和容错管理部分我们主要和Spring Cloud已有组件（eureka， hystrix）进行集成，而在限流机制部分我们通过阅读源代码理解了基于令牌桶的限流算法以及如何结合Redis实现分布式系统限流，在日志配置部分主要是结合Netty的日志机制来完成网关的访问日志配置。</p><p>在我们的实践中我们没有用上SCG的所有特性，但是就目前的情况用于我们自己的API 网关已经够用。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>应用技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Netty的边缘数采</title>
    <link href="/2020/03/13/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%B0%E9%87%87/"/>
    <url>/2020/03/13/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%B0%E9%87%87/</url>
    
    <content type="html"><![CDATA[<p>在设备数据采集方面，我们已经探索出一套成熟的做法即在设备侧部署一个边缘程序，通过定时拉取的机制到工控机如PLC的指定位置获取数据。但是对于机器人来说，不同型号的机器人控制设备都有自己不同程度的封装，我们需要严格按照机器人设备的数据开放方式进行定制化实现才有可能正确的获取到数据。</p><p>就我们这次研究的FANUC机器人来说，它的数据是通过内置的Socket服务端发送出来的。因此我们的数采方案是在边缘端部署一个相应的Socket客户端与之进行通信，获取数据并进行后续处理。</p><span id="more"></span><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p>由于团队的主技术栈是Java， 所以我们决定选用Netty作为构建网络通信客户端的框架。至于为什么使用Netty而不是原生的Java NIO不是本文讨论的重点，可以简单粗暴的认为Netty就是比原生的Java NIO更贴近实际应用场景。</p><p>通过分析需求，我们得出如下技术细节分解：</p><img src="solution.png"/><p>其中多客户端体现了边缘端管理维度的需求，断线重连机制是通讯维度的要求，数据解析和粘包处理是数据处理维度。接下来我们就针对技术细节进行详细的可行性验证。</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="多客户端"><a href="#多客户端" class="headerlink" title="多客户端"></a>多客户端</h3><p>在Netty中启动一个客户端简单到只需要三句话，虽然链式调用的一句话确实有点长。原始的Netty客户端建立过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>   <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>   bootstrap.group(workerGroup)<br>.channel(NioSocketChannel.class)<br>.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientIniterHandler</span>())<br>.connect(ip, port).addListener();<br><br></code></pre></td></tr></table></figure><p>考虑到多客户端的需求，我们对Netty客户端进行了封装，封装后的客户端更加易于管理。</p><img src="class-diagram.png" alt=""/><p>Starter是启动类，负责读取配置文件并初始化客户端，通过Map&lt;String, NettyClient&gt;的数据结构来管理所有的客户端。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">File[] files = FileUtil.getPropertiesFileArr();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; files.length; i++) &#123;<br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> PropertiesUtil.initProperties(files[i]);<br><span class="hljs-type">NettyClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClient</span>(properties);<br>clientMap.put(properties.getProperty(<span class="hljs-string">&quot;server.ip&quot;</span>)+<span class="hljs-string">&quot;:&quot;</span>+properties.getProperty(<span class="hljs-string">&quot;server.port&quot;</span>),client);<br>client.run();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>NettyClient是封装后的客户端，通过配置文件构造，将配置注入到属性中。DataHandler是数据处理类，主要负责报文解析和数据发送后台数据的工作。每个NettyClient聚合一个DataHandler用于数据处理，避免了并发问题符合Netty串行处理的设计思想。</p><h3 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h3><p>针对断线重连功能我们聚焦两个关注点，</p><ol><li><p>首次连接失败的重试</p><p>首次连接我们通过对Connect事件加入Future Listener实现，在Future Listener中监听isSuccess标识位可以获取到连接状态，从而确定下一步动作。加入retryTime字段的控制，当重试次数达到一定次数后降低重试的频率，一定程度上节省资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.connect(ip, port).addListener((ChannelFuture futureListener)-&gt;&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">EventLoop</span> <span class="hljs-variable">eventLoop</span> <span class="hljs-operator">=</span> futureListener.channel().eventLoop();<br><span class="hljs-keyword">if</span> (!futureListener.isSuccess()) &#123;<br><span class="hljs-comment">// 10s秒之后重连</span><br>retryTimes ++;<br><span class="hljs-keyword">if</span>(retryTimes &lt;= <span class="hljs-number">10</span>) &#123;<br>eventLoop.schedule(() -&gt; <br>doConnect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>(), eventLoop), <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//超过10次后改成1分钟重试</span><br>eventLoop.schedule(() -&gt; <br>doConnect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>(), eventLoop), <span class="hljs-number">1</span>, TimeUnit.MINUTES);<br>&#125;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>retryTimes = <span class="hljs-number">0</span>;<br>LOG.info(<span class="hljs-string">&quot;客户端[&#123;&#125;]与服务器连接成功&quot;</span>,id);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>非首次连接的断线重连</p><p>当连接过程中发生断线会触发Inactive事件，在Client Handler的channelInactive监听中进行处理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">EventLoop</span> <span class="hljs-variable">eventLoop</span> <span class="hljs-operator">=</span> ctx.channel().eventLoop();<br><span class="hljs-comment">//获取配置信息</span><br><span class="hljs-type">NettyClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> getNettyClientByCtx(ctx);<br><span class="hljs-keyword">if</span>(client != <span class="hljs-literal">null</span>) &#123;<br>client.doConnect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>(), eventLoop);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="16进制解析"><a href="#16进制解析" class="headerlink" title="16进制解析"></a>16进制解析</h3><p>在服务端和客户端通信的过程中通常采用字节流，Netty在接收端通过Pipeline加入编解码器的方式完成字节流和对象之间的转换。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();<br>pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br></code></pre></td></tr></table></figure><p>这里的StringDecoder是字符串解码器，字节流通过解码器的解析就可以转换成String类型，从而方便后续的处理。我们遇到的问题是服务端发送的是16进制数据，因此我们需要的是一个16进制解码器，下面是我们对于两种处理过程的比较。</p><img src="compare.png"/><p>由此可以看出和一般的处理差异在于服务端多了16进制编码过程，导致客户端也要相应的增加16进制的解码器，考虑实现方便我们将16进制解码器和字符串解码器合并成一个HexDecoder。在ClientInitHander中使用HexDecoder替换原来的StringDecoder。</p><p>而HexDecoder的Decode方法主要就是做了两件事情a) 字节到HexString b) HexString到String，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">HEXES</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>    <span class="hljs-type">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[msg.readableBytes()];<br>    msg.readBytes(req);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">2</span> * req.length);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; req.length; i++) &#123;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> req[i];<br>hex.append(HEXES.charAt((b &amp; <span class="hljs-number">0xF0</span>) &gt;&gt; <span class="hljs-number">4</span>))<br>.append(HEXES.charAt((b &amp; <span class="hljs-number">0x0F</span>)));<br>    &#125;<br>    out.add(ClientUtil.hexStr2Str(hex.toString()));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">hexStr2Str</span><span class="hljs-params">(String hexStr)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>    <span class="hljs-type">char</span>[] hexs = hexStr.toCharArray();<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[hexStr.length() / <span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bytes.length; i++) &#123;<br>n = str.indexOf(hexs[<span class="hljs-number">2</span> * i]) * <span class="hljs-number">16</span>;<br>n += str.indexOf(hexs[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>]);<br>bytes[i] = (<span class="hljs-type">byte</span>) (n &amp; <span class="hljs-number">0xff</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上的实现16进制数据的解析问题是解决了，我们不禁要好奇一下服务器为啥要弄成16进制传输呢？</p><p>结合网上的讨论，下面两点是我比较认可的</p><ol><li>机器人内部的数据都是二进制01形式的，二进制和十六进制之间转换比较容易</li><li>相对十进制来说，十六进制的数据可读性更强，如Ox1064，很容易的看出高四位是0001而这个位置一般会放一些标志位。</li></ol><h3 id="粘包处理"><a href="#粘包处理" class="headerlink" title="粘包处理"></a>粘包处理</h3><p>粘包是指客户端读取的报文不是一个完整的报文，大多数情况会和拆包结对出现。举个例子，我们的报文结构是<Robot><Item1></Item1></Robot>，当出现粘包的情况时某一次收到的报文就可能是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Robot</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Item1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Item1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Robot</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Robot</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Item1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而下一次收到的报文就可能是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Item1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Robot</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Robot</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Item1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Item1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>粘包的出现由两方面因素构成：</p><img src="cause.png"/><p>针对粘包现象，Netty提供了三种解决思路，</p><img src="solution2.png"/><p>了解了三种解决思路之后，我们发现固定长度和长度位两种方案对于服务端都需要改造，而分隔符的解决思路很好的契合了我们这种结构性很强的报文。最终我们选用了DelimiterBasedFrameDecoder，在ChannelInitHander中将Decoder加入Pipeline即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();<br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">delimiter</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(<span class="hljs-string">&quot;&lt;/Robot&gt;&quot;</span>.getBytes());<br>pipeline.addLast(<span class="hljs-string">&quot;delimiter&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelimiterBasedFrameDecoder</span>(<span class="hljs-number">1024</span>, <span class="hljs-literal">false</span>, delimiter));<br></code></pre></td></tr></table></figure><p>DelimiterBasedFrameDecoder需要传入三个参数。</p><ol><li>第一个参数1024是定义的最大字节长度，当报文长度超出1024，则丢弃该段报文，这个参数根据实际情况调整；</li><li>第二个参数false表示分隔符不被忽略也就是说分隔符也是作为报文的一部分需要读取。</li><li>第三个参数是传入的分隔符，我们选择结束符</Robot>作为分隔符。</li></ol><p>通过DelimiterBasedFrameDecoder的引入，我们的报文粘包拆包问题得到了解决。通过分隔符确保在客户端读缓冲区的数据是按照一个完整报文的分段被客户端读取，这种方式规避了服务端改动的复杂性，也避免了服务端和客户端同时修改的不一致性，在数据结构性很强的时候优先选择使用。</p><h2 id="总结展望"><a href="#总结展望" class="headerlink" title="总结展望"></a>总结展望</h2><p>在边缘数采的实现中，我们通过基于配置的客户端初始化方案，可以在一个边缘端管理多个客户端程序。通过断线重连机制确保了连接的高可用。16进制数据解析和粘包处理确保可以接收到正确的报文进行后续处理。</p><p>通过以上技术细节的实现，最终我们基于Netty搭建了一套符合FANUC机器人数采要求的边缘数采客户端。</p>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据采集</tag>
      
      <tag>应用技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么Java中的String设计成不可变的</title>
    <link href="/2020/03/13/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E7%9A%84String%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/"/>
    <url>/2020/03/13/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E7%9A%84String%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>原文出处：<a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/</a></p><p>在Java中String类是不可变的(final)。简单来说，一个不可变的类就意味着他的实例是不可修改的，实例的所有信息都是在实例创建的时候被初始化并且不可被修改。不可变类的设计有很多优点。这篇博文主要从内存，同步和数据结构的角度来具体说明这种不可变的概念。</p><span id="more"></span><h2 id="String-Pool-的需要"><a href="#String-Pool-的需要" class="headerlink" title="String Pool 的需要"></a>String Pool 的需要</h2><p>String Pool（String intern pool）是在方法区的一块特殊存储区域。当一个String被创建时如果发现当前String已经存在于String Pool，则会返回一个已存在String的引用而不会新建一个对象。以下代码只会创建一个String对象在堆内存中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">string2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br></code></pre></td></tr></table></figure><p>下图是创建的过程：</p><img src="string-create.png" /><p>假设一个String是可变的，改变了一个引用指向的String会导致其他引用得到错误的值。</p><h2 id="缓存-Hash-Code"><a href="#缓存-Hash-Code" class="headerlink" title="缓存 Hash Code"></a>缓存 Hash Code</h2><p>在Java中，对于String的Hash Code使用是非常频繁的，例如在HashMap或HashSet中。将String设计成不可变可以保证他的Hash Code始终一致，这样Hash Code就可以被缓存并且不用担心变化。这就意味着，不需要在每次使用String的时候都去计算他的Hash Code，这也使得程序运行更加高效。</p><h2 id="简化使用"><a href="#简化使用" class="headerlink" title="简化使用"></a>简化使用</h2><p>为了更加详细的阐述，我们考虑以下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>));<br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>));<br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;c&quot;</span>));<br> <br><span class="hljs-keyword">for</span>(String a: set)&#123;<br>a.value = <span class="hljs-string">&quot;a&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，如果String是可变的，那么就会违背set的设计初衷（set包含不重复的元素）。当然上面的例子只是为了论证，实际上String类中没有value这个字段。我们在使用set的时候同样要注意这个问题，如果set中的元素会发生变化，那么就有可能违背set的不重复设定。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>String在很多Java类中被广泛用作参数，例如网络连接，文件打开等。假设String是可变的，一个连接或者一个文件就可能被改变，这会导致严重的安全隐患。某个方法以为正在连接到一个机器，实际并没有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(String s)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!isSecure(s)) &#123; <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(); <br>&#125;<br>    <span class="hljs-comment">//here will cause problem, if s is changed before this by using other references.    </span><br>    causeProblem(s);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为不可变对象不能被改变，他们还可以在多线程中被自由的共享，这就消除了对象同步的需求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，String被设计成不可变的出发点是效率和安全。这也是不可变类在很多情况下被优先使用的原因。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个Slash引发的ClassNotFound血案</title>
    <link href="/2019/08/27/%E4%B8%80%E4%B8%AASlash%E5%BC%95%E5%8F%91%E7%9A%84ClassNotFound%E8%A1%80%E6%A1%88/"/>
    <url>/2019/08/27/%E4%B8%80%E4%B8%AASlash%E5%BC%95%E5%8F%91%E7%9A%84ClassNotFound%E8%A1%80%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>公司开发了一款Web应用，开发架构基于Spring Boot，通过jar包的方式发布到服务器并通过命令行运行在内置的Tomcat上。上线将近一年，一切都是那么的风平浪静，然而一切的平静被上周的一次现场算法回访打破。</p><p>我们的数据分析人员本意只是想查看一下历史数据来确认算法的表现符合预期，结果发现历史数据查询页面怎么点都没有反应，而其他页面都是正常的，服务重启后一切恢复正常。</p><h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>虽然问题通过服务重启后成功解决，但是出错的原因没有定位到也就意味着再次出错的可能性依然存在。</p><span id="more"></span><p>分析问题最直观的方式就是从错误出发，通过错误信息来反向推导错误发生的场景。在这个案例中我们查看了浏览器控制台和后台错误日志，最终获取了准确的错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2019</span>-08-<span class="hljs-number">23</span> <span class="hljs-number">14</span>:<span class="hljs-number">40</span>:<span class="hljs-number">47</span>,<span class="hljs-number">835</span> [http-nio-<span class="hljs-number">9090</span>-exec-<span class="hljs-number">8</span>] ERROR o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].[dispatcherServlet] - Servlet.service() <span class="hljs-keyword">for</span> servlet [dispatcherServlet] in context with path [] threw exception [java.lang.ClassNotFoundException: org.apache.jsp.WEB_002dINF.views.report.report_005fmain_jsp] with root cause<br>java.lang.ClassNotFoundException: org.apache.jsp.WEB_002dINF.views.report.report_005fmain_jsp<br>at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="hljs-number">381</span>)<br>at org.apache.jasper.servlet.JasperLoader.loadClass(JasperLoader.java:<span class="hljs-number">129</span>)<br>at org.apache.jasper.servlet.JasperLoader.loadClass(JasperLoader.java:<span class="hljs-number">60</span>)<br>at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:<span class="hljs-number">159</span>)<br>at org.apache.jasper.servlet.JspServletWrapper.getServlet(JspServletWrapper.java:<span class="hljs-number">171</span>)<br>at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:<span class="hljs-number">380</span>)<br>at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:<span class="hljs-number">386</span>)<br>at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:<span class="hljs-number">330</span>)<br>at javax.servlet.http.HttpServlet.service(HttpServlet.java:<span class="hljs-number">742</span>)<br>at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="hljs-number">231</span>)<br>at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="hljs-number">166</span>)<br>at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:<span class="hljs-number">52</span>)<br>at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="hljs-number">193</span>)<br>at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="hljs-number">166</span>)<br>at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:<span class="hljs-number">728</span>)<br>at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:<span class="hljs-number">470</span>)<br>at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:<br><br></code></pre></td></tr></table></figure><p>这是一个ClassNotFoundException，通过错误信息我们可以在搜索引擎上找到一堆解答，甚至在Spring Boot的Github上都有类似的情况(<a href="https://github.com/spring-projects/spring-boot/issues/5009)%E3%80%82">https://github.com/spring-projects/spring-boot/issues/5009)。</a></p><p>结果总结下来就是：</p><blockquote><p>Spring Boot内置的Tomcat会在系统根目录的&#x2F;tmp下创建Tomcat开头的临时目录，tmp目录的定时清理会导致部分文件的class文件找不到，解决办法是指定一个work目录不要使用默认的tmp目录。</p></blockquote><p>听起来很有道理，官方都这么说了那照着做就行了呗。</p><p>然而作为一个好奇心爆棚的程序员，这样的解释显得苍白而无力，但是这个解释倒是给我们的重现提供了很好的便利，毕竟只有充分重现了这个问题才能更好的去探究深层次的原因。 </p><p>于是在官方解释的指导下，我们进行了多次重现的尝试，最终将问题范围缩小如下：</p><p><span style="color:red">在Tomcat启动后将tmp下的ROOT目录删除，访问的第一个页面会出现无法访问的情况，后台出现ClassNotFoundException，之后再访问其他页面都是正常。</span></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在进行问题分析的时候，我们一般会使用三种方式</p><ul><li><p>经验法</p><p>结合自身的经验来猜测问题发生的可能原因，然后通过验证来定位问题具体原因</p></li><li><p>推导法</p><p>从问题的发生点开始倒推，沿着问题发生的路径逐步接近问题的根源</p></li><li><p>分析法</p><p>分析整个流程中的每一个节点，找到和问题可能相关的节点逐个验证从而找到导致问题的节点</p></li></ul><hr><p>经验法往往是遇到问题时第一个使用的方法，因为面对问题时冲在前面的往往是我们的直觉。在这个问题中我做了以下猜测，并逐一验证。</p><ol><li><p>class文件损坏</p><p>做出这个假设的依据是，在同一个目录下存在两个页面的Class文件，一个可以访问一个不可以访问。</p><p>验证方法也很简单，首先重启服务正常访问页面A获取到正常状态下的A.java和A.class文件；重启服务器后删除ROOT目录，再访问页面A触发错误，将目录下的java和class文件替换成正常状态的问题；再次访问页面，依然报错。</p><p>至此我们推翻了我们关于Class文件损坏的假设。</p></li><li><p>dev-tool导致classloader不一致</p><p>做出这个假设的依据是我们之前遇到的一个dev-tool的问题，Spring Boot在引入了dev-tool后会进行热加载，这时候由于jar包加载和class加载使用了不同的ClassLoader会出现ClassNotFoundException。</p><p>我们之前解决这个问题的方法是去掉dev-tool，同样在这里我们也可以去掉dev-tool再走一遍重现步骤，发现问题依然存在。</p><p>至此我们排除了Dev-tool导致ClassLoader不一致的假设。</p></li><li><p>class文件时间戳</p><p>在我们查看正常文件和异常文件差异的时候发现，正常文件的时间戳和jar包中的jsp时间戳一致，而异常文件的时间戳是当前时间，那会不会是因为时间戳不一致导致的呢。</p><p>为了验证这个假设我们从两方面入手a) 调整正常文件的时间戳到当前时间，结果正常文件依然正常 b) 调整异常文件的时间戳为jsp的时间，结果异常文件依然无法访问。</p><p>于是我们也排除了Class文件时间戳的假设。</p></li></ol><hr><p>推导法是比较直观也是可以比较快速的发现问题的方法，但是在我们这个案例中我们发现错误堆栈中的URLClassLoader并不是问题发生的第一现场，真正的第一现场在java自己的包中，对我们逐步跟踪问题造成了困难。</p><img src="classloader.png"/><hr><p>鉴于此我们选择分析法作为我们解决问题的突破口。当然还有一个重要条件支持我们采用分析法解决问题，那就是在我们这个案例中我们存在OK和NOK两种情况，在每一个分析的节点我们都可以引入两种情况进行对比。</p><p>在开始之前，由于要每一步比较差异，我们需要配置Eclipse的远程调试。传送门：(<a href="https://www.cnblogs.com/east7/p/10285955.html">https://www.cnblogs.com/east7/p/10285955.html</a>)</p><p>首先我们梳理一下Tomcat解析JSP的流程，由于我们基于类来描述流程，所以先罗列一下涉及的类以及主要的方法：</p><img src="jsp-class.png"/><p>JspServlet类是主入口，接收jsp请求；</p><p>JspRuntimeContext通过add和get方法来维持一个ServletWrapper的缓存；</p><p>从JspServlet往后是加载的主要类，而从Compiler往后的类是编译用到的类。</p><p>在大致了解了内部类结构后我们可以来看看Jsp加载的流程了，</p><img src="jsp-flow.png"/><p>从图中可以看出我们的报错点在获取Servlet的class这一步，那么我们从页面访问的步骤一步步比较OK和NOK表现的差异。</p><ol><li><p>获取ServletWrapper</p><p>这一步的作用是为每一个Jsp页面构建一个代理并缓存在JspRuntimeContext中，这样每次访问页面直接获取代理即可。从调试的结果看，构建wrapper的每个参数都是一样，而构建的wrapper结果也是一致的。</p></li><li><p>编译java文件</p><p>我们注意到在Complier.class的generateJava这个方法中有一步是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ctxt.checkOutputDir();<br></code></pre></td></tr></table></figure><p>我们的重现恰恰是删除了ROOT目录，继续进去看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkOutputDir</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outputDir != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(outputDir)).exists()) &#123;<br>                makeOutputDir();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            createOutputDir();<br>        &#125;<br>&#125;<br><span class="hljs-comment">//由于一开始的outputDir为空会进入createOutputDir方法</span><br><span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> options.getScratchDir();<br>            baseUrl = base.toURI().toURL();<br>            outputDir = base.getAbsolutePath() + File.separator + path +<br>                    File.separator;<br>            <span class="hljs-keyword">if</span> (!makeOutputDir()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(Localizer.getMessage(<span class="hljs-string">&quot;jsp.error.outputfolder&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (MalformedURLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(Localizer.getMessage(<span class="hljs-string">&quot;jsp.error.outputfolder&quot;</span>), e);<br>        &#125;<br><br></code></pre></td></tr></table></figure><p>这里对baseUrl进行赋值，联想到之前看到一个关于UrlClassPath加载资源的解读，ucp类会根据baseUrl来加载不同的loader进行资源加载。通过debug我们发现这个地方的baseUrl在OK和NOK两种情况下确实存在差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">NOK：<br>baseURL = file:/tmp/tomcat.2612162063177545213.9090/work/Tomcat/localhost/ROOT<br>OK：<br>baseURL = file:/tmp/tomcat.2612162063177545213.9090/work/Tomcat/localhost/ROOT/<br><br></code></pre></td></tr></table></figure><p>对照ucp的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Loader <span class="hljs-title function_">getLoader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> URL url)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> java.security.AccessController.doPrivileged(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.security.PrivilegedExceptionAction&lt;Loader&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Loader <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> url.getFile();<br>                    <span class="hljs-keyword">if</span> (file != <span class="hljs-literal">null</span> &amp;&amp; file.endsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;file&quot;</span>.equals(url.getProtocol())) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLoader</span>(url);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Loader</span>(url);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JarLoader</span>(url, jarHandler, lmap, acc);<br>                    &#125;<br>                &#125;<br>            &#125;, acc);<br>        &#125; <span class="hljs-keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;<br>            <span class="hljs-keyword">throw</span> (IOException)pae.getException();<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们发现当出现”&#x2F;”的时候我们是通过fileLoader来加载资源，而没有”&#x2F;”的情况我们默认到jarLoader，用jarLoader去加载一个文件路径当然会返回ClassNotFound了。</p></li></ol><hr><p>至此我们终于将这个问题的来龙去脉理清楚了，那这一个“&#x2F;”的差异是怎么来的呢，回到那段代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">baseUrl = base.toURI().toURL();<br>         outputDir = base.getAbsolutePath() + File.separator + path +<br>                 File.separator;<br>         <span class="hljs-keyword">if</span> (!makeOutputDir()) &#123;<br></code></pre></td></tr></table></figure><p>OK和NOK的情况base是一样的，唯一的区别就是OK的情况文件目录都是存在的，而NOK的时候文件夹是没有的，是不是这种差异导致了一个”&#x2F;”的差异呢，还是看代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//base.toURI():</span><br><span class="hljs-keyword">public</span> URI <span class="hljs-title function_">toURI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> getAbsoluteFile();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> slashify(f.getPath(), f.isDirectory());<br>            <span class="hljs-keyword">if</span> (sp.startsWith(<span class="hljs-string">&quot;//&quot;</span>))<br>                sp = <span class="hljs-string">&quot;//&quot;</span> + sp;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot;file&quot;</span>, <span class="hljs-literal">null</span>, sp, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (URISyntaxException x) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);         <span class="hljs-comment">// Can&#x27;t happen</span><br>        &#125;<br>    &#125;<br><span class="hljs-comment">//Slashify():</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">slashify</span><span class="hljs-params">(String path, <span class="hljs-type">boolean</span> isDirectory)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> path;<br>        <span class="hljs-keyword">if</span> (File.separatorChar != <span class="hljs-string">&#x27;/&#x27;</span>)<br>            p = p.replace(File.separatorChar, <span class="hljs-string">&#x27;/&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (!p.startsWith(<span class="hljs-string">&quot;/&quot;</span>))<br>            p = <span class="hljs-string">&quot;/&quot;</span> + p;<br>        <span class="hljs-keyword">if</span> (!p.endsWith(<span class="hljs-string">&quot;/&quot;</span>) &amp;&amp; isDirectory)<br>            p = p + <span class="hljs-string">&quot;/&quot;</span>;<br>        <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出只有满足isDirectory的判断才会给URI加上”&#x2F;”，在我们NOK的情况下由于文件夹不存在isDirectory返回false不会加上结尾的”&#x2F;”，导致了baseURI的差异，并最终导致了ClassNotFoundException的生产血案。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个案例中我们主要使用了经验法和分析法来定位问题，查找本源。</p><p>在经验分析的过程中我们遇到了阻碍，转而通过分析法分解了Tomcat对于Jsp请求的处理流程，在分析Jsp编译过程时发现会对baseURI进行赋值，结合我们已有的对URLClassLoader的加载过程的理解，于是我们对于baseURI的处理进行了着重分析。最终发现由于baseURI赋值时系统环境的差异导致了生成的baseURI产生了一个”&#x2F;”的差异，而这一个差异又导致资源加载的加载器选择差异，最终导致不合适的加载器加载不到资源的错误。</p><p>在问题的解决上我们还是沿用官方的说法，指定一个tmp url用来存放tomcat的临时文件，避免被删除。</p><p>参考材料：</p><p><a href="http://www.docjar.com/html/api/sun/misc/URLClassPath.java.html">http://www.docjar.com/html/api/sun/misc/URLClassPath.java.html</a></p><p><a href="https://www.jianshu.com/p/b8e331840961">https://www.jianshu.com/p/b8e331840961</a></p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计二进制1的代码解读</title>
    <link href="/2019/07/17/%E7%BB%9F%E8%AE%A1%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/2019/07/17/%E7%BB%9F%E8%AE%A1%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>为了适应边缘计算的需求决定投入学习Go语言的浪潮，用了10年的java突然要去接受一个风格完全不一样的语言感觉真是太刺激了。 在看《Go语言圣经》的时候看到里面的一个计算二进制中1的个数的程序popcount，觉得挺有意思就拿出来分享一下吧。</p><p>程序代码总计也没几行，可以说很一目了然了：</p> <span id="more"></span><img src="code.png"/><p>程序分为两个部分，</p><ol><li>初始化构造一个长度为256的数组</li><li>主程序PopCount通过8次右移操作分别求低8位的1数量然后相加</li></ol><p>那这么明显的结构，这么清晰的代码有啥好解读呢？主要原因是在第一遍看的时候产生了两个疑问，我觉得有必要记录一下解决疑惑的过程。</p><h2 id="初始化数组为什么是256"><a href="#初始化数组为什么是256" class="headerlink" title="初始化数组为什么是256"></a>初始化数组为什么是256</h2><p>这个问题需要和PopCount主程序结合看。</p><p>因为在主程序中使用的算法是将64位的无符号整数切割成8个8位，而8位的无符号整数取值范围是0-255，为了完整表示这256个数值的1的位数，所以使用了长度为256的数组。</p><h2 id="初始化算法的依据是什么"><a href="#初始化算法的依据是什么" class="headerlink" title="初始化算法的依据是什么"></a>初始化算法的依据是什么</h2><p>其实初始化的算法就一句话 pc[i] &#x3D; pc[i&#x2F;2] + byte(i&amp;1)，一句话就得出了整数中二进制1的个数字典表也太神奇了吧。怎么来理解这个算法呢？经验？定理？当然可以选择记住就行。</p><p>但是我们还是可以尝试着大声的念出这段代码的含义，</p><blockquote><p>整数 i 中1的个数等于整数 i&#x2F;2 中1的个数加上i在低1位的1的个数</p></blockquote><p>是不是有点灵感了？直接上图吧</p><img src="algorithm.png"/><p>从图中可以看出每个整数i的1的个数由两部分组成</p><ol><li>i&#x2F;2的1的个数，这部分就对应算法中的pc[i&#x2F;2]</li><li>i&#x2F;2的余数，这部分对应算法中的byte[i&amp;1]</li></ol><hr><p>到这里这段代码的疑惑就全部解开了，嗯就是这么Go！</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次性能事故的处理和总结</title>
    <link href="/2019/07/12/%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E4%BA%8B%E6%95%85%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2019/07/12/%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E4%BA%8B%E6%95%85%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>前几天做了一个工况统计的功能，查询最近7天的数据然后分析数据的分布。</p><p>从一开始接到这个需求就感觉哪里有点不对劲，上线一周后终于迎来了一次爆发：页面响应慢，多次查询后服务不可用。</p><span id="more"></span><img src="overview.png"/><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从线上环境拉取日志后发现两个异常表现，</p><ol><li>在进行查询分析的时候，后台会出现超时异常</li><li>经历了两到三次的超时异常后，出现了OOM导致系统服务不可用</li></ol><p>从日志的表现我们可以大致还原一下事故现场。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt; 用户点击查询分析功能，服务器开始吭哧吭哧的查询，由于数据量多导致查询的响应速度成为瓶颈<br>&gt;&gt; 用户在等了好久之后觉得页面是不是挂了，于是刷新页面并重新发起一次查询<br>&gt;&gt; 服务器重新启动一个线程继续开始漫长的吭哧吭哧之旅<br>&gt;&gt; 某一次的查询终于达到了熔断点，返回了超时异常，但是内存依然占用无法及时回收<br>&gt;&gt; 新的操作需要使用内存的时候，出现了OOM异常，系统服务不可用<br></code></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>我们从以下两方面进行验证，首先是通过问题重现验证我们关于事故现场的假设，其次通过分析代码来找出支持这种假设的依据。</p><h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><p>问题重现很容易，我们从客户现场拿回了全量的数据文件在本地就可以克隆一个现场环境。</p><p>然后按照我们设想的步骤进行操作，在第2步的时候等了将近1分钟，页面返回了一个空结果集，然后我们再点击一次查询，没过多久页面出现500错误服务已经不可用。</p><p>查看后台日志的表现和线上环境的表现一致，所以我们可以认为我们基本还原了现场。</p><p>唯一的不同是我们这边等了近1分钟后页面是有返回一个空的结果集，并不是设想中的一直等待。</p><h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><p>查看了该功能的相关代码后，我们定位出几个可能导致问题的代码片段。</p><img src="code_verify.png"/><ul><li>使用了线程池充分利用多线程的优势加快响应速度，这个没问题，但是当线程池被不恰当使用的时候很有可能造成系统资源得不到合理分配，最终导致OOM</li><li>在这里通过两个线程分别查询前一天的数据和前七天的数据，事实上这两部分数据是有重复的，多余的查询动作造成了资源的浪费</li><li>在线程阻塞的时候设置了15秒和30秒的查询超时时间，这里应该是造成日志中超时异常的根源</li></ul><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>结合问题重现和代码验证的结果，我们通过交叉验证进一步的确认症结所在。</p><ul><li><p>超时问题</p><p>在代码验证的过程中我们定位了两个代码片段，接下来我们就修改这两个片段，去掉超时时间的指定，一直等待到执行完成。</p><p>原代码：<code>dailyFuture.get(15, TimeUnit.SECONDS);</code></p><p>修改后：<code>dailyFuture.get();</code></p><p>通过这一步的验证，我们发现整个操作是可以返回结果的，只不过需要等将近2分钟，那么超时问题就转移为慢查询问题了。</p><p>接下来我们比较测试数据和线上数据后发现，线上数据比测试数据翻了一倍，原因是现场加大了采集频率，这样导致了我们预先实验出来的超时时间设定不符合数据要求。</p><p>由于数据量是我们不可控的，最终针对这个问题我们的解决思路是优化查询，减少查询所需要的时间。优化基线是数据量每天172w点,查询时间30秒，对象转换时间5-10秒。</p></li><li><p>OOM问题</p><p>针对OOM问题我们定位的原因是多线程，于是我们将整个查询过程查询7天的数据都串行化后，发现一次查询的内存占用都在1G以下，由于串行后资源得到及时释放，多次查询也不会造成OOM问题。</p><p>对比我们目前的设置，线程池设置的最大大小是30，每天的查询作为一个任务提交，理论上最多会在内存中保留30天的数据，OOM简直是一定的了。这样分析下来我们OOM的问题转移为线程池大小的合理设置问题，当然慢查询问题也是导致OOM问题的一个因素，因为查询一直没有返回导致资源无法被垃圾回收。</p></li></ul><p>总结下来，解决目前问题（超时和服务不可用）的突破口是:</p><ol><li>优化慢查询</li><li>合理设置线程池</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>通过上面的分析和验证过程我们已经找到了问题的两个突破口，其中设置线程池主要通过不断的优化调整完成，所以解决问题的重点我们放在了优化慢查询上。</p><p>我们将整个分布分析过程分解如下：</p><img src="query-flow.png"/><p>其中Influx查询和客户端对象转换属于我们慢查询的优化范畴，开始优化之前我们明确一下我们优化的基线，</p><table><thead><tr><th>数据量</th><th>Influx查询用时</th><th>对象转换用时</th></tr></thead><tbody><tr><td>1728000（20Hz）</td><td>30s</td><td>5~10s</td></tr></tbody></table><h3 id="Influx查询"><a href="#Influx查询" class="headerlink" title="Influx查询"></a>Influx查询</h3><p>对于Influx查询，我们首先分析执行过程：客户端通过Okhttp发送请求到Influx服务端，服务端执行查询语句，返回结果到客户端。</p><p>分析下来影响查询响应时间的因素主要有，</p><ol><li>传输因素，数据量对于网络传输的时间消耗</li><li>服务器因素，服务器负载性能对于influx的查询时间影响</li><li>查询语句，查询语句的不合理书写影响了influx的查询性能，如未使用时间和标签等索引</li></ol><p>首先我们看看我们的查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> history <span class="hljs-keyword">WHERE</span> item_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;%s&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-type">time</span><span class="hljs-operator">&gt;=</span><span class="hljs-operator">%</span>s <span class="hljs-keyword">and</span> <span class="hljs-type">time</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">%</span>s<br></code></pre></td></tr></table></figure><p>这个语句使用了time进行筛选，使用了item_code这个标签进行索引查询，但是在返回的结果集中使用了*返回了所有的字段。实际上我们这个需求只需要用到value字段，根据influx的查询接口我们针对每条记录只需要返回长度为2的数组，一个记录时间一个记录value。现在使用了*返回了很多无用的tag字段，结果集相当于翻倍了，改进后的查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">FROM</span> history <span class="hljs-keyword">WHERE</span> item_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;%s&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-type">time</span><span class="hljs-operator">&gt;=</span><span class="hljs-operator">%</span>s <span class="hljs-keyword">and</span> <span class="hljs-type">time</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">%</span>s<br></code></pre></td></tr></table></figure><p>仅仅通过这个小小的改动，每次查询的平均时间减少到20s。</p><p>顺着这个思路我们进一步缩减结果集，将原来写在代码中的一个过滤条件加入查询语句，最终的查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">FROM</span> history <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">ABS</span>(<span class="hljs-keyword">value</span>)<span class="hljs-operator">&gt;</span> <span class="hljs-operator">%</span>s <span class="hljs-keyword">and</span> item_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;%s&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-type">time</span><span class="hljs-operator">&gt;=</span><span class="hljs-operator">%</span>s <span class="hljs-keyword">and</span> <span class="hljs-type">time</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">%</span>s<br></code></pre></td></tr></table></figure><p>优化后的查询时间稳定在15s左右。</p><h3 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h3><p>对象转换阶段主要发生在influx客户端，通过InfluxDBResultMapper将服务端的Response转换成Pojo对象。</p><p>在这一步中我们定位了几个可能的优化点，</p><ol><li><p>将Response转换成Pojo相比于直接操作Response，多了一倍的内存占用</p><p>InfluxDB这样做可以确保通用性，而对于我们来说没有必要。</p></li><li><p>转换过程基于反射</p><p>为了找到Pojo和字段的对应关系，需要通过反射来保证通用性，我们在已经知道顺序的情况下直接赋值即可。</p></li><li><p>在遍历结果集的使用的stream而没有使用parallelstream</p><p>InfluxDB为了保证结果集解析的顺序性，而在我们的需求中对于顺序没有要求，所以可以利用并行流来提高处理效率。</p></li></ol><p>最终我们的方案是直接解析Response进行分析计算，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;DataItem&gt; <span class="hljs-title function_">queryToDataItem</span><span class="hljs-params">(String ql, String dbName, String tableName, InfluxDB influxDB)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Query</span>(ql, dbName);<br>            <span class="hljs-type">QueryResult</span> <span class="hljs-variable">queryResult</span> <span class="hljs-operator">=</span> influxDB.query(query, TimeUnit.MILLISECONDS);<br>            <span class="hljs-keyword">if</span>(!CommonUtil.isNullResponse(queryResult)) &#123;<br>            <span class="hljs-keyword">for</span>(Series s : queryResult.getResults().get(<span class="hljs-number">0</span>).getSeries()) &#123;<br>            <span class="hljs-keyword">if</span>(s.getName().equals(tableName)) &#123;<br>            <span class="hljs-keyword">return</span> s.getValues().stream()<br>            .map(row -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataItem</span>(<br>            ((Double)row.get(<span class="hljs-number">0</span>)).longValue(),<br>            (Double)row.get(<span class="hljs-number">1</span>))).collect(Collectors.toList());        <br>            &#125;<br>            &#125;<br>            &#125;<br>        <br>    &#125;<span class="hljs-keyword">catch</span>(Exception ex) &#123;<br>    LOG.error(<span class="hljs-string">&quot;Exception when query &#123;&#125;&quot;</span>, ex.getMessage());<br>    &#125;<br>    <br>        <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这一步优化，我们每一次查询后的转换可以控制在2s之内，而且大大降低了内存使用。反观InfluxDB客户端的实现，这也体现了代码中通用性和运行效率的博弈，我们可以合理利用tradeoff来实现我们的目的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过一起线上的事故作为切入点，首先通过经验进行合理的假设分析，得到一个可以模拟的事故现场。然后通过问题重现、代码定位和交叉验证的方式定位到最终需要解决的问题。在解决问题阶段我们根据我们在解决一般性能问题的经验，迁移到时序数据库性能问题的解决上，而最终的解决方案也证实了性能问题都是相通的。</p><p>通过以下表格可以看出我们优化的成效：</p><table><thead><tr><th></th><th>数据量</th><th>Influx查询用时</th><th>对象转换用时</th></tr></thead><tbody><tr><td>优化前</td><td>1728000</td><td>30s</td><td>5~10s</td></tr><tr><td>优化后</td><td>1728000</td><td>15s</td><td>2s</td></tr></tbody></table><p>也许有人会觉得查询花费将近20s还是有点慢，下面就分享一个这个过程中的趣事。</p><hr><p>针对这个问题，我和另一个同事分别进行优化。在优化到7次查询用时80s左右的时候，我感觉已经没有多大的余地了，结果他给出了他的优化结果是60s，出于好奇心我又花了一天时间在考虑资源利用最大化的情况下也还是在80左右徘徊。</p><p>最后我只能拿着他的方案过来研究一下，结果发现一跑要100多，于是检查一下机器配置后发现他的测试机是DDR4，而我的是DDR3。同样把我的优化方案放到他的机器上跑了一下，7天的查询时间为40s，相当于内存效率差了一倍。</p><h3 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h3><p>此外分享在InfluxDB调优中的两个花絮，</p><ol><li><p>使用chunk的方式并不能提升查询效率</p><p>chunk的方式其实是一种数据分页查询，通过串行的方式查询一个个子结果集。优点是可以快速返回并处理，减少资源锁时间。但是在百万级数据上的切分并没有到达查询引擎的临界点，相反增加了建立连接的次数和结果集处理的复杂度。</p></li><li><p>不使用绑定变量的方式查询速度更快</p><p>使用关系型数据库如MySql的经验告诉我们，在查询的时候使用绑定变量可以更加安全并且可以获得较好的查询性能。安全是毋庸置疑的，但是Influx对于更快的查询性能方面似乎没有实现，经过实测使用绑定变量的查询反而会慢一点。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于jsplumb的流程图实现</title>
    <link href="/2018/01/02/%E5%9F%BA%E4%BA%8Ejsplumb%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/01/02/%E5%9F%BA%E4%BA%8Ejsplumb%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在系统开发中经常需要展示一些流程，这时候需要用到流程图组件，但是在Echarts这些开源的可视化软件中居然没有流程图的支持。这时候我们的解决方案只能是用div和箭头图片自己实现一些简单的连接，如果流程稍微复杂一点，考虑兼顾功能和美观就需要投入大量的人力和精力进行一些造轮子的动作。</p><p>jsplumb的出现一定程度上解决了我们的烦恼。</p><span id="more"></span><h2 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h2><p>jsplumb是一款开源的javascript类库，基于SVG提供页面元素的连接。jsplumb提供了两个分支：</p><ul><li>Toolkit Edition商用版，基于社区版本进行封装提供更丰富的API支持</li><li>Community Edition社区版，基于MIT和GPL2协议进行开源，提供基础的API功能</li></ul><p>jsplumb的核心思想是对于页面元素的连接，在这个思想上对于连接进行了抽象，从而形成了jsplumb的几个基本要素：</p><ul><li><p>Anchor – 锚</p><p>锚点主要用来定位一个端点的位置，锚点是一个逻辑上而非实体的概念，用户不可以直接创建，而是通过内部的机制生成</p></li><li><p>Endpoint – 端点</p><p>作为每一个连接的终点而存在，可以通过编程来显式的创建</p></li><li><p>Connector – 连接器</p><p>连接器作为连接的抽象，提供了两个元素之间进行连接的方式</p></li><li><p>Overlay – 镀层</p><p>jsplumb通过镀层的方式给为连接器进行用户友好的展示，如通过label的方式</p></li><li><p>Group – 分组</p><p>通过分组可以将一组元素作为一个整体，从而进行整体的拖拽和收缩等</p></li></ul><blockquote><p>一般来说两个端点，一个连接器，0到多个镀层一起工作共同组成了一次连接。每一个端点都有一个关联的锚点。</p></blockquote><h2 id="技术攻关"><a href="#技术攻关" class="headerlink" title="技术攻关"></a>技术攻关</h2><p>在熟悉了jsplumb主要的概念后，可以通过官方API了解一些主要功能。同时可以通过<a href="https://github.com/jsplumb/jsplumb/tree/master/demo">github</a> 下载官方demo进行学习。通过观察，我们发现官方demo中的flowchart比较符合我们的需求，于是我们下载flowchart的demo源码进行研究改造。原始的demo效果图如下：</p><img src="original.png"/><p>下面列出几个主要攻关点：</p><h3 id="代码合并压缩"><a href="#代码合并压缩" class="headerlink" title="代码合并压缩"></a>代码合并压缩</h3><p>我们发现在demo中引入了一堆js和css，我们通过合并压缩最后形成了下面三个文件，</p><ol><li><p>jsplumb-link.min.js</p><p>包含jsbezier.js，mottle.js，biltong.js和katavorio.js</p></li><li><p>jsplumb-lib.min.js</p><p>包含jsplumb核心类库相关的16个js文件，注意合并的顺序</p></li><li><p>jsPlumb_process.js</p><p>process组件相关的js，基于jsplumb的封装和客户化</p></li></ol><h3 id="去除镀层的文字"><a href="#去除镀层的文字" class="headerlink" title="去除镀层的文字"></a>去除镀层的文字</h3><p>在connectionOverlay定义中发现同时对于箭头和文字都做了定义，直接将对于label的定义去除即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json">ConnectionOverlays<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;Arrow&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>                location<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                visible<span class="hljs-punctuation">:</span><span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>                width<span class="hljs-punctuation">:</span><span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>                length<span class="hljs-punctuation">:</span><span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>                id<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ARROW&quot;</span><span class="hljs-punctuation">,</span><br>                events<span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                    click<span class="hljs-punctuation">:</span>function() <span class="hljs-punctuation">&#123;</span> alert(<span class="hljs-string">&quot;you clicked on the arrow overlay&quot;</span>)<span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span><br>    <span class="hljs-comment">/*,</span><br><span class="hljs-comment">            [ &quot;Label&quot;, &#123;</span><br><span class="hljs-comment">                location: 0.1,</span><br><span class="hljs-comment">                id: &quot;label&quot;,</span><br><span class="hljs-comment">                cssClass: &quot;aLabel&quot;,</span><br><span class="hljs-comment">                events:&#123;</span><br><span class="hljs-comment">                    tap:function() &#123; alert(&quot;hey&quot;); &#125;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;]*/</span><br>        <span class="hljs-punctuation">]</span><br><br></code></pre></td></tr></table></figure><h3 id="禁止新增连接"><a href="#禁止新增连接" class="headerlink" title="禁止新增连接"></a>禁止新增连接</h3><p>在官方demo中可以通过鼠标拖动来新增一条连接，而API并没有对于连接的enable和disable的定义。Github有人回复说通过设置ConnectionsDetachable 属性来实现，实际效果并不能达到目的。</p><p>最终在初始化方法中通过两个方法的组合实现了这个功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">instance.<span class="hljs-title function_">unmakeEveryTarget</span>().<span class="hljs-title function_">unmakeEverySource</span>();<br></code></pre></td></tr></table></figure><h3 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h3><p>数据导出功能在社区版不提供方法支持，不过我们可以通过一些简单的变通来实现；而导出功能和加载功能是相对应的，实现了数据的导出就可以基于现有的数据结构来实现数据的初始化加载。以下是导出方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">exportData</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> blocks=[]; <br>    $(<span class="hljs-string">&quot;.w&quot;</span>).<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">idx, elem</span>)&#123;<br>        <span class="hljs-keyword">var</span> elem=$(elem);<br>        blocks.<span class="hljs-title function_">push</span>(&#123;<br>            <span class="hljs-title class_">BlockId</span>:elem.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;id&#x27;</span>),<br>            <span class="hljs-title class_">BlockContent</span>:elem.<span class="hljs-title function_">text</span>(),<br>            <span class="hljs-title class_">BlockX</span>:<span class="hljs-built_in">parseInt</span>(elem.<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;left&quot;</span>), <span class="hljs-number">10</span>),<br>            <span class="hljs-title class_">BlockY</span>:<span class="hljs-built_in">parseInt</span>(elem.<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;top&quot;</span>), <span class="hljs-number">10</span>)<br>        &#125;);<br>    &#125;);<br>    <span class="hljs-keyword">var</span> serliza=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(blocks);<br>    $(<span class="hljs-string">&quot;#outputText&quot;</span>).<span class="hljs-title function_">text</span>(serliza);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要思路是获取页面元素的id和名称以及他们和容器的相对位置，最终通过json的格式进行存储。至于元素之间的关系通过业务系统保存和维护。</p><p>相应的我们可以实现我们的导入方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> loadJson = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br><span class="hljs-keyword">var</span> unpack=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);<br><span class="hljs-keyword">if</span>(!unpack)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;        <br>unpack.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, array</span>) &#123;<br><span class="hljs-keyword">var</span> _block = <span class="hljs-built_in">eval</span>(value);<br><span class="hljs-title function_">newNodeWithName</span>(_block.<span class="hljs-property">BlockId</span>,_block.<span class="hljs-property">BlockContent</span>, _block.<span class="hljs-property">BlockX</span>, _block.<span class="hljs-property">BlockY</span>);<br>&#125;);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>    <br><span class="hljs-keyword">var</span> newNodeWithName = <span class="hljs-keyword">function</span>(<span class="hljs-params">id, name, x, y</span>)&#123;<br>    <span class="hljs-keyword">var</span> d = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>        d.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;w&quot;</span>;<br>        d.<span class="hljs-property">id</span> = id;<br>        d.<span class="hljs-property">innerHTML</span> = name.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>) + <span class="hljs-string">&quot;&lt;div class=\&quot;ep\&quot;&gt;&lt;/div&gt;&quot;</span>;<br>        d.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = x+ <span class="hljs-string">&quot;px&quot;</span>;<br>        d.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = y+ <span class="hljs-string">&quot;px&quot;</span>;<br>        instance.<span class="hljs-title function_">getContainer</span>().<span class="hljs-title function_">appendChild</span>(d);<br>        <span class="hljs-title function_">initNode</span>(d);<br>        <span class="hljs-keyword">return</span> d;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实现思路是通过解析json获取每一个元素的id和name并通过相对位置在容器中绘制出来。</p><h3 id="自动对齐"><a href="#自动对齐" class="headerlink" title="自动对齐"></a>自动对齐</h3><p>通过页面拖动的元素不像传统的流程图工具提供自动对齐的功能，我们基于像素级别对元素对齐进行了基本的约束。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">def<br> X(e) = 元素e的起始横坐标<br> Y(e) = 元素e的起始纵坐标<br> W(e) = 元素e的宽度<br> H(e) = 元素e的高<br>    <br>if abs(Diff(X(a),X(b))) between (0, W(a)) set X(a) = X(b)<br>if abs(Diff(Y(a),Y(b))) between (0, H(a)) set Y(a) = Y(b)<br><br></code></pre></td></tr></table></figure><p>实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">autoAlignment</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> baseX = <span class="hljs-title class_">Number</span>($(<span class="hljs-string">&quot;.w&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;width&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;px&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));   <br>   <span class="hljs-keyword">var</span> baseY = <span class="hljs-title class_">Number</span>($(<span class="hljs-string">&quot;.w&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;height&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;px&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<br>   <span class="hljs-keyword">var</span> thatX=<span class="hljs-number">0</span>, thatY=<span class="hljs-number">0</span>, thisX = <span class="hljs-number">0</span>, thisY=<span class="hljs-number">0</span>, deltaX = <span class="hljs-number">0</span>, deltaY = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">var</span> eleArray = $(<span class="hljs-string">&quot;.w&quot;</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span> ; i &lt; eleArray.<span class="hljs-property">length</span>; i++)&#123;<br> thatX = <span class="hljs-title class_">Number</span>($(eleArray[i]).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;left&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;px&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<br> thatY = <span class="hljs-title class_">Number</span>($(eleArray[i]).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;top&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;px&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j =i+<span class="hljs-number">1</span>; j &lt; eleArray.<span class="hljs-property">length</span>; j++)&#123;<br>   thisX = <span class="hljs-title class_">Number</span>($(eleArray[j]).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;left&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;px&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<br>   thisY = <span class="hljs-title class_">Number</span>($(eleArray[j]).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;top&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;px&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<br>   deltaX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(thisX - thatX);<br>   deltaY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(thisY - thatY);<br>   <span class="hljs-keyword">if</span>(deltaX &lt; baseX &amp;&amp; deltaX &gt;<span class="hljs-number">0</span> &amp;&amp; deltaY &gt;=baseY)&#123;<br>     <span class="hljs-comment">// 需要调整x</span><br>             $(eleArray[j]).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;left&quot;</span>,thatX+<span class="hljs-string">&quot;px&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">if</span>(deltaY &lt; baseY &amp;&amp; deltaY &gt;<span class="hljs-number">0</span> &amp;&amp; deltaX &gt;=baseX)&#123;<br>     $(eleArray[j]).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;top&quot;</span>,thatY+<span class="hljs-string">&quot;px&quot;</span>);<br>   &#125;<br> &#125;<br>   &#125;<br>   <span class="hljs-comment">//通过repaintEverything完成位置调整后的重绘</span><br>   instance.<span class="hljs-title function_">repaintEverything</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Zoom缩放"><a href="#Zoom缩放" class="headerlink" title="Zoom缩放"></a>Zoom缩放</h3><p>同样由于在社区版不提供zoom的接口，我们只能通过自己来实现zoom功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">setZoom</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">zoom, instance0, transformOrigin, el</span>) &#123;<br>        transformOrigin = transformOrigin || [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>];<br>    instance = instance || jsPlumb;<br>    el = el || instance.<span class="hljs-title function_">getContainer</span>();<br>    <span class="hljs-keyword">var</span> p = [<span class="hljs-string">&quot;webkit&quot;</span>, <span class="hljs-string">&quot;moz&quot;</span>, <span class="hljs-string">&quot;ms&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>],<br>            s = <span class="hljs-string">&quot;scale(&quot;</span> + zoom + <span class="hljs-string">&quot;)&quot;</span>,<br>            oString = (transformOrigin[<span class="hljs-number">0</span>] * <span class="hljs-number">100</span>) + <span class="hljs-string">&quot;% &quot;</span> + (transformOrigin[<span class="hljs-number">1</span>] * <span class="hljs-number">100</span>) + <span class="hljs-string">&quot;%&quot;</span>;<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-property">length</span>; i++) &#123;<br>        el.<span class="hljs-property">style</span>[p[i] + <span class="hljs-string">&quot;Transform&quot;</span>] = s;<br>        el.<span class="hljs-property">style</span>[p[i] + <span class="hljs-string">&quot;TransformOrigin&quot;</span>] = oString;<br>    &#125;<br><br>    el.<span class="hljs-property">style</span>[<span class="hljs-string">&quot;transform&quot;</span>] = s;<br>    el.<span class="hljs-property">style</span>[<span class="hljs-string">&quot;transformOrigin&quot;</span>] = oString;<br><br>    instance.<span class="hljs-title function_">setZoom</span>(zoom, <span class="hljs-literal">true</span>);<br>    instance.<span class="hljs-title function_">repaintEverything</span>();<br>    <br>&#125;;<br><br></code></pre></td></tr></table></figure><p>实现思路通过监听事件来设置style属性实现滚动，最终调用重绘方法进行整体调整。需要注意的是监听事件应该绑定到容器的上一层，如下图的外层div部分，否则缩放的是整个页面起不到zoom流程图的初衷</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jtk-canvas canvas-wide process-canvas jtk-surface jtk-surface-nopan&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jtk-surface-canvas&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;overflow:visible !important;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;canvas&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>我们通过对于jsplumb的客户化开发，实现了部分商用版本独有的功能，从而使得基于社区版的应用可以满足复杂业务使用的需求。其中比较核心的是数据交互部分，我们在jsplumb已有概念的基础上将页面元素封装成带有位置信息的组件进行保存和加载，实现了前后端的连接。</p>]]></content>
    
    
    <categories>
      
      <category>技术总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技术</tag>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信登录集成</title>
    <link href="/2017/09/01/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E9%9B%86%E6%88%90/"/>
    <url>/2017/09/01/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>平台上线快一年了，注册人数却始终不见起色，看着下面这注册走势可把大伙儿急的。一着急一上火就刷朋友圈，朋友圈，朋友圈？灵感来了有没有？ </p><p>如果我们可以支持微信登录，那么微信日活5.7亿岂不都是我们的潜在客户了？不用多久升职加薪，当上总经理，出任CEO，迎娶白富美，走上人生巅峰。想想还有点小激动呢。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>说干就干，程序员一般套路：<code>代码未动，文档先行</code>。先找到微信开放平台（<a href="https://open.weixin.qq.com)-&gt;/">https://open.weixin.qq.com）-&gt;</a> 资源中心-&gt; 网站应用，把开发文档刷一遍。不管看没看懂咱都是看过源代码，噢不原文档的人了。</p><p>象征性的总结一下，主要分三步走：</p><ol><li>授权换code（开门）</li><li>code换token（找钥匙）</li><li>token获取用户消息（该干啥干啥）</li></ol><p>当然，如果你觉得找到了钥匙你就拥有了全世界那你就simple simple了。用着人家的文档，坐拥5.7亿的日活，不交点保护费合适吗？</p><p>首先你要在开放平台注册一个账号，并通过开发者资质认证（300大洋一年）。然后到管理中心，创建一个网站应用并通过审核，这个不要钱。</p><blockquote><p>注:这里面有一个很重要的字段，叫授权回调域，最好和实际开发的回调域名保持一致。</p><p>网上很多文章说可以配置成顶级域名，开发使用二级域名，反正我试过这样不通，</p><p>错误信息：redirect_uri 参数错误。</p></blockquote><p>OK，到此为止，你才真正拥有了全世界。</p><h2 id="集成设计"><a href="#集成设计" class="headerlink" title="集成设计"></a>集成设计</h2><p>既然是登录集成首先我们需要审视用户模型，我们原来的用户模型是简单的用户密码认证方式，简单来说就是一张主用户表，加一堆外延表。这无疑给我们用户的扩展提供了便利，本着KISS的原则，我们的用户模型最终修改如下：</p><img src="user-diagram.png"/><p>主要的改动点就是增加了一个t_wx_bind_info表，围绕这个数据模型，我们的逻辑可以如下展开：</p><ol><li>首次微信登录，获取用户信息后保存至t_wx_bind_info, 此时的微信注册信息处于<strong>游离态</strong>，用户通过后续选择a) 绑定到现有用户 b) 创建新用户 将微信注册用户转化为<strong>激活态</strong></li><li>未绑定微信用户登录，用户授权后获取access token，通过token里面的unionId获取加载t_wx_bind_info中游离态的用户信息，用户同样需要通过选择来将<strong>游离态</strong>转化为<strong>激活态</strong></li><li>已绑定微信用户登录，用户授权后获取access token，通过token里面的unionId获取t_wx_bind_info中激活态的用户并做正常登陆，之后用户可以通过用户管理模块进行微信解绑</li><li>系统账号登录，普通账号可以通过账号管理模块进行账号绑定和解绑</li></ol><p>也许一张图来的更直观点，</p><img src="flow.png"/><blockquote><p>关于用户解绑后t_wx_bind_info的思考<br>正常来说我们有两个选择，<br>删除这条信息，每次绑定从头来过<br>恢复至游离态，下次绑定的时候直接使用<br>至于取舍见仁见智，每个选择都是优劣并存的，其实只要明白各自的优劣使用哪种方案并不重要。</p></blockquote><h2 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h2><p>俗话说的好，talk is cheap, show me the code.</p><p>那接下来就是coding show了，主要是记录一下开发的过程，方便以后用到的时候复制粘贴。</p><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h3><p>登录页面增加微信登录的按钮，至于背景图片可以到开放平台的资源中心下载相应尺寸的背景图片。</p><p>给登录按钮添加事件，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> dName = <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span>;<br><span class="hljs-keyword">var</span> redirectUri = <br><span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-string">&quot;http://&quot;</span> +dName+<span class="hljs-string">&quot;&lt;%=request.getContextPath()%&gt;/wechat_callback.do?rout=fromLogin&quot;</span>);<br><span class="hljs-keyword">var</span> wechatLoginUrl = <br><span class="hljs-string">&quot;https://open.weixin.qq.com/connect/qrconnect?appid=wx62c35d8f6a203158&quot;</span><br>+<span class="hljs-string">&quot;&amp;redirect_uri=&quot;</span>+redirectUri<br>+<span class="hljs-string">&quot;&amp;response_type=code&amp;scope=snsapi_login&amp;state=123#wechat_redirect&quot;</span>;<br>location.<span class="hljs-property">href</span> = wechatLoginUrl;<br></code></pre></td></tr></table></figure><p>实现的效果，是点击按钮后会跳到微信自己的二维码页面。</p><img src="qr-code.png"/><p>注意点：</p><ul><li>RedirectUrl需要经过urlEncode</li><li>AppId需要通过微信开发者资质认证后获得</li><li>其他参数按照文档填写即可</li></ul><h3 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h3><p>程序入口是redirectUrl指向的地址，一般是一个restful的资源。类图如下：</p><img src="class-diagram.png"/><p>在wechatCallback类中有两个分支分别处理扫码登录后的回调和账号登录后绑定微信的回调。主要的区别是重定向的页面和错误页面不同。</p><ul><li><p>扫码登录</p><p>成功后跳转到信息补全页面，失败后跳转到登录页面并提示错误信息。</p></li><li><p>登录绑定</p><p>成功后跳转到当前页面，失败后跳转到当前页面并提示错误信息。</p></li></ul><p>BindService主要处理t_wx_bind_info表的CRUD操作，sync方法用于同步微信信息和账户信息。 </p><p>WechatUtil类是连接微信API的工具类，主要逻辑是通过httpClient组装请求信息与微信服务器进行信息交换。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><ol><li><p>登录页面</p><img src="step1.png"/></li><li><p>扫码成功</p><img src="step2.png"/></li><li><p>跳转到信息补全，可以选择新创建账号还是绑定已有账号</p><img src="step3.png"/></li><li><p>选择绑定到已有账户，输入用户密码后就直接完成登录并可以看到微信绑定状态是已绑定</p><img src="step4.png"/></li></ol><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li><p>AppId参数不对</p><p>这个问题主要是在开发者资质认证阶段，我随便编个参数遇到的问题，填写正确的appId就可以了</p></li><li><p>RedirectUrl参数不对</p><p>这个问题前面也说过了，在网站申请的时候回调域名一定要和开发的redirectUrl一致。比如申请的回调域名是manulism.com, redirectUrl使用test.manulism.com则会出现这个问题。</p></li><li><p>本地测试的问题</p><p>由于微信平台配置的时候只接受回调域名，所以在本地要测试需要修改hosts文件里的域名mapping，文件目录在C:\Windows\System32\drivers\etc</p><p>新增一行：</p><p>192.168.8.254  test.manulism.com</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应用技术</tag>
      
      <tag>系统集成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2016/05/26/hello-world/"/>
    <url>/2016/05/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="生成的文件目录错乱"><a href="#生成的文件目录错乱" class="headerlink" title="生成的文件目录错乱"></a>生成的文件目录错乱</h3><p>原因是Next主题解析机制是二级目录、三级目录的按级解析，如果文章中出现了跳级的情况就会出现文件目录错乱。修复办法就是使用层层递进的目录定义。</p><h3 id="修改每页文章数量"><a href="#修改每页文章数量" class="headerlink" title="修改每页文章数量"></a>修改每页文章数量</h3><p>在hexo的_config.yml中修改per_page配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
